Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Unused terminals:

    FUNC
    SEMICOLON
    COLON

Grammar

Rule 0     S' -> func
Rule 1     func -> asign
Rule 2     funcx -> vars
Rule 3     funcx -> empty
Rule 4     block -> LBRACKET blockx RBRACKET
Rule 5     blockx -> statement blockx
Rule 6     blockx -> empty
Rule 7     vars -> type ID
Rule 8     type -> INT
Rule 9     type -> FLOAT
Rule 10    statement -> asign
Rule 11    statement -> condition
Rule 12    statement -> cycle
Rule 13    statement -> print
Rule 14    statement -> list
Rule 15    statement -> call
Rule 16    statement -> move
Rule 17    statement -> eat
Rule 18    statement -> clean
Rule 19    statement -> play
Rule 20    statement -> add
Rule 21    statement -> turnleft
Rule 22    statement -> turnright
Rule 23    asign -> ID EQUAL expression
Rule 24    expression -> exp
Rule 25    exp -> termino PLUS termino
Rule 26    exp -> termino MINUS termino
Rule 27    exp -> termino MULTIPLY termino
Rule 28    exp -> termino DIVIDE termino
Rule 29    exp -> termino COMPARISON termino
Rule 30    exp -> termino
Rule 31    termino -> LPAR expression RPAR
Rule 32    termino -> PLUS varcte
Rule 33    termino -> MINUS varcte
Rule 34    termino -> varcte
Rule 35    varcte -> ID
Rule 36    varcte -> NUMINT
Rule 37    varcte -> NUMFLOAT
Rule 38    print -> PRINT LPAR printx RPAR
Rule 39    printx -> expression
Rule 40    printx -> STRING
Rule 41    printx -> expression COMA printx
Rule 42    printx -> STRING COMA printx
Rule 43    cycle -> WHILE LPAR expression RPAR block
Rule 44    condition -> IF LPAR expression RPAR block
Rule 45    condition -> IF LPAR expression RPAR block ELSE block
Rule 46    list -> LIST ID EQUAL LBRACKET listx RBRACKET
Rule 47    listx -> ID
Rule 48    listx -> NUMINT
Rule 49    listx -> ID COMA listx
Rule 50    listx -> NUMINT COMA listx
Rule 51    call -> ID LPAR RPAR
Rule 52    call -> ID LPAR ID RPAR
Rule 53    move -> MOVE LPAR ID RPAR
Rule 54    eat -> EAT LPAR ID RPAR
Rule 55    clean -> CLEAN LPAR ID RPAR
Rule 56    play -> PLAY LPAR ID RPAR
Rule 57    add -> ID POINT ADD LPAR CANDY RPAR
Rule 58    add -> ID POINT ADD LPAR POOP RPAR
Rule 59    add -> ID POINT ADD LPAR BALL RPAR
Rule 60    turnleft -> TURNLEFT LPAR RPAR
Rule 61    turnright -> TURNRIGHT LPAR RPAR
Rule 62    empty -> <empty>

Terminals, with rules where they appear

ADD                  : 57 58 59
BALL                 : 59
CANDY                : 57
CLEAN                : 55
COLON                : 
COMA                 : 41 42 49 50
COMPARISON           : 29
DIVIDE               : 28
EAT                  : 54
ELSE                 : 45
EQUAL                : 23 46
FLOAT                : 9
FUNC                 : 
ID                   : 7 23 35 46 47 49 51 52 52 53 54 55 56 57 58 59
IF                   : 44 45
INT                  : 8
LBRACKET             : 4 46
LIST                 : 46
LPAR                 : 31 38 43 44 45 51 52 53 54 55 56 57 58 59 60 61
MINUS                : 26 33
MOVE                 : 53
MULTIPLY             : 27
NUMFLOAT             : 37
NUMINT               : 36 48 50
PLAY                 : 56
PLUS                 : 25 32
POINT                : 57 58 59
POOP                 : 58
PRINT                : 38
RBRACKET             : 4 46
RPAR                 : 31 38 43 44 45 51 52 53 54 55 56 57 58 59 60 61
SEMICOLON            : 
STRING               : 40 42
TURNLEFT             : 60
TURNRIGHT            : 61
WHILE                : 43
error                : 

Nonterminals, with rules where they appear

add                  : 20
asign                : 1 10
block                : 43 44 45 45
blockx               : 4 5
call                 : 15
clean                : 18
condition            : 11
cycle                : 12
eat                  : 17
empty                : 3 6
exp                  : 24
expression           : 23 31 39 41 43 44 45
func                 : 0
funcx                : 
list                 : 14
listx                : 46 49 50
move                 : 16
play                 : 19
print                : 13
printx               : 38 41 42
statement            : 5
termino              : 25 25 26 26 27 27 28 28 29 29 30
turnleft             : 21
turnright            : 22
type                 : 7
varcte               : 32 33 34
vars                 : 2

Parsing method: LALR

state 0

    (0) S' -> . func
    (1) func -> . asign
    (23) asign -> . ID EQUAL expression

    ID              shift and go to state 1

    func                           shift and go to state 2
    asign                          shift and go to state 3

state 1

    (23) asign -> ID . EQUAL expression

    EQUAL           shift and go to state 4


state 2

    (0) S' -> func .



state 3

    (1) func -> asign .

    $end            reduce using rule 1 (func -> asign .)


state 4

    (23) asign -> ID EQUAL . expression
    (24) expression -> . exp
    (25) exp -> . termino PLUS termino
    (26) exp -> . termino MINUS termino
    (27) exp -> . termino MULTIPLY termino
    (28) exp -> . termino DIVIDE termino
    (29) exp -> . termino COMPARISON termino
    (30) exp -> . termino
    (31) termino -> . LPAR expression RPAR
    (32) termino -> . PLUS varcte
    (33) termino -> . MINUS varcte
    (34) termino -> . varcte
    (35) varcte -> . ID
    (36) varcte -> . NUMINT
    (37) varcte -> . NUMFLOAT

    LPAR            shift and go to state 5
    PLUS            shift and go to state 8
    MINUS           shift and go to state 7
    ID              shift and go to state 13
    NUMINT          shift and go to state 6
    NUMFLOAT        shift and go to state 11

    expression                     shift and go to state 12
    termino                        shift and go to state 9
    exp                            shift and go to state 10
    varcte                         shift and go to state 14

state 5

    (31) termino -> LPAR . expression RPAR
    (24) expression -> . exp
    (25) exp -> . termino PLUS termino
    (26) exp -> . termino MINUS termino
    (27) exp -> . termino MULTIPLY termino
    (28) exp -> . termino DIVIDE termino
    (29) exp -> . termino COMPARISON termino
    (30) exp -> . termino
    (31) termino -> . LPAR expression RPAR
    (32) termino -> . PLUS varcte
    (33) termino -> . MINUS varcte
    (34) termino -> . varcte
    (35) varcte -> . ID
    (36) varcte -> . NUMINT
    (37) varcte -> . NUMFLOAT

    LPAR            shift and go to state 5
    PLUS            shift and go to state 8
    MINUS           shift and go to state 7
    ID              shift and go to state 13
    NUMINT          shift and go to state 6
    NUMFLOAT        shift and go to state 11

    expression                     shift and go to state 15
    termino                        shift and go to state 9
    exp                            shift and go to state 10
    varcte                         shift and go to state 14

state 6

    (36) varcte -> NUMINT .

    PLUS            reduce using rule 36 (varcte -> NUMINT .)
    MINUS           reduce using rule 36 (varcte -> NUMINT .)
    MULTIPLY        reduce using rule 36 (varcte -> NUMINT .)
    DIVIDE          reduce using rule 36 (varcte -> NUMINT .)
    COMPARISON      reduce using rule 36 (varcte -> NUMINT .)
    RPAR            reduce using rule 36 (varcte -> NUMINT .)
    $end            reduce using rule 36 (varcte -> NUMINT .)


state 7

    (33) termino -> MINUS . varcte
    (35) varcte -> . ID
    (36) varcte -> . NUMINT
    (37) varcte -> . NUMFLOAT

    ID              shift and go to state 13
    NUMINT          shift and go to state 6
    NUMFLOAT        shift and go to state 11

    varcte                         shift and go to state 16

state 8

    (32) termino -> PLUS . varcte
    (35) varcte -> . ID
    (36) varcte -> . NUMINT
    (37) varcte -> . NUMFLOAT

    ID              shift and go to state 13
    NUMINT          shift and go to state 6
    NUMFLOAT        shift and go to state 11

    varcte                         shift and go to state 17

state 9

    (25) exp -> termino . PLUS termino
    (26) exp -> termino . MINUS termino
    (27) exp -> termino . MULTIPLY termino
    (28) exp -> termino . DIVIDE termino
    (29) exp -> termino . COMPARISON termino
    (30) exp -> termino .

    PLUS            shift and go to state 20
    MINUS           shift and go to state 22
    MULTIPLY        shift and go to state 21
    DIVIDE          shift and go to state 19
    COMPARISON      shift and go to state 18
    $end            reduce using rule 30 (exp -> termino .)
    RPAR            reduce using rule 30 (exp -> termino .)


state 10

    (24) expression -> exp .

    $end            reduce using rule 24 (expression -> exp .)
    RPAR            reduce using rule 24 (expression -> exp .)


state 11

    (37) varcte -> NUMFLOAT .

    PLUS            reduce using rule 37 (varcte -> NUMFLOAT .)
    MINUS           reduce using rule 37 (varcte -> NUMFLOAT .)
    MULTIPLY        reduce using rule 37 (varcte -> NUMFLOAT .)
    DIVIDE          reduce using rule 37 (varcte -> NUMFLOAT .)
    COMPARISON      reduce using rule 37 (varcte -> NUMFLOAT .)
    RPAR            reduce using rule 37 (varcte -> NUMFLOAT .)
    $end            reduce using rule 37 (varcte -> NUMFLOAT .)


state 12

    (23) asign -> ID EQUAL expression .

    $end            reduce using rule 23 (asign -> ID EQUAL expression .)


state 13

    (35) varcte -> ID .

    PLUS            reduce using rule 35 (varcte -> ID .)
    MINUS           reduce using rule 35 (varcte -> ID .)
    MULTIPLY        reduce using rule 35 (varcte -> ID .)
    DIVIDE          reduce using rule 35 (varcte -> ID .)
    COMPARISON      reduce using rule 35 (varcte -> ID .)
    RPAR            reduce using rule 35 (varcte -> ID .)
    $end            reduce using rule 35 (varcte -> ID .)


state 14

    (34) termino -> varcte .

    $end            reduce using rule 34 (termino -> varcte .)
    RPAR            reduce using rule 34 (termino -> varcte .)
    PLUS            reduce using rule 34 (termino -> varcte .)
    MINUS           reduce using rule 34 (termino -> varcte .)
    MULTIPLY        reduce using rule 34 (termino -> varcte .)
    DIVIDE          reduce using rule 34 (termino -> varcte .)
    COMPARISON      reduce using rule 34 (termino -> varcte .)


state 15

    (31) termino -> LPAR expression . RPAR

    RPAR            shift and go to state 23


state 16

    (33) termino -> MINUS varcte .

    $end            reduce using rule 33 (termino -> MINUS varcte .)
    RPAR            reduce using rule 33 (termino -> MINUS varcte .)
    PLUS            reduce using rule 33 (termino -> MINUS varcte .)
    MINUS           reduce using rule 33 (termino -> MINUS varcte .)
    MULTIPLY        reduce using rule 33 (termino -> MINUS varcte .)
    DIVIDE          reduce using rule 33 (termino -> MINUS varcte .)
    COMPARISON      reduce using rule 33 (termino -> MINUS varcte .)


state 17

    (32) termino -> PLUS varcte .

    $end            reduce using rule 32 (termino -> PLUS varcte .)
    RPAR            reduce using rule 32 (termino -> PLUS varcte .)
    PLUS            reduce using rule 32 (termino -> PLUS varcte .)
    MINUS           reduce using rule 32 (termino -> PLUS varcte .)
    MULTIPLY        reduce using rule 32 (termino -> PLUS varcte .)
    DIVIDE          reduce using rule 32 (termino -> PLUS varcte .)
    COMPARISON      reduce using rule 32 (termino -> PLUS varcte .)


state 18

    (29) exp -> termino COMPARISON . termino
    (31) termino -> . LPAR expression RPAR
    (32) termino -> . PLUS varcte
    (33) termino -> . MINUS varcte
    (34) termino -> . varcte
    (35) varcte -> . ID
    (36) varcte -> . NUMINT
    (37) varcte -> . NUMFLOAT

    LPAR            shift and go to state 5
    PLUS            shift and go to state 8
    MINUS           shift and go to state 7
    ID              shift and go to state 13
    NUMINT          shift and go to state 6
    NUMFLOAT        shift and go to state 11

    termino                        shift and go to state 24
    varcte                         shift and go to state 14

state 19

    (28) exp -> termino DIVIDE . termino
    (31) termino -> . LPAR expression RPAR
    (32) termino -> . PLUS varcte
    (33) termino -> . MINUS varcte
    (34) termino -> . varcte
    (35) varcte -> . ID
    (36) varcte -> . NUMINT
    (37) varcte -> . NUMFLOAT

    LPAR            shift and go to state 5
    PLUS            shift and go to state 8
    MINUS           shift and go to state 7
    ID              shift and go to state 13
    NUMINT          shift and go to state 6
    NUMFLOAT        shift and go to state 11

    termino                        shift and go to state 25
    varcte                         shift and go to state 14

state 20

    (25) exp -> termino PLUS . termino
    (31) termino -> . LPAR expression RPAR
    (32) termino -> . PLUS varcte
    (33) termino -> . MINUS varcte
    (34) termino -> . varcte
    (35) varcte -> . ID
    (36) varcte -> . NUMINT
    (37) varcte -> . NUMFLOAT

    LPAR            shift and go to state 5
    PLUS            shift and go to state 8
    MINUS           shift and go to state 7
    ID              shift and go to state 13
    NUMINT          shift and go to state 6
    NUMFLOAT        shift and go to state 11

    termino                        shift and go to state 26
    varcte                         shift and go to state 14

state 21

    (27) exp -> termino MULTIPLY . termino
    (31) termino -> . LPAR expression RPAR
    (32) termino -> . PLUS varcte
    (33) termino -> . MINUS varcte
    (34) termino -> . varcte
    (35) varcte -> . ID
    (36) varcte -> . NUMINT
    (37) varcte -> . NUMFLOAT

    LPAR            shift and go to state 5
    PLUS            shift and go to state 8
    MINUS           shift and go to state 7
    ID              shift and go to state 13
    NUMINT          shift and go to state 6
    NUMFLOAT        shift and go to state 11

    termino                        shift and go to state 27
    varcte                         shift and go to state 14

state 22

    (26) exp -> termino MINUS . termino
    (31) termino -> . LPAR expression RPAR
    (32) termino -> . PLUS varcte
    (33) termino -> . MINUS varcte
    (34) termino -> . varcte
    (35) varcte -> . ID
    (36) varcte -> . NUMINT
    (37) varcte -> . NUMFLOAT

    LPAR            shift and go to state 5
    PLUS            shift and go to state 8
    MINUS           shift and go to state 7
    ID              shift and go to state 13
    NUMINT          shift and go to state 6
    NUMFLOAT        shift and go to state 11

    termino                        shift and go to state 28
    varcte                         shift and go to state 14

state 23

    (31) termino -> LPAR expression RPAR .

    $end            reduce using rule 31 (termino -> LPAR expression RPAR .)
    RPAR            reduce using rule 31 (termino -> LPAR expression RPAR .)
    PLUS            reduce using rule 31 (termino -> LPAR expression RPAR .)
    MINUS           reduce using rule 31 (termino -> LPAR expression RPAR .)
    MULTIPLY        reduce using rule 31 (termino -> LPAR expression RPAR .)
    DIVIDE          reduce using rule 31 (termino -> LPAR expression RPAR .)
    COMPARISON      reduce using rule 31 (termino -> LPAR expression RPAR .)


state 24

    (29) exp -> termino COMPARISON termino .

    $end            reduce using rule 29 (exp -> termino COMPARISON termino .)
    RPAR            reduce using rule 29 (exp -> termino COMPARISON termino .)


state 25

    (28) exp -> termino DIVIDE termino .

    $end            reduce using rule 28 (exp -> termino DIVIDE termino .)
    RPAR            reduce using rule 28 (exp -> termino DIVIDE termino .)


state 26

    (25) exp -> termino PLUS termino .

    $end            reduce using rule 25 (exp -> termino PLUS termino .)
    RPAR            reduce using rule 25 (exp -> termino PLUS termino .)


state 27

    (27) exp -> termino MULTIPLY termino .

    $end            reduce using rule 27 (exp -> termino MULTIPLY termino .)
    RPAR            reduce using rule 27 (exp -> termino MULTIPLY termino .)


state 28

    (26) exp -> termino MINUS termino .

    $end            reduce using rule 26 (exp -> termino MINUS termino .)
    RPAR            reduce using rule 26 (exp -> termino MINUS termino .)

