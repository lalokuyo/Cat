Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Unused terminals:

    TRUE
    STRING
    POOP
    SEMICOLON
    COLON
    BALL
    CANDY
    FALSE

Grammar

Rule 0     S' -> class
Rule 1     class -> vars_global init_vars func_list
Rule 2     class -> func class
Rule 3     vars_global -> varsGlobal vars_global
Rule 4     vars_global -> empty
Rule 5     init_vars -> asign init_vars
Rule 6     init_vars -> empty
Rule 7     func_list -> func func_list
Rule 8     func_list -> empty
Rule 9     func -> FUNC idCheck LPAR funcx RPAR block func_end
Rule 10    func_end -> <empty>
Rule 11    idCheck -> ID
Rule 12    funcx -> vars paramCheck
Rule 13    funcx -> vars paramCheck COMA funcx
Rule 14    funcx -> empty
Rule 15    paramCheck -> <empty>
Rule 16    block -> LCBRACKET blockx RCBRACKET
Rule 17    blockx -> vars
Rule 18    blockx -> vars blockx
Rule 19    blockx -> statement
Rule 20    blockx -> statement blockx
Rule 21    statement -> asign
Rule 22    statement -> condition
Rule 23    statement -> cycle
Rule 24    statement -> print
Rule 25    statement -> list
Rule 26    statement -> call
Rule 27    statement -> move
Rule 28    statement -> eat
Rule 29    statement -> clean
Rule 30    statement -> play
Rule 31    statement -> add
Rule 32    statement -> remove
Rule 33    statement -> turnleft
Rule 34    statement -> turnright
Rule 35    statement -> return
Rule 36    return -> RETURN LPAR par_call expression RPAR par_call2
Rule 37    varsGlobal -> type ID
Rule 38    vars -> type ID
Rule 39    type -> INT
Rule 40    type -> FLOAT
Rule 41    type -> BOOLEAN
Rule 42    asign -> ID id_val EQUAL equal_val expression
Rule 43    asign -> ID id_val EQUAL equal_val call
Rule 44    id_val -> <empty>
Rule 45    equal_val -> <empty>
Rule 46    expression -> exp
Rule 47    expression -> exp COMPARISON op_val expression
Rule 48    exp -> termino
Rule 49    exp -> termino PLUS op_val exp
Rule 50    exp -> termino MINUS op_val exp
Rule 51    termino -> factor
Rule 52    termino -> factor MULTIPLY op_val termino
Rule 53    termino -> factor DIVIDE op_val termino
Rule 54    termino_val -> <empty>
Rule 55    op_val -> <empty>
Rule 56    factor -> LPAR expression RPAR
Rule 57    factor -> MINUS varcte
Rule 58    factor -> varcte termino_val
Rule 59    varcte -> ID
Rule 60    varcte -> NUMINT
Rule 61    varcte -> NUMFLOAT
Rule 62    varcte -> BOOLEANTYPE
Rule 63    print -> PRINT LPAR par_call printx expCheck RPAR
Rule 64    printx -> expression
Rule 65    printx -> ID id_val
Rule 66    printx -> call
Rule 67    printx -> expression PLUS op_val printx
Rule 68    printx -> ID id_val PLUS op_val printx
Rule 69    printx -> call PLUS op_val printx
Rule 70    expCheck -> expression
Rule 71    expCheck -> empty
Rule 72    cycle -> WHILE cycle_1 LPAR exp RPAR cycle_2 block cycle_3
Rule 73    cycle_1 -> <empty>
Rule 74    cycle_2 -> <empty>
Rule 75    cycle_3 -> <empty>
Rule 76    condition -> IF LPAR exp RPAR cond_1 block else cond_2
Rule 77    else -> ELSE cond_else block
Rule 78    else -> empty
Rule 79    cond_1 -> <empty>
Rule 80    cond_2 -> <empty>
Rule 81    cond_else -> <empty>
Rule 82    list -> LIST idCheck_List EQUAL LBRACKET listx RBRACKET
Rule 83    listx -> ID id_param
Rule 84    listx -> ID id_param COMA listx
Rule 85    listx -> NUMINT id_param
Rule 86    listx -> NUMINT id_param COMA listx
Rule 87    listx -> NUMFLOAT id_param
Rule 88    listx -> NUMFLOAT id_param COMA listx
Rule 89    idCheck_List -> ID
Rule 90    id_param -> <empty>
Rule 91    id_param2 -> <empty>
Rule 92    listx_add -> ID id_param2
Rule 93    listx_add -> NUMINT id_param2
Rule 94    listx_add -> NUMFLOAT id_param2
Rule 95    add -> ID idCheck_Add POINT ADD LPAR listx_add RPAR
Rule 96    idCheck_Add -> <empty>
Rule 97    remove -> ID idCheck_Add POINT REMOVE LPAR RPAR
Rule 98    call -> ID id_call LPAR par_call RPAR par_call2
Rule 99    call -> ID id_call LPAR par_call params RPAR par_call2
Rule 100   id_call -> <empty>
Rule 101   par_call -> <empty>
Rule 102   par_call2 -> <empty>
Rule 103   params -> expression COMA params
Rule 104   params -> ID COMA params
Rule 105   params -> expression
Rule 106   params -> ID
Rule 107   move -> MOVE LPAR ID RPAR
Rule 108   eat -> EAT LPAR ID RPAR
Rule 109   clean -> CLEAN LPAR ID RPAR
Rule 110   play -> PLAY LPAR ID RPAR
Rule 111   turnleft -> TURNLEFT LPAR RPAR
Rule 112   turnright -> TURNRIGHT LPAR RPAR
Rule 113   empty -> <empty>

Terminals, with rules where they appear

ADD                  : 95
BALL                 : 
BOOLEAN              : 41
BOOLEANTYPE          : 62
CANDY                : 
CLEAN                : 109
COLON                : 
COMA                 : 13 84 86 88 103 104
COMPARISON           : 47
DIVIDE               : 53
EAT                  : 108
ELSE                 : 77
EQUAL                : 42 43 82
FALSE                : 
FLOAT                : 40
FUNC                 : 9
ID                   : 11 37 38 42 43 59 65 68 83 84 89 92 95 97 98 99 104 106 107 108 109 110
IF                   : 76
INT                  : 39
LBRACKET             : 82
LCBRACKET            : 16
LIST                 : 82
LPAR                 : 9 36 56 63 72 76 95 97 98 99 107 108 109 110 111 112
MINUS                : 50 57
MOVE                 : 107
MULTIPLY             : 52
NUMFLOAT             : 61 87 88 94
NUMINT               : 60 85 86 93
PLAY                 : 110
PLUS                 : 49 67 68 69
POINT                : 95 97
POOP                 : 
PRINT                : 63
RBRACKET             : 82
RCBRACKET            : 16
REMOVE               : 97
RETURN               : 36
RPAR                 : 9 36 56 63 72 76 95 97 98 99 107 108 109 110 111 112
SEMICOLON            : 
STRING               : 
TRUE                 : 
TURNLEFT             : 111
TURNRIGHT            : 112
WHILE                : 72
error                : 

Nonterminals, with rules where they appear

add                  : 31
asign                : 5 21
block                : 9 72 76 77
blockx               : 16 18 20
call                 : 26 43 66 69
class                : 2 0
clean                : 29
cond_1               : 76
cond_2               : 76
cond_else            : 77
condition            : 22
cycle                : 23
cycle_1              : 72
cycle_2              : 72
cycle_3              : 72
eat                  : 28
else                 : 76
empty                : 4 6 8 14 71 78
equal_val            : 42 43
exp                  : 46 47 49 50 72 76
expCheck             : 63
expression           : 36 42 47 56 64 67 70 103 105
factor               : 51 52 53
func                 : 2 7
func_end             : 9
func_list            : 1 7
funcx                : 9 13
idCheck              : 9
idCheck_Add          : 95 97
idCheck_List         : 82
id_call              : 98 99
id_param             : 83 84 85 86 87 88
id_param2            : 92 93 94
id_val               : 42 43 65 68
init_vars            : 1 5
list                 : 25
listx                : 82 84 86 88
listx_add            : 95
move                 : 27
op_val               : 47 49 50 52 53 67 68 69
par_call             : 36 63 98 99
par_call2            : 36 98 99
paramCheck           : 12 13
params               : 99 103 104
play                 : 30
print                : 24
printx               : 63 67 68 69
remove               : 32
return               : 35
statement            : 19 20
termino              : 48 49 50 52 53
termino_val          : 58
turnleft             : 33
turnright            : 34
type                 : 37 38
varcte               : 57 58
vars                 : 12 13 17 18
varsGlobal           : 3
vars_global          : 1 3

Parsing method: LALR

state 0

    (0) S' -> . class
    (1) class -> . vars_global init_vars func_list
    (2) class -> . func class
    (3) vars_global -> . varsGlobal vars_global
    (4) vars_global -> . empty
    (9) func -> . FUNC idCheck LPAR funcx RPAR block func_end
    (37) varsGlobal -> . type ID
    (113) empty -> .
    (39) type -> . INT
    (40) type -> . FLOAT
    (41) type -> . BOOLEAN

  ! shift/reduce conflict for FUNC resolved as shift
    FUNC            shift and go to state 3
    ID              reduce using rule 113 (empty -> .)
    $end            reduce using rule 113 (empty -> .)
    INT             shift and go to state 4
    FLOAT           shift and go to state 2
    BOOLEAN         shift and go to state 5

  ! FUNC            [ reduce using rule 113 (empty -> .) ]

    varsGlobal                     shift and go to state 1
    func                           shift and go to state 6
    vars_global                    shift and go to state 7
    type                           shift and go to state 8
    class                          shift and go to state 9
    empty                          shift and go to state 10

state 1

    (3) vars_global -> varsGlobal . vars_global
    (3) vars_global -> . varsGlobal vars_global
    (4) vars_global -> . empty
    (37) varsGlobal -> . type ID
    (113) empty -> .
    (39) type -> . INT
    (40) type -> . FLOAT
    (41) type -> . BOOLEAN

    ID              reduce using rule 113 (empty -> .)
    FUNC            reduce using rule 113 (empty -> .)
    $end            reduce using rule 113 (empty -> .)
    INT             shift and go to state 4
    FLOAT           shift and go to state 2
    BOOLEAN         shift and go to state 5

    varsGlobal                     shift and go to state 1
    vars_global                    shift and go to state 11
    type                           shift and go to state 8
    empty                          shift and go to state 10

state 2

    (40) type -> FLOAT .

    ID              reduce using rule 40 (type -> FLOAT .)


state 3

    (9) func -> FUNC . idCheck LPAR funcx RPAR block func_end
    (11) idCheck -> . ID

    ID              shift and go to state 13

    idCheck                        shift and go to state 12

state 4

    (39) type -> INT .

    ID              reduce using rule 39 (type -> INT .)


state 5

    (41) type -> BOOLEAN .

    ID              reduce using rule 41 (type -> BOOLEAN .)


state 6

    (2) class -> func . class
    (1) class -> . vars_global init_vars func_list
    (2) class -> . func class
    (3) vars_global -> . varsGlobal vars_global
    (4) vars_global -> . empty
    (9) func -> . FUNC idCheck LPAR funcx RPAR block func_end
    (37) varsGlobal -> . type ID
    (113) empty -> .
    (39) type -> . INT
    (40) type -> . FLOAT
    (41) type -> . BOOLEAN

  ! shift/reduce conflict for FUNC resolved as shift
    FUNC            shift and go to state 3
    ID              reduce using rule 113 (empty -> .)
    $end            reduce using rule 113 (empty -> .)
    INT             shift and go to state 4
    FLOAT           shift and go to state 2
    BOOLEAN         shift and go to state 5

  ! FUNC            [ reduce using rule 113 (empty -> .) ]

    varsGlobal                     shift and go to state 1
    func                           shift and go to state 6
    vars_global                    shift and go to state 7
    type                           shift and go to state 8
    class                          shift and go to state 14
    empty                          shift and go to state 10

state 7

    (1) class -> vars_global . init_vars func_list
    (5) init_vars -> . asign init_vars
    (6) init_vars -> . empty
    (42) asign -> . ID id_val EQUAL equal_val expression
    (43) asign -> . ID id_val EQUAL equal_val call
    (113) empty -> .

    ID              shift and go to state 17
    FUNC            reduce using rule 113 (empty -> .)
    $end            reduce using rule 113 (empty -> .)

    init_vars                      shift and go to state 15
    asign                          shift and go to state 16
    empty                          shift and go to state 18

state 8

    (37) varsGlobal -> type . ID

    ID              shift and go to state 19


state 9

    (0) S' -> class .



state 10

    (4) vars_global -> empty .

    ID              reduce using rule 4 (vars_global -> empty .)
    FUNC            reduce using rule 4 (vars_global -> empty .)
    $end            reduce using rule 4 (vars_global -> empty .)


state 11

    (3) vars_global -> varsGlobal vars_global .

    ID              reduce using rule 3 (vars_global -> varsGlobal vars_global .)
    FUNC            reduce using rule 3 (vars_global -> varsGlobal vars_global .)
    $end            reduce using rule 3 (vars_global -> varsGlobal vars_global .)


state 12

    (9) func -> FUNC idCheck . LPAR funcx RPAR block func_end

    LPAR            shift and go to state 20


state 13

    (11) idCheck -> ID .

    LPAR            reduce using rule 11 (idCheck -> ID .)


state 14

    (2) class -> func class .

    $end            reduce using rule 2 (class -> func class .)


state 15

    (1) class -> vars_global init_vars . func_list
    (7) func_list -> . func func_list
    (8) func_list -> . empty
    (9) func -> . FUNC idCheck LPAR funcx RPAR block func_end
    (113) empty -> .

    FUNC            shift and go to state 3
    $end            reduce using rule 113 (empty -> .)

    func                           shift and go to state 21
    func_list                      shift and go to state 22
    empty                          shift and go to state 23

state 16

    (5) init_vars -> asign . init_vars
    (5) init_vars -> . asign init_vars
    (6) init_vars -> . empty
    (42) asign -> . ID id_val EQUAL equal_val expression
    (43) asign -> . ID id_val EQUAL equal_val call
    (113) empty -> .

    ID              shift and go to state 17
    FUNC            reduce using rule 113 (empty -> .)
    $end            reduce using rule 113 (empty -> .)

    init_vars                      shift and go to state 24
    asign                          shift and go to state 16
    empty                          shift and go to state 18

state 17

    (42) asign -> ID . id_val EQUAL equal_val expression
    (43) asign -> ID . id_val EQUAL equal_val call
    (44) id_val -> .

    EQUAL           reduce using rule 44 (id_val -> .)

    id_val                         shift and go to state 25

state 18

    (6) init_vars -> empty .

    FUNC            reduce using rule 6 (init_vars -> empty .)
    $end            reduce using rule 6 (init_vars -> empty .)


state 19

    (37) varsGlobal -> type ID .

    INT             reduce using rule 37 (varsGlobal -> type ID .)
    FLOAT           reduce using rule 37 (varsGlobal -> type ID .)
    BOOLEAN         reduce using rule 37 (varsGlobal -> type ID .)
    ID              reduce using rule 37 (varsGlobal -> type ID .)
    FUNC            reduce using rule 37 (varsGlobal -> type ID .)
    $end            reduce using rule 37 (varsGlobal -> type ID .)


state 20

    (9) func -> FUNC idCheck LPAR . funcx RPAR block func_end
    (12) funcx -> . vars paramCheck
    (13) funcx -> . vars paramCheck COMA funcx
    (14) funcx -> . empty
    (38) vars -> . type ID
    (113) empty -> .
    (39) type -> . INT
    (40) type -> . FLOAT
    (41) type -> . BOOLEAN

    RPAR            reduce using rule 113 (empty -> .)
    INT             shift and go to state 4
    FLOAT           shift and go to state 2
    BOOLEAN         shift and go to state 5

    funcx                          shift and go to state 27
    vars                           shift and go to state 26
    empty                          shift and go to state 28
    type                           shift and go to state 29

state 21

    (7) func_list -> func . func_list
    (7) func_list -> . func func_list
    (8) func_list -> . empty
    (9) func -> . FUNC idCheck LPAR funcx RPAR block func_end
    (113) empty -> .

    FUNC            shift and go to state 3
    $end            reduce using rule 113 (empty -> .)

    empty                          shift and go to state 23
    func                           shift and go to state 21
    func_list                      shift and go to state 30

state 22

    (1) class -> vars_global init_vars func_list .

    $end            reduce using rule 1 (class -> vars_global init_vars func_list .)


state 23

    (8) func_list -> empty .

    $end            reduce using rule 8 (func_list -> empty .)


state 24

    (5) init_vars -> asign init_vars .

    FUNC            reduce using rule 5 (init_vars -> asign init_vars .)
    $end            reduce using rule 5 (init_vars -> asign init_vars .)


state 25

    (42) asign -> ID id_val . EQUAL equal_val expression
    (43) asign -> ID id_val . EQUAL equal_val call

    EQUAL           shift and go to state 31


state 26

    (12) funcx -> vars . paramCheck
    (13) funcx -> vars . paramCheck COMA funcx
    (15) paramCheck -> .

    COMA            reduce using rule 15 (paramCheck -> .)
    RPAR            reduce using rule 15 (paramCheck -> .)

    paramCheck                     shift and go to state 32

state 27

    (9) func -> FUNC idCheck LPAR funcx . RPAR block func_end

    RPAR            shift and go to state 33


state 28

    (14) funcx -> empty .

    RPAR            reduce using rule 14 (funcx -> empty .)


state 29

    (38) vars -> type . ID

    ID              shift and go to state 34


state 30

    (7) func_list -> func func_list .

    $end            reduce using rule 7 (func_list -> func func_list .)


state 31

    (42) asign -> ID id_val EQUAL . equal_val expression
    (43) asign -> ID id_val EQUAL . equal_val call
    (45) equal_val -> .

    ID              reduce using rule 45 (equal_val -> .)
    LPAR            reduce using rule 45 (equal_val -> .)
    MINUS           reduce using rule 45 (equal_val -> .)
    NUMINT          reduce using rule 45 (equal_val -> .)
    NUMFLOAT        reduce using rule 45 (equal_val -> .)
    BOOLEANTYPE     reduce using rule 45 (equal_val -> .)

    equal_val                      shift and go to state 35

state 32

    (12) funcx -> vars paramCheck .
    (13) funcx -> vars paramCheck . COMA funcx

    RPAR            reduce using rule 12 (funcx -> vars paramCheck .)
    COMA            shift and go to state 36


state 33

    (9) func -> FUNC idCheck LPAR funcx RPAR . block func_end
    (16) block -> . LCBRACKET blockx RCBRACKET

    LCBRACKET       shift and go to state 37

    block                          shift and go to state 38

state 34

    (38) vars -> type ID .

    COMA            reduce using rule 38 (vars -> type ID .)
    RPAR            reduce using rule 38 (vars -> type ID .)
    INT             reduce using rule 38 (vars -> type ID .)
    FLOAT           reduce using rule 38 (vars -> type ID .)
    BOOLEAN         reduce using rule 38 (vars -> type ID .)
    ID              reduce using rule 38 (vars -> type ID .)
    IF              reduce using rule 38 (vars -> type ID .)
    WHILE           reduce using rule 38 (vars -> type ID .)
    PRINT           reduce using rule 38 (vars -> type ID .)
    LIST            reduce using rule 38 (vars -> type ID .)
    MOVE            reduce using rule 38 (vars -> type ID .)
    EAT             reduce using rule 38 (vars -> type ID .)
    CLEAN           reduce using rule 38 (vars -> type ID .)
    PLAY            reduce using rule 38 (vars -> type ID .)
    TURNLEFT        reduce using rule 38 (vars -> type ID .)
    TURNRIGHT       reduce using rule 38 (vars -> type ID .)
    RETURN          reduce using rule 38 (vars -> type ID .)
    RCBRACKET       reduce using rule 38 (vars -> type ID .)


state 35

    (42) asign -> ID id_val EQUAL equal_val . expression
    (43) asign -> ID id_val EQUAL equal_val . call
    (46) expression -> . exp
    (47) expression -> . exp COMPARISON op_val expression
    (98) call -> . ID id_call LPAR par_call RPAR par_call2
    (99) call -> . ID id_call LPAR par_call params RPAR par_call2
    (48) exp -> . termino
    (49) exp -> . termino PLUS op_val exp
    (50) exp -> . termino MINUS op_val exp
    (51) termino -> . factor
    (52) termino -> . factor MULTIPLY op_val termino
    (53) termino -> . factor DIVIDE op_val termino
    (56) factor -> . LPAR expression RPAR
    (57) factor -> . MINUS varcte
    (58) factor -> . varcte termino_val
    (59) varcte -> . ID
    (60) varcte -> . NUMINT
    (61) varcte -> . NUMFLOAT
    (62) varcte -> . BOOLEANTYPE

    ID              shift and go to state 46
    LPAR            shift and go to state 39
    MINUS           shift and go to state 42
    NUMINT          shift and go to state 47
    NUMFLOAT        shift and go to state 41
    BOOLEANTYPE     shift and go to state 49

    factor                         shift and go to state 45
    varcte                         shift and go to state 43
    call                           shift and go to state 44
    termino                        shift and go to state 40
    exp                            shift and go to state 48
    expression                     shift and go to state 50

state 36

    (13) funcx -> vars paramCheck COMA . funcx
    (12) funcx -> . vars paramCheck
    (13) funcx -> . vars paramCheck COMA funcx
    (14) funcx -> . empty
    (38) vars -> . type ID
    (113) empty -> .
    (39) type -> . INT
    (40) type -> . FLOAT
    (41) type -> . BOOLEAN

    RPAR            reduce using rule 113 (empty -> .)
    INT             shift and go to state 4
    FLOAT           shift and go to state 2
    BOOLEAN         shift and go to state 5

    funcx                          shift and go to state 51
    type                           shift and go to state 29
    empty                          shift and go to state 28
    vars                           shift and go to state 26

state 37

    (16) block -> LCBRACKET . blockx RCBRACKET
    (17) blockx -> . vars
    (18) blockx -> . vars blockx
    (19) blockx -> . statement
    (20) blockx -> . statement blockx
    (38) vars -> . type ID
    (21) statement -> . asign
    (22) statement -> . condition
    (23) statement -> . cycle
    (24) statement -> . print
    (25) statement -> . list
    (26) statement -> . call
    (27) statement -> . move
    (28) statement -> . eat
    (29) statement -> . clean
    (30) statement -> . play
    (31) statement -> . add
    (32) statement -> . remove
    (33) statement -> . turnleft
    (34) statement -> . turnright
    (35) statement -> . return
    (39) type -> . INT
    (40) type -> . FLOAT
    (41) type -> . BOOLEAN
    (42) asign -> . ID id_val EQUAL equal_val expression
    (43) asign -> . ID id_val EQUAL equal_val call
    (76) condition -> . IF LPAR exp RPAR cond_1 block else cond_2
    (72) cycle -> . WHILE cycle_1 LPAR exp RPAR cycle_2 block cycle_3
    (63) print -> . PRINT LPAR par_call printx expCheck RPAR
    (82) list -> . LIST idCheck_List EQUAL LBRACKET listx RBRACKET
    (98) call -> . ID id_call LPAR par_call RPAR par_call2
    (99) call -> . ID id_call LPAR par_call params RPAR par_call2
    (107) move -> . MOVE LPAR ID RPAR
    (108) eat -> . EAT LPAR ID RPAR
    (109) clean -> . CLEAN LPAR ID RPAR
    (110) play -> . PLAY LPAR ID RPAR
    (95) add -> . ID idCheck_Add POINT ADD LPAR listx_add RPAR
    (97) remove -> . ID idCheck_Add POINT REMOVE LPAR RPAR
    (111) turnleft -> . TURNLEFT LPAR RPAR
    (112) turnright -> . TURNRIGHT LPAR RPAR
    (36) return -> . RETURN LPAR par_call expression RPAR par_call2

    INT             shift and go to state 4
    FLOAT           shift and go to state 2
    BOOLEAN         shift and go to state 5
    ID              shift and go to state 58
    IF              shift and go to state 64
    WHILE           shift and go to state 55
    PRINT           shift and go to state 56
    LIST            shift and go to state 57
    MOVE            shift and go to state 68
    EAT             shift and go to state 65
    CLEAN           shift and go to state 73
    PLAY            shift and go to state 66
    TURNLEFT        shift and go to state 77
    TURNRIGHT       shift and go to state 72
    RETURN          shift and go to state 52

    vars                           shift and go to state 53
    move                           shift and go to state 54
    turnright                      shift and go to state 59
    add                            shift and go to state 60
    call                           shift and go to state 61
    statement                      shift and go to state 62
    print                          shift and go to state 63
    type                           shift and go to state 29
    play                           shift and go to state 67
    return                         shift and go to state 69
    turnleft                       shift and go to state 70
    blockx                         shift and go to state 71
    eat                            shift and go to state 74
    condition                      shift and go to state 75
    cycle                          shift and go to state 76
    list                           shift and go to state 78
    remove                         shift and go to state 79
    asign                          shift and go to state 80
    clean                          shift and go to state 81

state 38

    (9) func -> FUNC idCheck LPAR funcx RPAR block . func_end
    (10) func_end -> .

    FUNC            reduce using rule 10 (func_end -> .)
    INT             reduce using rule 10 (func_end -> .)
    FLOAT           reduce using rule 10 (func_end -> .)
    BOOLEAN         reduce using rule 10 (func_end -> .)
    ID              reduce using rule 10 (func_end -> .)
    $end            reduce using rule 10 (func_end -> .)

    func_end                       shift and go to state 82

state 39

    (56) factor -> LPAR . expression RPAR
    (46) expression -> . exp
    (47) expression -> . exp COMPARISON op_val expression
    (48) exp -> . termino
    (49) exp -> . termino PLUS op_val exp
    (50) exp -> . termino MINUS op_val exp
    (51) termino -> . factor
    (52) termino -> . factor MULTIPLY op_val termino
    (53) termino -> . factor DIVIDE op_val termino
    (56) factor -> . LPAR expression RPAR
    (57) factor -> . MINUS varcte
    (58) factor -> . varcte termino_val
    (59) varcte -> . ID
    (60) varcte -> . NUMINT
    (61) varcte -> . NUMFLOAT
    (62) varcte -> . BOOLEANTYPE

    LPAR            shift and go to state 39
    MINUS           shift and go to state 42
    ID              shift and go to state 83
    NUMINT          shift and go to state 47
    NUMFLOAT        shift and go to state 41
    BOOLEANTYPE     shift and go to state 49

    varcte                         shift and go to state 43
    termino                        shift and go to state 40
    exp                            shift and go to state 48
    factor                         shift and go to state 45
    expression                     shift and go to state 84

state 40

    (48) exp -> termino .
    (49) exp -> termino . PLUS op_val exp
    (50) exp -> termino . MINUS op_val exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    COMPARISON      reduce using rule 48 (exp -> termino .)
    ID              reduce using rule 48 (exp -> termino .)
    FUNC            reduce using rule 48 (exp -> termino .)
    $end            reduce using rule 48 (exp -> termino .)
    INT             reduce using rule 48 (exp -> termino .)
    FLOAT           reduce using rule 48 (exp -> termino .)
    BOOLEAN         reduce using rule 48 (exp -> termino .)
    IF              reduce using rule 48 (exp -> termino .)
    WHILE           reduce using rule 48 (exp -> termino .)
    PRINT           reduce using rule 48 (exp -> termino .)
    LIST            reduce using rule 48 (exp -> termino .)
    MOVE            reduce using rule 48 (exp -> termino .)
    EAT             reduce using rule 48 (exp -> termino .)
    CLEAN           reduce using rule 48 (exp -> termino .)
    PLAY            reduce using rule 48 (exp -> termino .)
    TURNLEFT        reduce using rule 48 (exp -> termino .)
    TURNRIGHT       reduce using rule 48 (exp -> termino .)
    RETURN          reduce using rule 48 (exp -> termino .)
    RCBRACKET       reduce using rule 48 (exp -> termino .)
    RPAR            reduce using rule 48 (exp -> termino .)
    LPAR            reduce using rule 48 (exp -> termino .)
    NUMINT          reduce using rule 48 (exp -> termino .)
    NUMFLOAT        reduce using rule 48 (exp -> termino .)
    BOOLEANTYPE     reduce using rule 48 (exp -> termino .)
    COMA            reduce using rule 48 (exp -> termino .)
    PLUS            shift and go to state 85
    MINUS           shift and go to state 86

  ! PLUS            [ reduce using rule 48 (exp -> termino .) ]
  ! MINUS           [ reduce using rule 48 (exp -> termino .) ]


state 41

    (61) varcte -> NUMFLOAT .

    MULTIPLY        reduce using rule 61 (varcte -> NUMFLOAT .)
    DIVIDE          reduce using rule 61 (varcte -> NUMFLOAT .)
    PLUS            reduce using rule 61 (varcte -> NUMFLOAT .)
    MINUS           reduce using rule 61 (varcte -> NUMFLOAT .)
    COMPARISON      reduce using rule 61 (varcte -> NUMFLOAT .)
    RPAR            reduce using rule 61 (varcte -> NUMFLOAT .)
    ID              reduce using rule 61 (varcte -> NUMFLOAT .)
    FUNC            reduce using rule 61 (varcte -> NUMFLOAT .)
    $end            reduce using rule 61 (varcte -> NUMFLOAT .)
    INT             reduce using rule 61 (varcte -> NUMFLOAT .)
    FLOAT           reduce using rule 61 (varcte -> NUMFLOAT .)
    BOOLEAN         reduce using rule 61 (varcte -> NUMFLOAT .)
    IF              reduce using rule 61 (varcte -> NUMFLOAT .)
    WHILE           reduce using rule 61 (varcte -> NUMFLOAT .)
    PRINT           reduce using rule 61 (varcte -> NUMFLOAT .)
    LIST            reduce using rule 61 (varcte -> NUMFLOAT .)
    MOVE            reduce using rule 61 (varcte -> NUMFLOAT .)
    EAT             reduce using rule 61 (varcte -> NUMFLOAT .)
    CLEAN           reduce using rule 61 (varcte -> NUMFLOAT .)
    PLAY            reduce using rule 61 (varcte -> NUMFLOAT .)
    TURNLEFT        reduce using rule 61 (varcte -> NUMFLOAT .)
    TURNRIGHT       reduce using rule 61 (varcte -> NUMFLOAT .)
    RETURN          reduce using rule 61 (varcte -> NUMFLOAT .)
    RCBRACKET       reduce using rule 61 (varcte -> NUMFLOAT .)
    LPAR            reduce using rule 61 (varcte -> NUMFLOAT .)
    NUMINT          reduce using rule 61 (varcte -> NUMFLOAT .)
    NUMFLOAT        reduce using rule 61 (varcte -> NUMFLOAT .)
    BOOLEANTYPE     reduce using rule 61 (varcte -> NUMFLOAT .)
    COMA            reduce using rule 61 (varcte -> NUMFLOAT .)


state 42

    (57) factor -> MINUS . varcte
    (59) varcte -> . ID
    (60) varcte -> . NUMINT
    (61) varcte -> . NUMFLOAT
    (62) varcte -> . BOOLEANTYPE

    ID              shift and go to state 83
    NUMINT          shift and go to state 47
    NUMFLOAT        shift and go to state 41
    BOOLEANTYPE     shift and go to state 49

    varcte                         shift and go to state 87

state 43

    (58) factor -> varcte . termino_val
    (54) termino_val -> .

    MULTIPLY        reduce using rule 54 (termino_val -> .)
    DIVIDE          reduce using rule 54 (termino_val -> .)
    PLUS            reduce using rule 54 (termino_val -> .)
    MINUS           reduce using rule 54 (termino_val -> .)
    COMPARISON      reduce using rule 54 (termino_val -> .)
    ID              reduce using rule 54 (termino_val -> .)
    FUNC            reduce using rule 54 (termino_val -> .)
    $end            reduce using rule 54 (termino_val -> .)
    INT             reduce using rule 54 (termino_val -> .)
    FLOAT           reduce using rule 54 (termino_val -> .)
    BOOLEAN         reduce using rule 54 (termino_val -> .)
    IF              reduce using rule 54 (termino_val -> .)
    WHILE           reduce using rule 54 (termino_val -> .)
    PRINT           reduce using rule 54 (termino_val -> .)
    LIST            reduce using rule 54 (termino_val -> .)
    MOVE            reduce using rule 54 (termino_val -> .)
    EAT             reduce using rule 54 (termino_val -> .)
    CLEAN           reduce using rule 54 (termino_val -> .)
    PLAY            reduce using rule 54 (termino_val -> .)
    TURNLEFT        reduce using rule 54 (termino_val -> .)
    TURNRIGHT       reduce using rule 54 (termino_val -> .)
    RETURN          reduce using rule 54 (termino_val -> .)
    RCBRACKET       reduce using rule 54 (termino_val -> .)
    RPAR            reduce using rule 54 (termino_val -> .)
    LPAR            reduce using rule 54 (termino_val -> .)
    NUMINT          reduce using rule 54 (termino_val -> .)
    NUMFLOAT        reduce using rule 54 (termino_val -> .)
    BOOLEANTYPE     reduce using rule 54 (termino_val -> .)
    COMA            reduce using rule 54 (termino_val -> .)

    termino_val                    shift and go to state 88

state 44

    (43) asign -> ID id_val EQUAL equal_val call .

    INT             reduce using rule 43 (asign -> ID id_val EQUAL equal_val call .)
    FLOAT           reduce using rule 43 (asign -> ID id_val EQUAL equal_val call .)
    BOOLEAN         reduce using rule 43 (asign -> ID id_val EQUAL equal_val call .)
    ID              reduce using rule 43 (asign -> ID id_val EQUAL equal_val call .)
    IF              reduce using rule 43 (asign -> ID id_val EQUAL equal_val call .)
    WHILE           reduce using rule 43 (asign -> ID id_val EQUAL equal_val call .)
    PRINT           reduce using rule 43 (asign -> ID id_val EQUAL equal_val call .)
    LIST            reduce using rule 43 (asign -> ID id_val EQUAL equal_val call .)
    MOVE            reduce using rule 43 (asign -> ID id_val EQUAL equal_val call .)
    EAT             reduce using rule 43 (asign -> ID id_val EQUAL equal_val call .)
    CLEAN           reduce using rule 43 (asign -> ID id_val EQUAL equal_val call .)
    PLAY            reduce using rule 43 (asign -> ID id_val EQUAL equal_val call .)
    TURNLEFT        reduce using rule 43 (asign -> ID id_val EQUAL equal_val call .)
    TURNRIGHT       reduce using rule 43 (asign -> ID id_val EQUAL equal_val call .)
    RETURN          reduce using rule 43 (asign -> ID id_val EQUAL equal_val call .)
    RCBRACKET       reduce using rule 43 (asign -> ID id_val EQUAL equal_val call .)
    FUNC            reduce using rule 43 (asign -> ID id_val EQUAL equal_val call .)
    $end            reduce using rule 43 (asign -> ID id_val EQUAL equal_val call .)


state 45

    (51) termino -> factor .
    (52) termino -> factor . MULTIPLY op_val termino
    (53) termino -> factor . DIVIDE op_val termino

    PLUS            reduce using rule 51 (termino -> factor .)
    MINUS           reduce using rule 51 (termino -> factor .)
    RPAR            reduce using rule 51 (termino -> factor .)
    COMPARISON      reduce using rule 51 (termino -> factor .)
    LPAR            reduce using rule 51 (termino -> factor .)
    ID              reduce using rule 51 (termino -> factor .)
    NUMINT          reduce using rule 51 (termino -> factor .)
    NUMFLOAT        reduce using rule 51 (termino -> factor .)
    BOOLEANTYPE     reduce using rule 51 (termino -> factor .)
    FUNC            reduce using rule 51 (termino -> factor .)
    $end            reduce using rule 51 (termino -> factor .)
    INT             reduce using rule 51 (termino -> factor .)
    FLOAT           reduce using rule 51 (termino -> factor .)
    BOOLEAN         reduce using rule 51 (termino -> factor .)
    IF              reduce using rule 51 (termino -> factor .)
    WHILE           reduce using rule 51 (termino -> factor .)
    PRINT           reduce using rule 51 (termino -> factor .)
    LIST            reduce using rule 51 (termino -> factor .)
    MOVE            reduce using rule 51 (termino -> factor .)
    EAT             reduce using rule 51 (termino -> factor .)
    CLEAN           reduce using rule 51 (termino -> factor .)
    PLAY            reduce using rule 51 (termino -> factor .)
    TURNLEFT        reduce using rule 51 (termino -> factor .)
    TURNRIGHT       reduce using rule 51 (termino -> factor .)
    RETURN          reduce using rule 51 (termino -> factor .)
    RCBRACKET       reduce using rule 51 (termino -> factor .)
    COMA            reduce using rule 51 (termino -> factor .)
    MULTIPLY        shift and go to state 89
    DIVIDE          shift and go to state 90


state 46

    (98) call -> ID . id_call LPAR par_call RPAR par_call2
    (99) call -> ID . id_call LPAR par_call params RPAR par_call2
    (59) varcte -> ID .
    (100) id_call -> .

    MULTIPLY        reduce using rule 59 (varcte -> ID .)
    DIVIDE          reduce using rule 59 (varcte -> ID .)
    PLUS            reduce using rule 59 (varcte -> ID .)
    MINUS           reduce using rule 59 (varcte -> ID .)
    COMPARISON      reduce using rule 59 (varcte -> ID .)
    ID              reduce using rule 59 (varcte -> ID .)
    FUNC            reduce using rule 59 (varcte -> ID .)
    $end            reduce using rule 59 (varcte -> ID .)
    INT             reduce using rule 59 (varcte -> ID .)
    FLOAT           reduce using rule 59 (varcte -> ID .)
    BOOLEAN         reduce using rule 59 (varcte -> ID .)
    IF              reduce using rule 59 (varcte -> ID .)
    WHILE           reduce using rule 59 (varcte -> ID .)
    PRINT           reduce using rule 59 (varcte -> ID .)
    LIST            reduce using rule 59 (varcte -> ID .)
    MOVE            reduce using rule 59 (varcte -> ID .)
    EAT             reduce using rule 59 (varcte -> ID .)
    CLEAN           reduce using rule 59 (varcte -> ID .)
    PLAY            reduce using rule 59 (varcte -> ID .)
    TURNLEFT        reduce using rule 59 (varcte -> ID .)
    TURNRIGHT       reduce using rule 59 (varcte -> ID .)
    RETURN          reduce using rule 59 (varcte -> ID .)
    RCBRACKET       reduce using rule 59 (varcte -> ID .)
    LPAR            reduce using rule 100 (id_call -> .)

    id_call                        shift and go to state 91

state 47

    (60) varcte -> NUMINT .

    MULTIPLY        reduce using rule 60 (varcte -> NUMINT .)
    DIVIDE          reduce using rule 60 (varcte -> NUMINT .)
    PLUS            reduce using rule 60 (varcte -> NUMINT .)
    MINUS           reduce using rule 60 (varcte -> NUMINT .)
    COMPARISON      reduce using rule 60 (varcte -> NUMINT .)
    RPAR            reduce using rule 60 (varcte -> NUMINT .)
    ID              reduce using rule 60 (varcte -> NUMINT .)
    FUNC            reduce using rule 60 (varcte -> NUMINT .)
    $end            reduce using rule 60 (varcte -> NUMINT .)
    INT             reduce using rule 60 (varcte -> NUMINT .)
    FLOAT           reduce using rule 60 (varcte -> NUMINT .)
    BOOLEAN         reduce using rule 60 (varcte -> NUMINT .)
    IF              reduce using rule 60 (varcte -> NUMINT .)
    WHILE           reduce using rule 60 (varcte -> NUMINT .)
    PRINT           reduce using rule 60 (varcte -> NUMINT .)
    LIST            reduce using rule 60 (varcte -> NUMINT .)
    MOVE            reduce using rule 60 (varcte -> NUMINT .)
    EAT             reduce using rule 60 (varcte -> NUMINT .)
    CLEAN           reduce using rule 60 (varcte -> NUMINT .)
    PLAY            reduce using rule 60 (varcte -> NUMINT .)
    TURNLEFT        reduce using rule 60 (varcte -> NUMINT .)
    TURNRIGHT       reduce using rule 60 (varcte -> NUMINT .)
    RETURN          reduce using rule 60 (varcte -> NUMINT .)
    RCBRACKET       reduce using rule 60 (varcte -> NUMINT .)
    LPAR            reduce using rule 60 (varcte -> NUMINT .)
    NUMINT          reduce using rule 60 (varcte -> NUMINT .)
    NUMFLOAT        reduce using rule 60 (varcte -> NUMINT .)
    BOOLEANTYPE     reduce using rule 60 (varcte -> NUMINT .)
    COMA            reduce using rule 60 (varcte -> NUMINT .)


state 48

    (46) expression -> exp .
    (47) expression -> exp . COMPARISON op_val expression

    COMA            reduce using rule 46 (expression -> exp .)
    RPAR            reduce using rule 46 (expression -> exp .)
    PLUS            reduce using rule 46 (expression -> exp .)
    LPAR            reduce using rule 46 (expression -> exp .)
    MINUS           reduce using rule 46 (expression -> exp .)
    ID              reduce using rule 46 (expression -> exp .)
    NUMINT          reduce using rule 46 (expression -> exp .)
    NUMFLOAT        reduce using rule 46 (expression -> exp .)
    BOOLEANTYPE     reduce using rule 46 (expression -> exp .)
    FUNC            reduce using rule 46 (expression -> exp .)
    $end            reduce using rule 46 (expression -> exp .)
    INT             reduce using rule 46 (expression -> exp .)
    FLOAT           reduce using rule 46 (expression -> exp .)
    BOOLEAN         reduce using rule 46 (expression -> exp .)
    IF              reduce using rule 46 (expression -> exp .)
    WHILE           reduce using rule 46 (expression -> exp .)
    PRINT           reduce using rule 46 (expression -> exp .)
    LIST            reduce using rule 46 (expression -> exp .)
    MOVE            reduce using rule 46 (expression -> exp .)
    EAT             reduce using rule 46 (expression -> exp .)
    CLEAN           reduce using rule 46 (expression -> exp .)
    PLAY            reduce using rule 46 (expression -> exp .)
    TURNLEFT        reduce using rule 46 (expression -> exp .)
    TURNRIGHT       reduce using rule 46 (expression -> exp .)
    RETURN          reduce using rule 46 (expression -> exp .)
    RCBRACKET       reduce using rule 46 (expression -> exp .)
    COMPARISON      shift and go to state 92


state 49

    (62) varcte -> BOOLEANTYPE .

    MULTIPLY        reduce using rule 62 (varcte -> BOOLEANTYPE .)
    DIVIDE          reduce using rule 62 (varcte -> BOOLEANTYPE .)
    PLUS            reduce using rule 62 (varcte -> BOOLEANTYPE .)
    MINUS           reduce using rule 62 (varcte -> BOOLEANTYPE .)
    COMPARISON      reduce using rule 62 (varcte -> BOOLEANTYPE .)
    RPAR            reduce using rule 62 (varcte -> BOOLEANTYPE .)
    ID              reduce using rule 62 (varcte -> BOOLEANTYPE .)
    FUNC            reduce using rule 62 (varcte -> BOOLEANTYPE .)
    $end            reduce using rule 62 (varcte -> BOOLEANTYPE .)
    INT             reduce using rule 62 (varcte -> BOOLEANTYPE .)
    FLOAT           reduce using rule 62 (varcte -> BOOLEANTYPE .)
    BOOLEAN         reduce using rule 62 (varcte -> BOOLEANTYPE .)
    IF              reduce using rule 62 (varcte -> BOOLEANTYPE .)
    WHILE           reduce using rule 62 (varcte -> BOOLEANTYPE .)
    PRINT           reduce using rule 62 (varcte -> BOOLEANTYPE .)
    LIST            reduce using rule 62 (varcte -> BOOLEANTYPE .)
    MOVE            reduce using rule 62 (varcte -> BOOLEANTYPE .)
    EAT             reduce using rule 62 (varcte -> BOOLEANTYPE .)
    CLEAN           reduce using rule 62 (varcte -> BOOLEANTYPE .)
    PLAY            reduce using rule 62 (varcte -> BOOLEANTYPE .)
    TURNLEFT        reduce using rule 62 (varcte -> BOOLEANTYPE .)
    TURNRIGHT       reduce using rule 62 (varcte -> BOOLEANTYPE .)
    RETURN          reduce using rule 62 (varcte -> BOOLEANTYPE .)
    RCBRACKET       reduce using rule 62 (varcte -> BOOLEANTYPE .)
    LPAR            reduce using rule 62 (varcte -> BOOLEANTYPE .)
    NUMINT          reduce using rule 62 (varcte -> BOOLEANTYPE .)
    NUMFLOAT        reduce using rule 62 (varcte -> BOOLEANTYPE .)
    BOOLEANTYPE     reduce using rule 62 (varcte -> BOOLEANTYPE .)
    COMA            reduce using rule 62 (varcte -> BOOLEANTYPE .)


state 50

    (42) asign -> ID id_val EQUAL equal_val expression .

    INT             reduce using rule 42 (asign -> ID id_val EQUAL equal_val expression .)
    FLOAT           reduce using rule 42 (asign -> ID id_val EQUAL equal_val expression .)
    BOOLEAN         reduce using rule 42 (asign -> ID id_val EQUAL equal_val expression .)
    ID              reduce using rule 42 (asign -> ID id_val EQUAL equal_val expression .)
    IF              reduce using rule 42 (asign -> ID id_val EQUAL equal_val expression .)
    WHILE           reduce using rule 42 (asign -> ID id_val EQUAL equal_val expression .)
    PRINT           reduce using rule 42 (asign -> ID id_val EQUAL equal_val expression .)
    LIST            reduce using rule 42 (asign -> ID id_val EQUAL equal_val expression .)
    MOVE            reduce using rule 42 (asign -> ID id_val EQUAL equal_val expression .)
    EAT             reduce using rule 42 (asign -> ID id_val EQUAL equal_val expression .)
    CLEAN           reduce using rule 42 (asign -> ID id_val EQUAL equal_val expression .)
    PLAY            reduce using rule 42 (asign -> ID id_val EQUAL equal_val expression .)
    TURNLEFT        reduce using rule 42 (asign -> ID id_val EQUAL equal_val expression .)
    TURNRIGHT       reduce using rule 42 (asign -> ID id_val EQUAL equal_val expression .)
    RETURN          reduce using rule 42 (asign -> ID id_val EQUAL equal_val expression .)
    RCBRACKET       reduce using rule 42 (asign -> ID id_val EQUAL equal_val expression .)
    FUNC            reduce using rule 42 (asign -> ID id_val EQUAL equal_val expression .)
    $end            reduce using rule 42 (asign -> ID id_val EQUAL equal_val expression .)


state 51

    (13) funcx -> vars paramCheck COMA funcx .

    RPAR            reduce using rule 13 (funcx -> vars paramCheck COMA funcx .)


state 52

    (36) return -> RETURN . LPAR par_call expression RPAR par_call2

    LPAR            shift and go to state 93


state 53

    (17) blockx -> vars .
    (18) blockx -> vars . blockx
    (17) blockx -> . vars
    (18) blockx -> . vars blockx
    (19) blockx -> . statement
    (20) blockx -> . statement blockx
    (38) vars -> . type ID
    (21) statement -> . asign
    (22) statement -> . condition
    (23) statement -> . cycle
    (24) statement -> . print
    (25) statement -> . list
    (26) statement -> . call
    (27) statement -> . move
    (28) statement -> . eat
    (29) statement -> . clean
    (30) statement -> . play
    (31) statement -> . add
    (32) statement -> . remove
    (33) statement -> . turnleft
    (34) statement -> . turnright
    (35) statement -> . return
    (39) type -> . INT
    (40) type -> . FLOAT
    (41) type -> . BOOLEAN
    (42) asign -> . ID id_val EQUAL equal_val expression
    (43) asign -> . ID id_val EQUAL equal_val call
    (76) condition -> . IF LPAR exp RPAR cond_1 block else cond_2
    (72) cycle -> . WHILE cycle_1 LPAR exp RPAR cycle_2 block cycle_3
    (63) print -> . PRINT LPAR par_call printx expCheck RPAR
    (82) list -> . LIST idCheck_List EQUAL LBRACKET listx RBRACKET
    (98) call -> . ID id_call LPAR par_call RPAR par_call2
    (99) call -> . ID id_call LPAR par_call params RPAR par_call2
    (107) move -> . MOVE LPAR ID RPAR
    (108) eat -> . EAT LPAR ID RPAR
    (109) clean -> . CLEAN LPAR ID RPAR
    (110) play -> . PLAY LPAR ID RPAR
    (95) add -> . ID idCheck_Add POINT ADD LPAR listx_add RPAR
    (97) remove -> . ID idCheck_Add POINT REMOVE LPAR RPAR
    (111) turnleft -> . TURNLEFT LPAR RPAR
    (112) turnright -> . TURNRIGHT LPAR RPAR
    (36) return -> . RETURN LPAR par_call expression RPAR par_call2

    RCBRACKET       reduce using rule 17 (blockx -> vars .)
    INT             shift and go to state 4
    FLOAT           shift and go to state 2
    BOOLEAN         shift and go to state 5
    ID              shift and go to state 58
    IF              shift and go to state 64
    WHILE           shift and go to state 55
    PRINT           shift and go to state 56
    LIST            shift and go to state 57
    MOVE            shift and go to state 68
    EAT             shift and go to state 65
    CLEAN           shift and go to state 73
    PLAY            shift and go to state 66
    TURNLEFT        shift and go to state 77
    TURNRIGHT       shift and go to state 72
    RETURN          shift and go to state 52

    vars                           shift and go to state 53
    move                           shift and go to state 54
    turnright                      shift and go to state 59
    add                            shift and go to state 60
    call                           shift and go to state 61
    statement                      shift and go to state 62
    print                          shift and go to state 63
    type                           shift and go to state 29
    play                           shift and go to state 67
    return                         shift and go to state 69
    turnleft                       shift and go to state 70
    blockx                         shift and go to state 94
    eat                            shift and go to state 74
    condition                      shift and go to state 75
    cycle                          shift and go to state 76
    list                           shift and go to state 78
    remove                         shift and go to state 79
    asign                          shift and go to state 80
    clean                          shift and go to state 81

state 54

    (27) statement -> move .

    INT             reduce using rule 27 (statement -> move .)
    FLOAT           reduce using rule 27 (statement -> move .)
    BOOLEAN         reduce using rule 27 (statement -> move .)
    ID              reduce using rule 27 (statement -> move .)
    IF              reduce using rule 27 (statement -> move .)
    WHILE           reduce using rule 27 (statement -> move .)
    PRINT           reduce using rule 27 (statement -> move .)
    LIST            reduce using rule 27 (statement -> move .)
    MOVE            reduce using rule 27 (statement -> move .)
    EAT             reduce using rule 27 (statement -> move .)
    CLEAN           reduce using rule 27 (statement -> move .)
    PLAY            reduce using rule 27 (statement -> move .)
    TURNLEFT        reduce using rule 27 (statement -> move .)
    TURNRIGHT       reduce using rule 27 (statement -> move .)
    RETURN          reduce using rule 27 (statement -> move .)
    RCBRACKET       reduce using rule 27 (statement -> move .)


state 55

    (72) cycle -> WHILE . cycle_1 LPAR exp RPAR cycle_2 block cycle_3
    (73) cycle_1 -> .

    LPAR            reduce using rule 73 (cycle_1 -> .)

    cycle_1                        shift and go to state 95

state 56

    (63) print -> PRINT . LPAR par_call printx expCheck RPAR

    LPAR            shift and go to state 96


state 57

    (82) list -> LIST . idCheck_List EQUAL LBRACKET listx RBRACKET
    (89) idCheck_List -> . ID

    ID              shift and go to state 98

    idCheck_List                   shift and go to state 97

state 58

    (42) asign -> ID . id_val EQUAL equal_val expression
    (43) asign -> ID . id_val EQUAL equal_val call
    (98) call -> ID . id_call LPAR par_call RPAR par_call2
    (99) call -> ID . id_call LPAR par_call params RPAR par_call2
    (95) add -> ID . idCheck_Add POINT ADD LPAR listx_add RPAR
    (97) remove -> ID . idCheck_Add POINT REMOVE LPAR RPAR
    (44) id_val -> .
    (100) id_call -> .
    (96) idCheck_Add -> .

    EQUAL           reduce using rule 44 (id_val -> .)
    LPAR            reduce using rule 100 (id_call -> .)
    POINT           reduce using rule 96 (idCheck_Add -> .)

    idCheck_Add                    shift and go to state 99
    id_call                        shift and go to state 91
    id_val                         shift and go to state 25

state 59

    (34) statement -> turnright .

    INT             reduce using rule 34 (statement -> turnright .)
    FLOAT           reduce using rule 34 (statement -> turnright .)
    BOOLEAN         reduce using rule 34 (statement -> turnright .)
    ID              reduce using rule 34 (statement -> turnright .)
    IF              reduce using rule 34 (statement -> turnright .)
    WHILE           reduce using rule 34 (statement -> turnright .)
    PRINT           reduce using rule 34 (statement -> turnright .)
    LIST            reduce using rule 34 (statement -> turnright .)
    MOVE            reduce using rule 34 (statement -> turnright .)
    EAT             reduce using rule 34 (statement -> turnright .)
    CLEAN           reduce using rule 34 (statement -> turnright .)
    PLAY            reduce using rule 34 (statement -> turnright .)
    TURNLEFT        reduce using rule 34 (statement -> turnright .)
    TURNRIGHT       reduce using rule 34 (statement -> turnright .)
    RETURN          reduce using rule 34 (statement -> turnright .)
    RCBRACKET       reduce using rule 34 (statement -> turnright .)


state 60

    (31) statement -> add .

    INT             reduce using rule 31 (statement -> add .)
    FLOAT           reduce using rule 31 (statement -> add .)
    BOOLEAN         reduce using rule 31 (statement -> add .)
    ID              reduce using rule 31 (statement -> add .)
    IF              reduce using rule 31 (statement -> add .)
    WHILE           reduce using rule 31 (statement -> add .)
    PRINT           reduce using rule 31 (statement -> add .)
    LIST            reduce using rule 31 (statement -> add .)
    MOVE            reduce using rule 31 (statement -> add .)
    EAT             reduce using rule 31 (statement -> add .)
    CLEAN           reduce using rule 31 (statement -> add .)
    PLAY            reduce using rule 31 (statement -> add .)
    TURNLEFT        reduce using rule 31 (statement -> add .)
    TURNRIGHT       reduce using rule 31 (statement -> add .)
    RETURN          reduce using rule 31 (statement -> add .)
    RCBRACKET       reduce using rule 31 (statement -> add .)


state 61

    (26) statement -> call .

    INT             reduce using rule 26 (statement -> call .)
    FLOAT           reduce using rule 26 (statement -> call .)
    BOOLEAN         reduce using rule 26 (statement -> call .)
    ID              reduce using rule 26 (statement -> call .)
    IF              reduce using rule 26 (statement -> call .)
    WHILE           reduce using rule 26 (statement -> call .)
    PRINT           reduce using rule 26 (statement -> call .)
    LIST            reduce using rule 26 (statement -> call .)
    MOVE            reduce using rule 26 (statement -> call .)
    EAT             reduce using rule 26 (statement -> call .)
    CLEAN           reduce using rule 26 (statement -> call .)
    PLAY            reduce using rule 26 (statement -> call .)
    TURNLEFT        reduce using rule 26 (statement -> call .)
    TURNRIGHT       reduce using rule 26 (statement -> call .)
    RETURN          reduce using rule 26 (statement -> call .)
    RCBRACKET       reduce using rule 26 (statement -> call .)


state 62

    (19) blockx -> statement .
    (20) blockx -> statement . blockx
    (17) blockx -> . vars
    (18) blockx -> . vars blockx
    (19) blockx -> . statement
    (20) blockx -> . statement blockx
    (38) vars -> . type ID
    (21) statement -> . asign
    (22) statement -> . condition
    (23) statement -> . cycle
    (24) statement -> . print
    (25) statement -> . list
    (26) statement -> . call
    (27) statement -> . move
    (28) statement -> . eat
    (29) statement -> . clean
    (30) statement -> . play
    (31) statement -> . add
    (32) statement -> . remove
    (33) statement -> . turnleft
    (34) statement -> . turnright
    (35) statement -> . return
    (39) type -> . INT
    (40) type -> . FLOAT
    (41) type -> . BOOLEAN
    (42) asign -> . ID id_val EQUAL equal_val expression
    (43) asign -> . ID id_val EQUAL equal_val call
    (76) condition -> . IF LPAR exp RPAR cond_1 block else cond_2
    (72) cycle -> . WHILE cycle_1 LPAR exp RPAR cycle_2 block cycle_3
    (63) print -> . PRINT LPAR par_call printx expCheck RPAR
    (82) list -> . LIST idCheck_List EQUAL LBRACKET listx RBRACKET
    (98) call -> . ID id_call LPAR par_call RPAR par_call2
    (99) call -> . ID id_call LPAR par_call params RPAR par_call2
    (107) move -> . MOVE LPAR ID RPAR
    (108) eat -> . EAT LPAR ID RPAR
    (109) clean -> . CLEAN LPAR ID RPAR
    (110) play -> . PLAY LPAR ID RPAR
    (95) add -> . ID idCheck_Add POINT ADD LPAR listx_add RPAR
    (97) remove -> . ID idCheck_Add POINT REMOVE LPAR RPAR
    (111) turnleft -> . TURNLEFT LPAR RPAR
    (112) turnright -> . TURNRIGHT LPAR RPAR
    (36) return -> . RETURN LPAR par_call expression RPAR par_call2

    RCBRACKET       reduce using rule 19 (blockx -> statement .)
    INT             shift and go to state 4
    FLOAT           shift and go to state 2
    BOOLEAN         shift and go to state 5
    ID              shift and go to state 58
    IF              shift and go to state 64
    WHILE           shift and go to state 55
    PRINT           shift and go to state 56
    LIST            shift and go to state 57
    MOVE            shift and go to state 68
    EAT             shift and go to state 65
    CLEAN           shift and go to state 73
    PLAY            shift and go to state 66
    TURNLEFT        shift and go to state 77
    TURNRIGHT       shift and go to state 72
    RETURN          shift and go to state 52

    vars                           shift and go to state 53
    move                           shift and go to state 54
    turnright                      shift and go to state 59
    add                            shift and go to state 60
    call                           shift and go to state 61
    statement                      shift and go to state 62
    print                          shift and go to state 63
    type                           shift and go to state 29
    play                           shift and go to state 67
    return                         shift and go to state 69
    turnleft                       shift and go to state 70
    blockx                         shift and go to state 100
    eat                            shift and go to state 74
    condition                      shift and go to state 75
    cycle                          shift and go to state 76
    list                           shift and go to state 78
    remove                         shift and go to state 79
    asign                          shift and go to state 80
    clean                          shift and go to state 81

state 63

    (24) statement -> print .

    INT             reduce using rule 24 (statement -> print .)
    FLOAT           reduce using rule 24 (statement -> print .)
    BOOLEAN         reduce using rule 24 (statement -> print .)
    ID              reduce using rule 24 (statement -> print .)
    IF              reduce using rule 24 (statement -> print .)
    WHILE           reduce using rule 24 (statement -> print .)
    PRINT           reduce using rule 24 (statement -> print .)
    LIST            reduce using rule 24 (statement -> print .)
    MOVE            reduce using rule 24 (statement -> print .)
    EAT             reduce using rule 24 (statement -> print .)
    CLEAN           reduce using rule 24 (statement -> print .)
    PLAY            reduce using rule 24 (statement -> print .)
    TURNLEFT        reduce using rule 24 (statement -> print .)
    TURNRIGHT       reduce using rule 24 (statement -> print .)
    RETURN          reduce using rule 24 (statement -> print .)
    RCBRACKET       reduce using rule 24 (statement -> print .)


state 64

    (76) condition -> IF . LPAR exp RPAR cond_1 block else cond_2

    LPAR            shift and go to state 101


state 65

    (108) eat -> EAT . LPAR ID RPAR

    LPAR            shift and go to state 102


state 66

    (110) play -> PLAY . LPAR ID RPAR

    LPAR            shift and go to state 103


state 67

    (30) statement -> play .

    INT             reduce using rule 30 (statement -> play .)
    FLOAT           reduce using rule 30 (statement -> play .)
    BOOLEAN         reduce using rule 30 (statement -> play .)
    ID              reduce using rule 30 (statement -> play .)
    IF              reduce using rule 30 (statement -> play .)
    WHILE           reduce using rule 30 (statement -> play .)
    PRINT           reduce using rule 30 (statement -> play .)
    LIST            reduce using rule 30 (statement -> play .)
    MOVE            reduce using rule 30 (statement -> play .)
    EAT             reduce using rule 30 (statement -> play .)
    CLEAN           reduce using rule 30 (statement -> play .)
    PLAY            reduce using rule 30 (statement -> play .)
    TURNLEFT        reduce using rule 30 (statement -> play .)
    TURNRIGHT       reduce using rule 30 (statement -> play .)
    RETURN          reduce using rule 30 (statement -> play .)
    RCBRACKET       reduce using rule 30 (statement -> play .)


state 68

    (107) move -> MOVE . LPAR ID RPAR

    LPAR            shift and go to state 104


state 69

    (35) statement -> return .

    INT             reduce using rule 35 (statement -> return .)
    FLOAT           reduce using rule 35 (statement -> return .)
    BOOLEAN         reduce using rule 35 (statement -> return .)
    ID              reduce using rule 35 (statement -> return .)
    IF              reduce using rule 35 (statement -> return .)
    WHILE           reduce using rule 35 (statement -> return .)
    PRINT           reduce using rule 35 (statement -> return .)
    LIST            reduce using rule 35 (statement -> return .)
    MOVE            reduce using rule 35 (statement -> return .)
    EAT             reduce using rule 35 (statement -> return .)
    CLEAN           reduce using rule 35 (statement -> return .)
    PLAY            reduce using rule 35 (statement -> return .)
    TURNLEFT        reduce using rule 35 (statement -> return .)
    TURNRIGHT       reduce using rule 35 (statement -> return .)
    RETURN          reduce using rule 35 (statement -> return .)
    RCBRACKET       reduce using rule 35 (statement -> return .)


state 70

    (33) statement -> turnleft .

    INT             reduce using rule 33 (statement -> turnleft .)
    FLOAT           reduce using rule 33 (statement -> turnleft .)
    BOOLEAN         reduce using rule 33 (statement -> turnleft .)
    ID              reduce using rule 33 (statement -> turnleft .)
    IF              reduce using rule 33 (statement -> turnleft .)
    WHILE           reduce using rule 33 (statement -> turnleft .)
    PRINT           reduce using rule 33 (statement -> turnleft .)
    LIST            reduce using rule 33 (statement -> turnleft .)
    MOVE            reduce using rule 33 (statement -> turnleft .)
    EAT             reduce using rule 33 (statement -> turnleft .)
    CLEAN           reduce using rule 33 (statement -> turnleft .)
    PLAY            reduce using rule 33 (statement -> turnleft .)
    TURNLEFT        reduce using rule 33 (statement -> turnleft .)
    TURNRIGHT       reduce using rule 33 (statement -> turnleft .)
    RETURN          reduce using rule 33 (statement -> turnleft .)
    RCBRACKET       reduce using rule 33 (statement -> turnleft .)


state 71

    (16) block -> LCBRACKET blockx . RCBRACKET

    RCBRACKET       shift and go to state 105


state 72

    (112) turnright -> TURNRIGHT . LPAR RPAR

    LPAR            shift and go to state 106


state 73

    (109) clean -> CLEAN . LPAR ID RPAR

    LPAR            shift and go to state 107


state 74

    (28) statement -> eat .

    INT             reduce using rule 28 (statement -> eat .)
    FLOAT           reduce using rule 28 (statement -> eat .)
    BOOLEAN         reduce using rule 28 (statement -> eat .)
    ID              reduce using rule 28 (statement -> eat .)
    IF              reduce using rule 28 (statement -> eat .)
    WHILE           reduce using rule 28 (statement -> eat .)
    PRINT           reduce using rule 28 (statement -> eat .)
    LIST            reduce using rule 28 (statement -> eat .)
    MOVE            reduce using rule 28 (statement -> eat .)
    EAT             reduce using rule 28 (statement -> eat .)
    CLEAN           reduce using rule 28 (statement -> eat .)
    PLAY            reduce using rule 28 (statement -> eat .)
    TURNLEFT        reduce using rule 28 (statement -> eat .)
    TURNRIGHT       reduce using rule 28 (statement -> eat .)
    RETURN          reduce using rule 28 (statement -> eat .)
    RCBRACKET       reduce using rule 28 (statement -> eat .)


state 75

    (22) statement -> condition .

    INT             reduce using rule 22 (statement -> condition .)
    FLOAT           reduce using rule 22 (statement -> condition .)
    BOOLEAN         reduce using rule 22 (statement -> condition .)
    ID              reduce using rule 22 (statement -> condition .)
    IF              reduce using rule 22 (statement -> condition .)
    WHILE           reduce using rule 22 (statement -> condition .)
    PRINT           reduce using rule 22 (statement -> condition .)
    LIST            reduce using rule 22 (statement -> condition .)
    MOVE            reduce using rule 22 (statement -> condition .)
    EAT             reduce using rule 22 (statement -> condition .)
    CLEAN           reduce using rule 22 (statement -> condition .)
    PLAY            reduce using rule 22 (statement -> condition .)
    TURNLEFT        reduce using rule 22 (statement -> condition .)
    TURNRIGHT       reduce using rule 22 (statement -> condition .)
    RETURN          reduce using rule 22 (statement -> condition .)
    RCBRACKET       reduce using rule 22 (statement -> condition .)


state 76

    (23) statement -> cycle .

    INT             reduce using rule 23 (statement -> cycle .)
    FLOAT           reduce using rule 23 (statement -> cycle .)
    BOOLEAN         reduce using rule 23 (statement -> cycle .)
    ID              reduce using rule 23 (statement -> cycle .)
    IF              reduce using rule 23 (statement -> cycle .)
    WHILE           reduce using rule 23 (statement -> cycle .)
    PRINT           reduce using rule 23 (statement -> cycle .)
    LIST            reduce using rule 23 (statement -> cycle .)
    MOVE            reduce using rule 23 (statement -> cycle .)
    EAT             reduce using rule 23 (statement -> cycle .)
    CLEAN           reduce using rule 23 (statement -> cycle .)
    PLAY            reduce using rule 23 (statement -> cycle .)
    TURNLEFT        reduce using rule 23 (statement -> cycle .)
    TURNRIGHT       reduce using rule 23 (statement -> cycle .)
    RETURN          reduce using rule 23 (statement -> cycle .)
    RCBRACKET       reduce using rule 23 (statement -> cycle .)


state 77

    (111) turnleft -> TURNLEFT . LPAR RPAR

    LPAR            shift and go to state 108


state 78

    (25) statement -> list .

    INT             reduce using rule 25 (statement -> list .)
    FLOAT           reduce using rule 25 (statement -> list .)
    BOOLEAN         reduce using rule 25 (statement -> list .)
    ID              reduce using rule 25 (statement -> list .)
    IF              reduce using rule 25 (statement -> list .)
    WHILE           reduce using rule 25 (statement -> list .)
    PRINT           reduce using rule 25 (statement -> list .)
    LIST            reduce using rule 25 (statement -> list .)
    MOVE            reduce using rule 25 (statement -> list .)
    EAT             reduce using rule 25 (statement -> list .)
    CLEAN           reduce using rule 25 (statement -> list .)
    PLAY            reduce using rule 25 (statement -> list .)
    TURNLEFT        reduce using rule 25 (statement -> list .)
    TURNRIGHT       reduce using rule 25 (statement -> list .)
    RETURN          reduce using rule 25 (statement -> list .)
    RCBRACKET       reduce using rule 25 (statement -> list .)


state 79

    (32) statement -> remove .

    INT             reduce using rule 32 (statement -> remove .)
    FLOAT           reduce using rule 32 (statement -> remove .)
    BOOLEAN         reduce using rule 32 (statement -> remove .)
    ID              reduce using rule 32 (statement -> remove .)
    IF              reduce using rule 32 (statement -> remove .)
    WHILE           reduce using rule 32 (statement -> remove .)
    PRINT           reduce using rule 32 (statement -> remove .)
    LIST            reduce using rule 32 (statement -> remove .)
    MOVE            reduce using rule 32 (statement -> remove .)
    EAT             reduce using rule 32 (statement -> remove .)
    CLEAN           reduce using rule 32 (statement -> remove .)
    PLAY            reduce using rule 32 (statement -> remove .)
    TURNLEFT        reduce using rule 32 (statement -> remove .)
    TURNRIGHT       reduce using rule 32 (statement -> remove .)
    RETURN          reduce using rule 32 (statement -> remove .)
    RCBRACKET       reduce using rule 32 (statement -> remove .)


state 80

    (21) statement -> asign .

    INT             reduce using rule 21 (statement -> asign .)
    FLOAT           reduce using rule 21 (statement -> asign .)
    BOOLEAN         reduce using rule 21 (statement -> asign .)
    ID              reduce using rule 21 (statement -> asign .)
    IF              reduce using rule 21 (statement -> asign .)
    WHILE           reduce using rule 21 (statement -> asign .)
    PRINT           reduce using rule 21 (statement -> asign .)
    LIST            reduce using rule 21 (statement -> asign .)
    MOVE            reduce using rule 21 (statement -> asign .)
    EAT             reduce using rule 21 (statement -> asign .)
    CLEAN           reduce using rule 21 (statement -> asign .)
    PLAY            reduce using rule 21 (statement -> asign .)
    TURNLEFT        reduce using rule 21 (statement -> asign .)
    TURNRIGHT       reduce using rule 21 (statement -> asign .)
    RETURN          reduce using rule 21 (statement -> asign .)
    RCBRACKET       reduce using rule 21 (statement -> asign .)


state 81

    (29) statement -> clean .

    INT             reduce using rule 29 (statement -> clean .)
    FLOAT           reduce using rule 29 (statement -> clean .)
    BOOLEAN         reduce using rule 29 (statement -> clean .)
    ID              reduce using rule 29 (statement -> clean .)
    IF              reduce using rule 29 (statement -> clean .)
    WHILE           reduce using rule 29 (statement -> clean .)
    PRINT           reduce using rule 29 (statement -> clean .)
    LIST            reduce using rule 29 (statement -> clean .)
    MOVE            reduce using rule 29 (statement -> clean .)
    EAT             reduce using rule 29 (statement -> clean .)
    CLEAN           reduce using rule 29 (statement -> clean .)
    PLAY            reduce using rule 29 (statement -> clean .)
    TURNLEFT        reduce using rule 29 (statement -> clean .)
    TURNRIGHT       reduce using rule 29 (statement -> clean .)
    RETURN          reduce using rule 29 (statement -> clean .)
    RCBRACKET       reduce using rule 29 (statement -> clean .)


state 82

    (9) func -> FUNC idCheck LPAR funcx RPAR block func_end .

    FUNC            reduce using rule 9 (func -> FUNC idCheck LPAR funcx RPAR block func_end .)
    $end            reduce using rule 9 (func -> FUNC idCheck LPAR funcx RPAR block func_end .)
    INT             reduce using rule 9 (func -> FUNC idCheck LPAR funcx RPAR block func_end .)
    FLOAT           reduce using rule 9 (func -> FUNC idCheck LPAR funcx RPAR block func_end .)
    BOOLEAN         reduce using rule 9 (func -> FUNC idCheck LPAR funcx RPAR block func_end .)
    ID              reduce using rule 9 (func -> FUNC idCheck LPAR funcx RPAR block func_end .)


state 83

    (59) varcte -> ID .

    MULTIPLY        reduce using rule 59 (varcte -> ID .)
    DIVIDE          reduce using rule 59 (varcte -> ID .)
    PLUS            reduce using rule 59 (varcte -> ID .)
    MINUS           reduce using rule 59 (varcte -> ID .)
    COMPARISON      reduce using rule 59 (varcte -> ID .)
    RPAR            reduce using rule 59 (varcte -> ID .)
    ID              reduce using rule 59 (varcte -> ID .)
    FUNC            reduce using rule 59 (varcte -> ID .)
    $end            reduce using rule 59 (varcte -> ID .)
    INT             reduce using rule 59 (varcte -> ID .)
    FLOAT           reduce using rule 59 (varcte -> ID .)
    BOOLEAN         reduce using rule 59 (varcte -> ID .)
    IF              reduce using rule 59 (varcte -> ID .)
    WHILE           reduce using rule 59 (varcte -> ID .)
    PRINT           reduce using rule 59 (varcte -> ID .)
    LIST            reduce using rule 59 (varcte -> ID .)
    MOVE            reduce using rule 59 (varcte -> ID .)
    EAT             reduce using rule 59 (varcte -> ID .)
    CLEAN           reduce using rule 59 (varcte -> ID .)
    PLAY            reduce using rule 59 (varcte -> ID .)
    TURNLEFT        reduce using rule 59 (varcte -> ID .)
    TURNRIGHT       reduce using rule 59 (varcte -> ID .)
    RETURN          reduce using rule 59 (varcte -> ID .)
    RCBRACKET       reduce using rule 59 (varcte -> ID .)
    LPAR            reduce using rule 59 (varcte -> ID .)
    NUMINT          reduce using rule 59 (varcte -> ID .)
    NUMFLOAT        reduce using rule 59 (varcte -> ID .)
    BOOLEANTYPE     reduce using rule 59 (varcte -> ID .)
    COMA            reduce using rule 59 (varcte -> ID .)


state 84

    (56) factor -> LPAR expression . RPAR

    RPAR            shift and go to state 109


state 85

    (49) exp -> termino PLUS . op_val exp
    (55) op_val -> .

    LPAR            reduce using rule 55 (op_val -> .)
    MINUS           reduce using rule 55 (op_val -> .)
    ID              reduce using rule 55 (op_val -> .)
    NUMINT          reduce using rule 55 (op_val -> .)
    NUMFLOAT        reduce using rule 55 (op_val -> .)
    BOOLEANTYPE     reduce using rule 55 (op_val -> .)

    op_val                         shift and go to state 110

state 86

    (50) exp -> termino MINUS . op_val exp
    (55) op_val -> .

    LPAR            reduce using rule 55 (op_val -> .)
    MINUS           reduce using rule 55 (op_val -> .)
    ID              reduce using rule 55 (op_val -> .)
    NUMINT          reduce using rule 55 (op_val -> .)
    NUMFLOAT        reduce using rule 55 (op_val -> .)
    BOOLEANTYPE     reduce using rule 55 (op_val -> .)

    op_val                         shift and go to state 111

state 87

    (57) factor -> MINUS varcte .

    MULTIPLY        reduce using rule 57 (factor -> MINUS varcte .)
    DIVIDE          reduce using rule 57 (factor -> MINUS varcte .)
    PLUS            reduce using rule 57 (factor -> MINUS varcte .)
    MINUS           reduce using rule 57 (factor -> MINUS varcte .)
    RPAR            reduce using rule 57 (factor -> MINUS varcte .)
    COMPARISON      reduce using rule 57 (factor -> MINUS varcte .)
    ID              reduce using rule 57 (factor -> MINUS varcte .)
    FUNC            reduce using rule 57 (factor -> MINUS varcte .)
    $end            reduce using rule 57 (factor -> MINUS varcte .)
    INT             reduce using rule 57 (factor -> MINUS varcte .)
    FLOAT           reduce using rule 57 (factor -> MINUS varcte .)
    BOOLEAN         reduce using rule 57 (factor -> MINUS varcte .)
    IF              reduce using rule 57 (factor -> MINUS varcte .)
    WHILE           reduce using rule 57 (factor -> MINUS varcte .)
    PRINT           reduce using rule 57 (factor -> MINUS varcte .)
    LIST            reduce using rule 57 (factor -> MINUS varcte .)
    MOVE            reduce using rule 57 (factor -> MINUS varcte .)
    EAT             reduce using rule 57 (factor -> MINUS varcte .)
    CLEAN           reduce using rule 57 (factor -> MINUS varcte .)
    PLAY            reduce using rule 57 (factor -> MINUS varcte .)
    TURNLEFT        reduce using rule 57 (factor -> MINUS varcte .)
    TURNRIGHT       reduce using rule 57 (factor -> MINUS varcte .)
    RETURN          reduce using rule 57 (factor -> MINUS varcte .)
    RCBRACKET       reduce using rule 57 (factor -> MINUS varcte .)
    LPAR            reduce using rule 57 (factor -> MINUS varcte .)
    NUMINT          reduce using rule 57 (factor -> MINUS varcte .)
    NUMFLOAT        reduce using rule 57 (factor -> MINUS varcte .)
    BOOLEANTYPE     reduce using rule 57 (factor -> MINUS varcte .)
    COMA            reduce using rule 57 (factor -> MINUS varcte .)


state 88

    (58) factor -> varcte termino_val .

    MULTIPLY        reduce using rule 58 (factor -> varcte termino_val .)
    DIVIDE          reduce using rule 58 (factor -> varcte termino_val .)
    PLUS            reduce using rule 58 (factor -> varcte termino_val .)
    MINUS           reduce using rule 58 (factor -> varcte termino_val .)
    RPAR            reduce using rule 58 (factor -> varcte termino_val .)
    COMPARISON      reduce using rule 58 (factor -> varcte termino_val .)
    ID              reduce using rule 58 (factor -> varcte termino_val .)
    FUNC            reduce using rule 58 (factor -> varcte termino_val .)
    $end            reduce using rule 58 (factor -> varcte termino_val .)
    INT             reduce using rule 58 (factor -> varcte termino_val .)
    FLOAT           reduce using rule 58 (factor -> varcte termino_val .)
    BOOLEAN         reduce using rule 58 (factor -> varcte termino_val .)
    IF              reduce using rule 58 (factor -> varcte termino_val .)
    WHILE           reduce using rule 58 (factor -> varcte termino_val .)
    PRINT           reduce using rule 58 (factor -> varcte termino_val .)
    LIST            reduce using rule 58 (factor -> varcte termino_val .)
    MOVE            reduce using rule 58 (factor -> varcte termino_val .)
    EAT             reduce using rule 58 (factor -> varcte termino_val .)
    CLEAN           reduce using rule 58 (factor -> varcte termino_val .)
    PLAY            reduce using rule 58 (factor -> varcte termino_val .)
    TURNLEFT        reduce using rule 58 (factor -> varcte termino_val .)
    TURNRIGHT       reduce using rule 58 (factor -> varcte termino_val .)
    RETURN          reduce using rule 58 (factor -> varcte termino_val .)
    RCBRACKET       reduce using rule 58 (factor -> varcte termino_val .)
    LPAR            reduce using rule 58 (factor -> varcte termino_val .)
    NUMINT          reduce using rule 58 (factor -> varcte termino_val .)
    NUMFLOAT        reduce using rule 58 (factor -> varcte termino_val .)
    BOOLEANTYPE     reduce using rule 58 (factor -> varcte termino_val .)
    COMA            reduce using rule 58 (factor -> varcte termino_val .)


state 89

    (52) termino -> factor MULTIPLY . op_val termino
    (55) op_val -> .

    LPAR            reduce using rule 55 (op_val -> .)
    MINUS           reduce using rule 55 (op_val -> .)
    ID              reduce using rule 55 (op_val -> .)
    NUMINT          reduce using rule 55 (op_val -> .)
    NUMFLOAT        reduce using rule 55 (op_val -> .)
    BOOLEANTYPE     reduce using rule 55 (op_val -> .)

    op_val                         shift and go to state 112

state 90

    (53) termino -> factor DIVIDE . op_val termino
    (55) op_val -> .

    LPAR            reduce using rule 55 (op_val -> .)
    MINUS           reduce using rule 55 (op_val -> .)
    ID              reduce using rule 55 (op_val -> .)
    NUMINT          reduce using rule 55 (op_val -> .)
    NUMFLOAT        reduce using rule 55 (op_val -> .)
    BOOLEANTYPE     reduce using rule 55 (op_val -> .)

    op_val                         shift and go to state 113

state 91

    (98) call -> ID id_call . LPAR par_call RPAR par_call2
    (99) call -> ID id_call . LPAR par_call params RPAR par_call2

    LPAR            shift and go to state 114


state 92

    (47) expression -> exp COMPARISON . op_val expression
    (55) op_val -> .

    LPAR            reduce using rule 55 (op_val -> .)
    MINUS           reduce using rule 55 (op_val -> .)
    ID              reduce using rule 55 (op_val -> .)
    NUMINT          reduce using rule 55 (op_val -> .)
    NUMFLOAT        reduce using rule 55 (op_val -> .)
    BOOLEANTYPE     reduce using rule 55 (op_val -> .)

    op_val                         shift and go to state 115

state 93

    (36) return -> RETURN LPAR . par_call expression RPAR par_call2
    (101) par_call -> .

    LPAR            reduce using rule 101 (par_call -> .)
    MINUS           reduce using rule 101 (par_call -> .)
    ID              reduce using rule 101 (par_call -> .)
    NUMINT          reduce using rule 101 (par_call -> .)
    NUMFLOAT        reduce using rule 101 (par_call -> .)
    BOOLEANTYPE     reduce using rule 101 (par_call -> .)

    par_call                       shift and go to state 116

state 94

    (18) blockx -> vars blockx .

    RCBRACKET       reduce using rule 18 (blockx -> vars blockx .)


state 95

    (72) cycle -> WHILE cycle_1 . LPAR exp RPAR cycle_2 block cycle_3

    LPAR            shift and go to state 117


state 96

    (63) print -> PRINT LPAR . par_call printx expCheck RPAR
    (101) par_call -> .

    ID              reduce using rule 101 (par_call -> .)
    LPAR            reduce using rule 101 (par_call -> .)
    MINUS           reduce using rule 101 (par_call -> .)
    NUMINT          reduce using rule 101 (par_call -> .)
    NUMFLOAT        reduce using rule 101 (par_call -> .)
    BOOLEANTYPE     reduce using rule 101 (par_call -> .)

    par_call                       shift and go to state 118

state 97

    (82) list -> LIST idCheck_List . EQUAL LBRACKET listx RBRACKET

    EQUAL           shift and go to state 119


state 98

    (89) idCheck_List -> ID .

    EQUAL           reduce using rule 89 (idCheck_List -> ID .)


state 99

    (95) add -> ID idCheck_Add . POINT ADD LPAR listx_add RPAR
    (97) remove -> ID idCheck_Add . POINT REMOVE LPAR RPAR

    POINT           shift and go to state 120


state 100

    (20) blockx -> statement blockx .

    RCBRACKET       reduce using rule 20 (blockx -> statement blockx .)


state 101

    (76) condition -> IF LPAR . exp RPAR cond_1 block else cond_2
    (48) exp -> . termino
    (49) exp -> . termino PLUS op_val exp
    (50) exp -> . termino MINUS op_val exp
    (51) termino -> . factor
    (52) termino -> . factor MULTIPLY op_val termino
    (53) termino -> . factor DIVIDE op_val termino
    (56) factor -> . LPAR expression RPAR
    (57) factor -> . MINUS varcte
    (58) factor -> . varcte termino_val
    (59) varcte -> . ID
    (60) varcte -> . NUMINT
    (61) varcte -> . NUMFLOAT
    (62) varcte -> . BOOLEANTYPE

    LPAR            shift and go to state 39
    MINUS           shift and go to state 42
    ID              shift and go to state 83
    NUMINT          shift and go to state 47
    NUMFLOAT        shift and go to state 41
    BOOLEANTYPE     shift and go to state 49

    varcte                         shift and go to state 43
    termino                        shift and go to state 40
    exp                            shift and go to state 121
    factor                         shift and go to state 45

state 102

    (108) eat -> EAT LPAR . ID RPAR

    ID              shift and go to state 122


state 103

    (110) play -> PLAY LPAR . ID RPAR

    ID              shift and go to state 123


state 104

    (107) move -> MOVE LPAR . ID RPAR

    ID              shift and go to state 124


state 105

    (16) block -> LCBRACKET blockx RCBRACKET .

    ELSE            reduce using rule 16 (block -> LCBRACKET blockx RCBRACKET .)
    INT             reduce using rule 16 (block -> LCBRACKET blockx RCBRACKET .)
    FLOAT           reduce using rule 16 (block -> LCBRACKET blockx RCBRACKET .)
    BOOLEAN         reduce using rule 16 (block -> LCBRACKET blockx RCBRACKET .)
    ID              reduce using rule 16 (block -> LCBRACKET blockx RCBRACKET .)
    IF              reduce using rule 16 (block -> LCBRACKET blockx RCBRACKET .)
    WHILE           reduce using rule 16 (block -> LCBRACKET blockx RCBRACKET .)
    PRINT           reduce using rule 16 (block -> LCBRACKET blockx RCBRACKET .)
    LIST            reduce using rule 16 (block -> LCBRACKET blockx RCBRACKET .)
    MOVE            reduce using rule 16 (block -> LCBRACKET blockx RCBRACKET .)
    EAT             reduce using rule 16 (block -> LCBRACKET blockx RCBRACKET .)
    CLEAN           reduce using rule 16 (block -> LCBRACKET blockx RCBRACKET .)
    PLAY            reduce using rule 16 (block -> LCBRACKET blockx RCBRACKET .)
    TURNLEFT        reduce using rule 16 (block -> LCBRACKET blockx RCBRACKET .)
    TURNRIGHT       reduce using rule 16 (block -> LCBRACKET blockx RCBRACKET .)
    RETURN          reduce using rule 16 (block -> LCBRACKET blockx RCBRACKET .)
    RCBRACKET       reduce using rule 16 (block -> LCBRACKET blockx RCBRACKET .)
    FUNC            reduce using rule 16 (block -> LCBRACKET blockx RCBRACKET .)
    $end            reduce using rule 16 (block -> LCBRACKET blockx RCBRACKET .)


state 106

    (112) turnright -> TURNRIGHT LPAR . RPAR

    RPAR            shift and go to state 125


state 107

    (109) clean -> CLEAN LPAR . ID RPAR

    ID              shift and go to state 126


state 108

    (111) turnleft -> TURNLEFT LPAR . RPAR

    RPAR            shift and go to state 127


state 109

    (56) factor -> LPAR expression RPAR .

    MULTIPLY        reduce using rule 56 (factor -> LPAR expression RPAR .)
    DIVIDE          reduce using rule 56 (factor -> LPAR expression RPAR .)
    PLUS            reduce using rule 56 (factor -> LPAR expression RPAR .)
    MINUS           reduce using rule 56 (factor -> LPAR expression RPAR .)
    RPAR            reduce using rule 56 (factor -> LPAR expression RPAR .)
    COMPARISON      reduce using rule 56 (factor -> LPAR expression RPAR .)
    ID              reduce using rule 56 (factor -> LPAR expression RPAR .)
    FUNC            reduce using rule 56 (factor -> LPAR expression RPAR .)
    $end            reduce using rule 56 (factor -> LPAR expression RPAR .)
    INT             reduce using rule 56 (factor -> LPAR expression RPAR .)
    FLOAT           reduce using rule 56 (factor -> LPAR expression RPAR .)
    BOOLEAN         reduce using rule 56 (factor -> LPAR expression RPAR .)
    IF              reduce using rule 56 (factor -> LPAR expression RPAR .)
    WHILE           reduce using rule 56 (factor -> LPAR expression RPAR .)
    PRINT           reduce using rule 56 (factor -> LPAR expression RPAR .)
    LIST            reduce using rule 56 (factor -> LPAR expression RPAR .)
    MOVE            reduce using rule 56 (factor -> LPAR expression RPAR .)
    EAT             reduce using rule 56 (factor -> LPAR expression RPAR .)
    CLEAN           reduce using rule 56 (factor -> LPAR expression RPAR .)
    PLAY            reduce using rule 56 (factor -> LPAR expression RPAR .)
    TURNLEFT        reduce using rule 56 (factor -> LPAR expression RPAR .)
    TURNRIGHT       reduce using rule 56 (factor -> LPAR expression RPAR .)
    RETURN          reduce using rule 56 (factor -> LPAR expression RPAR .)
    RCBRACKET       reduce using rule 56 (factor -> LPAR expression RPAR .)
    LPAR            reduce using rule 56 (factor -> LPAR expression RPAR .)
    NUMINT          reduce using rule 56 (factor -> LPAR expression RPAR .)
    NUMFLOAT        reduce using rule 56 (factor -> LPAR expression RPAR .)
    BOOLEANTYPE     reduce using rule 56 (factor -> LPAR expression RPAR .)
    COMA            reduce using rule 56 (factor -> LPAR expression RPAR .)


state 110

    (49) exp -> termino PLUS op_val . exp
    (48) exp -> . termino
    (49) exp -> . termino PLUS op_val exp
    (50) exp -> . termino MINUS op_val exp
    (51) termino -> . factor
    (52) termino -> . factor MULTIPLY op_val termino
    (53) termino -> . factor DIVIDE op_val termino
    (56) factor -> . LPAR expression RPAR
    (57) factor -> . MINUS varcte
    (58) factor -> . varcte termino_val
    (59) varcte -> . ID
    (60) varcte -> . NUMINT
    (61) varcte -> . NUMFLOAT
    (62) varcte -> . BOOLEANTYPE

    LPAR            shift and go to state 39
    MINUS           shift and go to state 42
    ID              shift and go to state 83
    NUMINT          shift and go to state 47
    NUMFLOAT        shift and go to state 41
    BOOLEANTYPE     shift and go to state 49

    varcte                         shift and go to state 43
    termino                        shift and go to state 40
    exp                            shift and go to state 128
    factor                         shift and go to state 45

state 111

    (50) exp -> termino MINUS op_val . exp
    (48) exp -> . termino
    (49) exp -> . termino PLUS op_val exp
    (50) exp -> . termino MINUS op_val exp
    (51) termino -> . factor
    (52) termino -> . factor MULTIPLY op_val termino
    (53) termino -> . factor DIVIDE op_val termino
    (56) factor -> . LPAR expression RPAR
    (57) factor -> . MINUS varcte
    (58) factor -> . varcte termino_val
    (59) varcte -> . ID
    (60) varcte -> . NUMINT
    (61) varcte -> . NUMFLOAT
    (62) varcte -> . BOOLEANTYPE

    LPAR            shift and go to state 39
    MINUS           shift and go to state 42
    ID              shift and go to state 83
    NUMINT          shift and go to state 47
    NUMFLOAT        shift and go to state 41
    BOOLEANTYPE     shift and go to state 49

    varcte                         shift and go to state 43
    termino                        shift and go to state 40
    exp                            shift and go to state 129
    factor                         shift and go to state 45

state 112

    (52) termino -> factor MULTIPLY op_val . termino
    (51) termino -> . factor
    (52) termino -> . factor MULTIPLY op_val termino
    (53) termino -> . factor DIVIDE op_val termino
    (56) factor -> . LPAR expression RPAR
    (57) factor -> . MINUS varcte
    (58) factor -> . varcte termino_val
    (59) varcte -> . ID
    (60) varcte -> . NUMINT
    (61) varcte -> . NUMFLOAT
    (62) varcte -> . BOOLEANTYPE

    LPAR            shift and go to state 39
    MINUS           shift and go to state 42
    ID              shift and go to state 83
    NUMINT          shift and go to state 47
    NUMFLOAT        shift and go to state 41
    BOOLEANTYPE     shift and go to state 49

    varcte                         shift and go to state 43
    factor                         shift and go to state 45
    termino                        shift and go to state 130

state 113

    (53) termino -> factor DIVIDE op_val . termino
    (51) termino -> . factor
    (52) termino -> . factor MULTIPLY op_val termino
    (53) termino -> . factor DIVIDE op_val termino
    (56) factor -> . LPAR expression RPAR
    (57) factor -> . MINUS varcte
    (58) factor -> . varcte termino_val
    (59) varcte -> . ID
    (60) varcte -> . NUMINT
    (61) varcte -> . NUMFLOAT
    (62) varcte -> . BOOLEANTYPE

    LPAR            shift and go to state 39
    MINUS           shift and go to state 42
    ID              shift and go to state 83
    NUMINT          shift and go to state 47
    NUMFLOAT        shift and go to state 41
    BOOLEANTYPE     shift and go to state 49

    varcte                         shift and go to state 43
    factor                         shift and go to state 45
    termino                        shift and go to state 131

state 114

    (98) call -> ID id_call LPAR . par_call RPAR par_call2
    (99) call -> ID id_call LPAR . par_call params RPAR par_call2
    (101) par_call -> .

    RPAR            reduce using rule 101 (par_call -> .)
    ID              reduce using rule 101 (par_call -> .)
    LPAR            reduce using rule 101 (par_call -> .)
    MINUS           reduce using rule 101 (par_call -> .)
    NUMINT          reduce using rule 101 (par_call -> .)
    NUMFLOAT        reduce using rule 101 (par_call -> .)
    BOOLEANTYPE     reduce using rule 101 (par_call -> .)

    par_call                       shift and go to state 132

state 115

    (47) expression -> exp COMPARISON op_val . expression
    (46) expression -> . exp
    (47) expression -> . exp COMPARISON op_val expression
    (48) exp -> . termino
    (49) exp -> . termino PLUS op_val exp
    (50) exp -> . termino MINUS op_val exp
    (51) termino -> . factor
    (52) termino -> . factor MULTIPLY op_val termino
    (53) termino -> . factor DIVIDE op_val termino
    (56) factor -> . LPAR expression RPAR
    (57) factor -> . MINUS varcte
    (58) factor -> . varcte termino_val
    (59) varcte -> . ID
    (60) varcte -> . NUMINT
    (61) varcte -> . NUMFLOAT
    (62) varcte -> . BOOLEANTYPE

    LPAR            shift and go to state 39
    MINUS           shift and go to state 42
    ID              shift and go to state 83
    NUMINT          shift and go to state 47
    NUMFLOAT        shift and go to state 41
    BOOLEANTYPE     shift and go to state 49

    varcte                         shift and go to state 43
    termino                        shift and go to state 40
    exp                            shift and go to state 48
    factor                         shift and go to state 45
    expression                     shift and go to state 133

state 116

    (36) return -> RETURN LPAR par_call . expression RPAR par_call2
    (46) expression -> . exp
    (47) expression -> . exp COMPARISON op_val expression
    (48) exp -> . termino
    (49) exp -> . termino PLUS op_val exp
    (50) exp -> . termino MINUS op_val exp
    (51) termino -> . factor
    (52) termino -> . factor MULTIPLY op_val termino
    (53) termino -> . factor DIVIDE op_val termino
    (56) factor -> . LPAR expression RPAR
    (57) factor -> . MINUS varcte
    (58) factor -> . varcte termino_val
    (59) varcte -> . ID
    (60) varcte -> . NUMINT
    (61) varcte -> . NUMFLOAT
    (62) varcte -> . BOOLEANTYPE

    LPAR            shift and go to state 39
    MINUS           shift and go to state 42
    ID              shift and go to state 83
    NUMINT          shift and go to state 47
    NUMFLOAT        shift and go to state 41
    BOOLEANTYPE     shift and go to state 49

    varcte                         shift and go to state 43
    termino                        shift and go to state 40
    exp                            shift and go to state 48
    factor                         shift and go to state 45
    expression                     shift and go to state 134

state 117

    (72) cycle -> WHILE cycle_1 LPAR . exp RPAR cycle_2 block cycle_3
    (48) exp -> . termino
    (49) exp -> . termino PLUS op_val exp
    (50) exp -> . termino MINUS op_val exp
    (51) termino -> . factor
    (52) termino -> . factor MULTIPLY op_val termino
    (53) termino -> . factor DIVIDE op_val termino
    (56) factor -> . LPAR expression RPAR
    (57) factor -> . MINUS varcte
    (58) factor -> . varcte termino_val
    (59) varcte -> . ID
    (60) varcte -> . NUMINT
    (61) varcte -> . NUMFLOAT
    (62) varcte -> . BOOLEANTYPE

    LPAR            shift and go to state 39
    MINUS           shift and go to state 42
    ID              shift and go to state 83
    NUMINT          shift and go to state 47
    NUMFLOAT        shift and go to state 41
    BOOLEANTYPE     shift and go to state 49

    termino                        shift and go to state 40
    exp                            shift and go to state 135
    factor                         shift and go to state 45
    varcte                         shift and go to state 43

state 118

    (63) print -> PRINT LPAR par_call . printx expCheck RPAR
    (64) printx -> . expression
    (65) printx -> . ID id_val
    (66) printx -> . call
    (67) printx -> . expression PLUS op_val printx
    (68) printx -> . ID id_val PLUS op_val printx
    (69) printx -> . call PLUS op_val printx
    (46) expression -> . exp
    (47) expression -> . exp COMPARISON op_val expression
    (98) call -> . ID id_call LPAR par_call RPAR par_call2
    (99) call -> . ID id_call LPAR par_call params RPAR par_call2
    (48) exp -> . termino
    (49) exp -> . termino PLUS op_val exp
    (50) exp -> . termino MINUS op_val exp
    (51) termino -> . factor
    (52) termino -> . factor MULTIPLY op_val termino
    (53) termino -> . factor DIVIDE op_val termino
    (56) factor -> . LPAR expression RPAR
    (57) factor -> . MINUS varcte
    (58) factor -> . varcte termino_val
    (59) varcte -> . ID
    (60) varcte -> . NUMINT
    (61) varcte -> . NUMFLOAT
    (62) varcte -> . BOOLEANTYPE

    ID              shift and go to state 138
    LPAR            shift and go to state 39
    MINUS           shift and go to state 42
    NUMINT          shift and go to state 47
    NUMFLOAT        shift and go to state 41
    BOOLEANTYPE     shift and go to state 49

    factor                         shift and go to state 45
    varcte                         shift and go to state 43
    printx                         shift and go to state 136
    call                           shift and go to state 137
    termino                        shift and go to state 40
    exp                            shift and go to state 48
    expression                     shift and go to state 139

state 119

    (82) list -> LIST idCheck_List EQUAL . LBRACKET listx RBRACKET

    LBRACKET        shift and go to state 140


state 120

    (95) add -> ID idCheck_Add POINT . ADD LPAR listx_add RPAR
    (97) remove -> ID idCheck_Add POINT . REMOVE LPAR RPAR

    ADD             shift and go to state 142
    REMOVE          shift and go to state 141


state 121

    (76) condition -> IF LPAR exp . RPAR cond_1 block else cond_2

    RPAR            shift and go to state 143


state 122

    (108) eat -> EAT LPAR ID . RPAR

    RPAR            shift and go to state 144


state 123

    (110) play -> PLAY LPAR ID . RPAR

    RPAR            shift and go to state 145


state 124

    (107) move -> MOVE LPAR ID . RPAR

    RPAR            shift and go to state 146


state 125

    (112) turnright -> TURNRIGHT LPAR RPAR .

    INT             reduce using rule 112 (turnright -> TURNRIGHT LPAR RPAR .)
    FLOAT           reduce using rule 112 (turnright -> TURNRIGHT LPAR RPAR .)
    BOOLEAN         reduce using rule 112 (turnright -> TURNRIGHT LPAR RPAR .)
    ID              reduce using rule 112 (turnright -> TURNRIGHT LPAR RPAR .)
    IF              reduce using rule 112 (turnright -> TURNRIGHT LPAR RPAR .)
    WHILE           reduce using rule 112 (turnright -> TURNRIGHT LPAR RPAR .)
    PRINT           reduce using rule 112 (turnright -> TURNRIGHT LPAR RPAR .)
    LIST            reduce using rule 112 (turnright -> TURNRIGHT LPAR RPAR .)
    MOVE            reduce using rule 112 (turnright -> TURNRIGHT LPAR RPAR .)
    EAT             reduce using rule 112 (turnright -> TURNRIGHT LPAR RPAR .)
    CLEAN           reduce using rule 112 (turnright -> TURNRIGHT LPAR RPAR .)
    PLAY            reduce using rule 112 (turnright -> TURNRIGHT LPAR RPAR .)
    TURNLEFT        reduce using rule 112 (turnright -> TURNRIGHT LPAR RPAR .)
    TURNRIGHT       reduce using rule 112 (turnright -> TURNRIGHT LPAR RPAR .)
    RETURN          reduce using rule 112 (turnright -> TURNRIGHT LPAR RPAR .)
    RCBRACKET       reduce using rule 112 (turnright -> TURNRIGHT LPAR RPAR .)


state 126

    (109) clean -> CLEAN LPAR ID . RPAR

    RPAR            shift and go to state 147


state 127

    (111) turnleft -> TURNLEFT LPAR RPAR .

    INT             reduce using rule 111 (turnleft -> TURNLEFT LPAR RPAR .)
    FLOAT           reduce using rule 111 (turnleft -> TURNLEFT LPAR RPAR .)
    BOOLEAN         reduce using rule 111 (turnleft -> TURNLEFT LPAR RPAR .)
    ID              reduce using rule 111 (turnleft -> TURNLEFT LPAR RPAR .)
    IF              reduce using rule 111 (turnleft -> TURNLEFT LPAR RPAR .)
    WHILE           reduce using rule 111 (turnleft -> TURNLEFT LPAR RPAR .)
    PRINT           reduce using rule 111 (turnleft -> TURNLEFT LPAR RPAR .)
    LIST            reduce using rule 111 (turnleft -> TURNLEFT LPAR RPAR .)
    MOVE            reduce using rule 111 (turnleft -> TURNLEFT LPAR RPAR .)
    EAT             reduce using rule 111 (turnleft -> TURNLEFT LPAR RPAR .)
    CLEAN           reduce using rule 111 (turnleft -> TURNLEFT LPAR RPAR .)
    PLAY            reduce using rule 111 (turnleft -> TURNLEFT LPAR RPAR .)
    TURNLEFT        reduce using rule 111 (turnleft -> TURNLEFT LPAR RPAR .)
    TURNRIGHT       reduce using rule 111 (turnleft -> TURNLEFT LPAR RPAR .)
    RETURN          reduce using rule 111 (turnleft -> TURNLEFT LPAR RPAR .)
    RCBRACKET       reduce using rule 111 (turnleft -> TURNLEFT LPAR RPAR .)


state 128

    (49) exp -> termino PLUS op_val exp .

    COMPARISON      reduce using rule 49 (exp -> termino PLUS op_val exp .)
    ID              reduce using rule 49 (exp -> termino PLUS op_val exp .)
    FUNC            reduce using rule 49 (exp -> termino PLUS op_val exp .)
    $end            reduce using rule 49 (exp -> termino PLUS op_val exp .)
    INT             reduce using rule 49 (exp -> termino PLUS op_val exp .)
    FLOAT           reduce using rule 49 (exp -> termino PLUS op_val exp .)
    BOOLEAN         reduce using rule 49 (exp -> termino PLUS op_val exp .)
    IF              reduce using rule 49 (exp -> termino PLUS op_val exp .)
    WHILE           reduce using rule 49 (exp -> termino PLUS op_val exp .)
    PRINT           reduce using rule 49 (exp -> termino PLUS op_val exp .)
    LIST            reduce using rule 49 (exp -> termino PLUS op_val exp .)
    MOVE            reduce using rule 49 (exp -> termino PLUS op_val exp .)
    EAT             reduce using rule 49 (exp -> termino PLUS op_val exp .)
    CLEAN           reduce using rule 49 (exp -> termino PLUS op_val exp .)
    PLAY            reduce using rule 49 (exp -> termino PLUS op_val exp .)
    TURNLEFT        reduce using rule 49 (exp -> termino PLUS op_val exp .)
    TURNRIGHT       reduce using rule 49 (exp -> termino PLUS op_val exp .)
    RETURN          reduce using rule 49 (exp -> termino PLUS op_val exp .)
    RCBRACKET       reduce using rule 49 (exp -> termino PLUS op_val exp .)
    RPAR            reduce using rule 49 (exp -> termino PLUS op_val exp .)
    PLUS            reduce using rule 49 (exp -> termino PLUS op_val exp .)
    LPAR            reduce using rule 49 (exp -> termino PLUS op_val exp .)
    MINUS           reduce using rule 49 (exp -> termino PLUS op_val exp .)
    NUMINT          reduce using rule 49 (exp -> termino PLUS op_val exp .)
    NUMFLOAT        reduce using rule 49 (exp -> termino PLUS op_val exp .)
    BOOLEANTYPE     reduce using rule 49 (exp -> termino PLUS op_val exp .)
    COMA            reduce using rule 49 (exp -> termino PLUS op_val exp .)


state 129

    (50) exp -> termino MINUS op_val exp .

    COMPARISON      reduce using rule 50 (exp -> termino MINUS op_val exp .)
    ID              reduce using rule 50 (exp -> termino MINUS op_val exp .)
    FUNC            reduce using rule 50 (exp -> termino MINUS op_val exp .)
    $end            reduce using rule 50 (exp -> termino MINUS op_val exp .)
    INT             reduce using rule 50 (exp -> termino MINUS op_val exp .)
    FLOAT           reduce using rule 50 (exp -> termino MINUS op_val exp .)
    BOOLEAN         reduce using rule 50 (exp -> termino MINUS op_val exp .)
    IF              reduce using rule 50 (exp -> termino MINUS op_val exp .)
    WHILE           reduce using rule 50 (exp -> termino MINUS op_val exp .)
    PRINT           reduce using rule 50 (exp -> termino MINUS op_val exp .)
    LIST            reduce using rule 50 (exp -> termino MINUS op_val exp .)
    MOVE            reduce using rule 50 (exp -> termino MINUS op_val exp .)
    EAT             reduce using rule 50 (exp -> termino MINUS op_val exp .)
    CLEAN           reduce using rule 50 (exp -> termino MINUS op_val exp .)
    PLAY            reduce using rule 50 (exp -> termino MINUS op_val exp .)
    TURNLEFT        reduce using rule 50 (exp -> termino MINUS op_val exp .)
    TURNRIGHT       reduce using rule 50 (exp -> termino MINUS op_val exp .)
    RETURN          reduce using rule 50 (exp -> termino MINUS op_val exp .)
    RCBRACKET       reduce using rule 50 (exp -> termino MINUS op_val exp .)
    RPAR            reduce using rule 50 (exp -> termino MINUS op_val exp .)
    PLUS            reduce using rule 50 (exp -> termino MINUS op_val exp .)
    LPAR            reduce using rule 50 (exp -> termino MINUS op_val exp .)
    MINUS           reduce using rule 50 (exp -> termino MINUS op_val exp .)
    NUMINT          reduce using rule 50 (exp -> termino MINUS op_val exp .)
    NUMFLOAT        reduce using rule 50 (exp -> termino MINUS op_val exp .)
    BOOLEANTYPE     reduce using rule 50 (exp -> termino MINUS op_val exp .)
    COMA            reduce using rule 50 (exp -> termino MINUS op_val exp .)


state 130

    (52) termino -> factor MULTIPLY op_val termino .

    PLUS            reduce using rule 52 (termino -> factor MULTIPLY op_val termino .)
    MINUS           reduce using rule 52 (termino -> factor MULTIPLY op_val termino .)
    RPAR            reduce using rule 52 (termino -> factor MULTIPLY op_val termino .)
    COMPARISON      reduce using rule 52 (termino -> factor MULTIPLY op_val termino .)
    LPAR            reduce using rule 52 (termino -> factor MULTIPLY op_val termino .)
    ID              reduce using rule 52 (termino -> factor MULTIPLY op_val termino .)
    NUMINT          reduce using rule 52 (termino -> factor MULTIPLY op_val termino .)
    NUMFLOAT        reduce using rule 52 (termino -> factor MULTIPLY op_val termino .)
    BOOLEANTYPE     reduce using rule 52 (termino -> factor MULTIPLY op_val termino .)
    FUNC            reduce using rule 52 (termino -> factor MULTIPLY op_val termino .)
    $end            reduce using rule 52 (termino -> factor MULTIPLY op_val termino .)
    INT             reduce using rule 52 (termino -> factor MULTIPLY op_val termino .)
    FLOAT           reduce using rule 52 (termino -> factor MULTIPLY op_val termino .)
    BOOLEAN         reduce using rule 52 (termino -> factor MULTIPLY op_val termino .)
    IF              reduce using rule 52 (termino -> factor MULTIPLY op_val termino .)
    WHILE           reduce using rule 52 (termino -> factor MULTIPLY op_val termino .)
    PRINT           reduce using rule 52 (termino -> factor MULTIPLY op_val termino .)
    LIST            reduce using rule 52 (termino -> factor MULTIPLY op_val termino .)
    MOVE            reduce using rule 52 (termino -> factor MULTIPLY op_val termino .)
    EAT             reduce using rule 52 (termino -> factor MULTIPLY op_val termino .)
    CLEAN           reduce using rule 52 (termino -> factor MULTIPLY op_val termino .)
    PLAY            reduce using rule 52 (termino -> factor MULTIPLY op_val termino .)
    TURNLEFT        reduce using rule 52 (termino -> factor MULTIPLY op_val termino .)
    TURNRIGHT       reduce using rule 52 (termino -> factor MULTIPLY op_val termino .)
    RETURN          reduce using rule 52 (termino -> factor MULTIPLY op_val termino .)
    RCBRACKET       reduce using rule 52 (termino -> factor MULTIPLY op_val termino .)
    COMA            reduce using rule 52 (termino -> factor MULTIPLY op_val termino .)


state 131

    (53) termino -> factor DIVIDE op_val termino .

    PLUS            reduce using rule 53 (termino -> factor DIVIDE op_val termino .)
    MINUS           reduce using rule 53 (termino -> factor DIVIDE op_val termino .)
    RPAR            reduce using rule 53 (termino -> factor DIVIDE op_val termino .)
    COMPARISON      reduce using rule 53 (termino -> factor DIVIDE op_val termino .)
    LPAR            reduce using rule 53 (termino -> factor DIVIDE op_val termino .)
    ID              reduce using rule 53 (termino -> factor DIVIDE op_val termino .)
    NUMINT          reduce using rule 53 (termino -> factor DIVIDE op_val termino .)
    NUMFLOAT        reduce using rule 53 (termino -> factor DIVIDE op_val termino .)
    BOOLEANTYPE     reduce using rule 53 (termino -> factor DIVIDE op_val termino .)
    FUNC            reduce using rule 53 (termino -> factor DIVIDE op_val termino .)
    $end            reduce using rule 53 (termino -> factor DIVIDE op_val termino .)
    INT             reduce using rule 53 (termino -> factor DIVIDE op_val termino .)
    FLOAT           reduce using rule 53 (termino -> factor DIVIDE op_val termino .)
    BOOLEAN         reduce using rule 53 (termino -> factor DIVIDE op_val termino .)
    IF              reduce using rule 53 (termino -> factor DIVIDE op_val termino .)
    WHILE           reduce using rule 53 (termino -> factor DIVIDE op_val termino .)
    PRINT           reduce using rule 53 (termino -> factor DIVIDE op_val termino .)
    LIST            reduce using rule 53 (termino -> factor DIVIDE op_val termino .)
    MOVE            reduce using rule 53 (termino -> factor DIVIDE op_val termino .)
    EAT             reduce using rule 53 (termino -> factor DIVIDE op_val termino .)
    CLEAN           reduce using rule 53 (termino -> factor DIVIDE op_val termino .)
    PLAY            reduce using rule 53 (termino -> factor DIVIDE op_val termino .)
    TURNLEFT        reduce using rule 53 (termino -> factor DIVIDE op_val termino .)
    TURNRIGHT       reduce using rule 53 (termino -> factor DIVIDE op_val termino .)
    RETURN          reduce using rule 53 (termino -> factor DIVIDE op_val termino .)
    RCBRACKET       reduce using rule 53 (termino -> factor DIVIDE op_val termino .)
    COMA            reduce using rule 53 (termino -> factor DIVIDE op_val termino .)


state 132

    (98) call -> ID id_call LPAR par_call . RPAR par_call2
    (99) call -> ID id_call LPAR par_call . params RPAR par_call2
    (103) params -> . expression COMA params
    (104) params -> . ID COMA params
    (105) params -> . expression
    (106) params -> . ID
    (46) expression -> . exp
    (47) expression -> . exp COMPARISON op_val expression
    (48) exp -> . termino
    (49) exp -> . termino PLUS op_val exp
    (50) exp -> . termino MINUS op_val exp
    (51) termino -> . factor
    (52) termino -> . factor MULTIPLY op_val termino
    (53) termino -> . factor DIVIDE op_val termino
    (56) factor -> . LPAR expression RPAR
    (57) factor -> . MINUS varcte
    (58) factor -> . varcte termino_val
    (59) varcte -> . ID
    (60) varcte -> . NUMINT
    (61) varcte -> . NUMFLOAT
    (62) varcte -> . BOOLEANTYPE

    RPAR            shift and go to state 148
    ID              shift and go to state 150
    LPAR            shift and go to state 39
    MINUS           shift and go to state 42
    NUMINT          shift and go to state 47
    NUMFLOAT        shift and go to state 41
    BOOLEANTYPE     shift and go to state 49

    varcte                         shift and go to state 43
    params                         shift and go to state 149
    termino                        shift and go to state 40
    exp                            shift and go to state 48
    factor                         shift and go to state 45
    expression                     shift and go to state 151

state 133

    (47) expression -> exp COMPARISON op_val expression .

    COMA            reduce using rule 47 (expression -> exp COMPARISON op_val expression .)
    RPAR            reduce using rule 47 (expression -> exp COMPARISON op_val expression .)
    PLUS            reduce using rule 47 (expression -> exp COMPARISON op_val expression .)
    LPAR            reduce using rule 47 (expression -> exp COMPARISON op_val expression .)
    MINUS           reduce using rule 47 (expression -> exp COMPARISON op_val expression .)
    ID              reduce using rule 47 (expression -> exp COMPARISON op_val expression .)
    NUMINT          reduce using rule 47 (expression -> exp COMPARISON op_val expression .)
    NUMFLOAT        reduce using rule 47 (expression -> exp COMPARISON op_val expression .)
    BOOLEANTYPE     reduce using rule 47 (expression -> exp COMPARISON op_val expression .)
    FUNC            reduce using rule 47 (expression -> exp COMPARISON op_val expression .)
    $end            reduce using rule 47 (expression -> exp COMPARISON op_val expression .)
    INT             reduce using rule 47 (expression -> exp COMPARISON op_val expression .)
    FLOAT           reduce using rule 47 (expression -> exp COMPARISON op_val expression .)
    BOOLEAN         reduce using rule 47 (expression -> exp COMPARISON op_val expression .)
    IF              reduce using rule 47 (expression -> exp COMPARISON op_val expression .)
    WHILE           reduce using rule 47 (expression -> exp COMPARISON op_val expression .)
    PRINT           reduce using rule 47 (expression -> exp COMPARISON op_val expression .)
    LIST            reduce using rule 47 (expression -> exp COMPARISON op_val expression .)
    MOVE            reduce using rule 47 (expression -> exp COMPARISON op_val expression .)
    EAT             reduce using rule 47 (expression -> exp COMPARISON op_val expression .)
    CLEAN           reduce using rule 47 (expression -> exp COMPARISON op_val expression .)
    PLAY            reduce using rule 47 (expression -> exp COMPARISON op_val expression .)
    TURNLEFT        reduce using rule 47 (expression -> exp COMPARISON op_val expression .)
    TURNRIGHT       reduce using rule 47 (expression -> exp COMPARISON op_val expression .)
    RETURN          reduce using rule 47 (expression -> exp COMPARISON op_val expression .)
    RCBRACKET       reduce using rule 47 (expression -> exp COMPARISON op_val expression .)


state 134

    (36) return -> RETURN LPAR par_call expression . RPAR par_call2

    RPAR            shift and go to state 152


state 135

    (72) cycle -> WHILE cycle_1 LPAR exp . RPAR cycle_2 block cycle_3

    RPAR            shift and go to state 153


state 136

    (63) print -> PRINT LPAR par_call printx . expCheck RPAR
    (70) expCheck -> . expression
    (71) expCheck -> . empty
    (46) expression -> . exp
    (47) expression -> . exp COMPARISON op_val expression
    (113) empty -> .
    (48) exp -> . termino
    (49) exp -> . termino PLUS op_val exp
    (50) exp -> . termino MINUS op_val exp
    (51) termino -> . factor
    (52) termino -> . factor MULTIPLY op_val termino
    (53) termino -> . factor DIVIDE op_val termino
    (56) factor -> . LPAR expression RPAR
    (57) factor -> . MINUS varcte
    (58) factor -> . varcte termino_val
    (59) varcte -> . ID
    (60) varcte -> . NUMINT
    (61) varcte -> . NUMFLOAT
    (62) varcte -> . BOOLEANTYPE

    RPAR            reduce using rule 113 (empty -> .)
    LPAR            shift and go to state 39
    MINUS           shift and go to state 42
    ID              shift and go to state 83
    NUMINT          shift and go to state 47
    NUMFLOAT        shift and go to state 41
    BOOLEANTYPE     shift and go to state 49

    varcte                         shift and go to state 43
    expCheck                       shift and go to state 155
    termino                        shift and go to state 40
    exp                            shift and go to state 48
    factor                         shift and go to state 45
    expression                     shift and go to state 156
    empty                          shift and go to state 154

state 137

    (66) printx -> call .
    (69) printx -> call . PLUS op_val printx

    LPAR            reduce using rule 66 (printx -> call .)
    MINUS           reduce using rule 66 (printx -> call .)
    ID              reduce using rule 66 (printx -> call .)
    NUMINT          reduce using rule 66 (printx -> call .)
    NUMFLOAT        reduce using rule 66 (printx -> call .)
    BOOLEANTYPE     reduce using rule 66 (printx -> call .)
    RPAR            reduce using rule 66 (printx -> call .)
    PLUS            shift and go to state 157


state 138

    (65) printx -> ID . id_val
    (68) printx -> ID . id_val PLUS op_val printx
    (98) call -> ID . id_call LPAR par_call RPAR par_call2
    (99) call -> ID . id_call LPAR par_call params RPAR par_call2
    (59) varcte -> ID .
    (44) id_val -> .
    (100) id_call -> .

  ! reduce/reduce conflict for PLUS resolved using rule 44 (id_val -> .)
  ! reduce/reduce conflict for LPAR resolved using rule 44 (id_val -> .)
  ! reduce/reduce conflict for MINUS resolved using rule 44 (id_val -> .)
  ! reduce/reduce conflict for ID resolved using rule 44 (id_val -> .)
  ! reduce/reduce conflict for NUMINT resolved using rule 44 (id_val -> .)
  ! reduce/reduce conflict for NUMFLOAT resolved using rule 44 (id_val -> .)
  ! reduce/reduce conflict for BOOLEANTYPE resolved using rule 44 (id_val -> .)
  ! reduce/reduce conflict for RPAR resolved using rule 44 (id_val -> .)
  ! reduce/reduce conflict for LPAR resolved using rule 44 (id_val -> .)
    MULTIPLY        reduce using rule 59 (varcte -> ID .)
    DIVIDE          reduce using rule 59 (varcte -> ID .)
    COMPARISON      reduce using rule 59 (varcte -> ID .)
    PLUS            reduce using rule 44 (id_val -> .)
    LPAR            reduce using rule 44 (id_val -> .)
    MINUS           reduce using rule 44 (id_val -> .)
    ID              reduce using rule 44 (id_val -> .)
    NUMINT          reduce using rule 44 (id_val -> .)
    NUMFLOAT        reduce using rule 44 (id_val -> .)
    BOOLEANTYPE     reduce using rule 44 (id_val -> .)
    RPAR            reduce using rule 44 (id_val -> .)

  ! PLUS            [ reduce using rule 59 (varcte -> ID .) ]
  ! MINUS           [ reduce using rule 59 (varcte -> ID .) ]
  ! LPAR            [ reduce using rule 59 (varcte -> ID .) ]
  ! ID              [ reduce using rule 59 (varcte -> ID .) ]
  ! NUMINT          [ reduce using rule 59 (varcte -> ID .) ]
  ! NUMFLOAT        [ reduce using rule 59 (varcte -> ID .) ]
  ! BOOLEANTYPE     [ reduce using rule 59 (varcte -> ID .) ]
  ! RPAR            [ reduce using rule 59 (varcte -> ID .) ]
  ! LPAR            [ reduce using rule 100 (id_call -> .) ]

    id_val                         shift and go to state 158
    id_call                        shift and go to state 91

state 139

    (64) printx -> expression .
    (67) printx -> expression . PLUS op_val printx

    LPAR            reduce using rule 64 (printx -> expression .)
    MINUS           reduce using rule 64 (printx -> expression .)
    ID              reduce using rule 64 (printx -> expression .)
    NUMINT          reduce using rule 64 (printx -> expression .)
    NUMFLOAT        reduce using rule 64 (printx -> expression .)
    BOOLEANTYPE     reduce using rule 64 (printx -> expression .)
    RPAR            reduce using rule 64 (printx -> expression .)
    PLUS            shift and go to state 159


state 140

    (82) list -> LIST idCheck_List EQUAL LBRACKET . listx RBRACKET
    (83) listx -> . ID id_param
    (84) listx -> . ID id_param COMA listx
    (85) listx -> . NUMINT id_param
    (86) listx -> . NUMINT id_param COMA listx
    (87) listx -> . NUMFLOAT id_param
    (88) listx -> . NUMFLOAT id_param COMA listx

    ID              shift and go to state 163
    NUMINT          shift and go to state 161
    NUMFLOAT        shift and go to state 162

    listx                          shift and go to state 160

state 141

    (97) remove -> ID idCheck_Add POINT REMOVE . LPAR RPAR

    LPAR            shift and go to state 164


state 142

    (95) add -> ID idCheck_Add POINT ADD . LPAR listx_add RPAR

    LPAR            shift and go to state 165


state 143

    (76) condition -> IF LPAR exp RPAR . cond_1 block else cond_2
    (79) cond_1 -> .

    LCBRACKET       reduce using rule 79 (cond_1 -> .)

    cond_1                         shift and go to state 166

state 144

    (108) eat -> EAT LPAR ID RPAR .

    INT             reduce using rule 108 (eat -> EAT LPAR ID RPAR .)
    FLOAT           reduce using rule 108 (eat -> EAT LPAR ID RPAR .)
    BOOLEAN         reduce using rule 108 (eat -> EAT LPAR ID RPAR .)
    ID              reduce using rule 108 (eat -> EAT LPAR ID RPAR .)
    IF              reduce using rule 108 (eat -> EAT LPAR ID RPAR .)
    WHILE           reduce using rule 108 (eat -> EAT LPAR ID RPAR .)
    PRINT           reduce using rule 108 (eat -> EAT LPAR ID RPAR .)
    LIST            reduce using rule 108 (eat -> EAT LPAR ID RPAR .)
    MOVE            reduce using rule 108 (eat -> EAT LPAR ID RPAR .)
    EAT             reduce using rule 108 (eat -> EAT LPAR ID RPAR .)
    CLEAN           reduce using rule 108 (eat -> EAT LPAR ID RPAR .)
    PLAY            reduce using rule 108 (eat -> EAT LPAR ID RPAR .)
    TURNLEFT        reduce using rule 108 (eat -> EAT LPAR ID RPAR .)
    TURNRIGHT       reduce using rule 108 (eat -> EAT LPAR ID RPAR .)
    RETURN          reduce using rule 108 (eat -> EAT LPAR ID RPAR .)
    RCBRACKET       reduce using rule 108 (eat -> EAT LPAR ID RPAR .)


state 145

    (110) play -> PLAY LPAR ID RPAR .

    INT             reduce using rule 110 (play -> PLAY LPAR ID RPAR .)
    FLOAT           reduce using rule 110 (play -> PLAY LPAR ID RPAR .)
    BOOLEAN         reduce using rule 110 (play -> PLAY LPAR ID RPAR .)
    ID              reduce using rule 110 (play -> PLAY LPAR ID RPAR .)
    IF              reduce using rule 110 (play -> PLAY LPAR ID RPAR .)
    WHILE           reduce using rule 110 (play -> PLAY LPAR ID RPAR .)
    PRINT           reduce using rule 110 (play -> PLAY LPAR ID RPAR .)
    LIST            reduce using rule 110 (play -> PLAY LPAR ID RPAR .)
    MOVE            reduce using rule 110 (play -> PLAY LPAR ID RPAR .)
    EAT             reduce using rule 110 (play -> PLAY LPAR ID RPAR .)
    CLEAN           reduce using rule 110 (play -> PLAY LPAR ID RPAR .)
    PLAY            reduce using rule 110 (play -> PLAY LPAR ID RPAR .)
    TURNLEFT        reduce using rule 110 (play -> PLAY LPAR ID RPAR .)
    TURNRIGHT       reduce using rule 110 (play -> PLAY LPAR ID RPAR .)
    RETURN          reduce using rule 110 (play -> PLAY LPAR ID RPAR .)
    RCBRACKET       reduce using rule 110 (play -> PLAY LPAR ID RPAR .)


state 146

    (107) move -> MOVE LPAR ID RPAR .

    INT             reduce using rule 107 (move -> MOVE LPAR ID RPAR .)
    FLOAT           reduce using rule 107 (move -> MOVE LPAR ID RPAR .)
    BOOLEAN         reduce using rule 107 (move -> MOVE LPAR ID RPAR .)
    ID              reduce using rule 107 (move -> MOVE LPAR ID RPAR .)
    IF              reduce using rule 107 (move -> MOVE LPAR ID RPAR .)
    WHILE           reduce using rule 107 (move -> MOVE LPAR ID RPAR .)
    PRINT           reduce using rule 107 (move -> MOVE LPAR ID RPAR .)
    LIST            reduce using rule 107 (move -> MOVE LPAR ID RPAR .)
    MOVE            reduce using rule 107 (move -> MOVE LPAR ID RPAR .)
    EAT             reduce using rule 107 (move -> MOVE LPAR ID RPAR .)
    CLEAN           reduce using rule 107 (move -> MOVE LPAR ID RPAR .)
    PLAY            reduce using rule 107 (move -> MOVE LPAR ID RPAR .)
    TURNLEFT        reduce using rule 107 (move -> MOVE LPAR ID RPAR .)
    TURNRIGHT       reduce using rule 107 (move -> MOVE LPAR ID RPAR .)
    RETURN          reduce using rule 107 (move -> MOVE LPAR ID RPAR .)
    RCBRACKET       reduce using rule 107 (move -> MOVE LPAR ID RPAR .)


state 147

    (109) clean -> CLEAN LPAR ID RPAR .

    INT             reduce using rule 109 (clean -> CLEAN LPAR ID RPAR .)
    FLOAT           reduce using rule 109 (clean -> CLEAN LPAR ID RPAR .)
    BOOLEAN         reduce using rule 109 (clean -> CLEAN LPAR ID RPAR .)
    ID              reduce using rule 109 (clean -> CLEAN LPAR ID RPAR .)
    IF              reduce using rule 109 (clean -> CLEAN LPAR ID RPAR .)
    WHILE           reduce using rule 109 (clean -> CLEAN LPAR ID RPAR .)
    PRINT           reduce using rule 109 (clean -> CLEAN LPAR ID RPAR .)
    LIST            reduce using rule 109 (clean -> CLEAN LPAR ID RPAR .)
    MOVE            reduce using rule 109 (clean -> CLEAN LPAR ID RPAR .)
    EAT             reduce using rule 109 (clean -> CLEAN LPAR ID RPAR .)
    CLEAN           reduce using rule 109 (clean -> CLEAN LPAR ID RPAR .)
    PLAY            reduce using rule 109 (clean -> CLEAN LPAR ID RPAR .)
    TURNLEFT        reduce using rule 109 (clean -> CLEAN LPAR ID RPAR .)
    TURNRIGHT       reduce using rule 109 (clean -> CLEAN LPAR ID RPAR .)
    RETURN          reduce using rule 109 (clean -> CLEAN LPAR ID RPAR .)
    RCBRACKET       reduce using rule 109 (clean -> CLEAN LPAR ID RPAR .)


state 148

    (98) call -> ID id_call LPAR par_call RPAR . par_call2
    (102) par_call2 -> .

    ID              reduce using rule 102 (par_call2 -> .)
    FUNC            reduce using rule 102 (par_call2 -> .)
    $end            reduce using rule 102 (par_call2 -> .)
    INT             reduce using rule 102 (par_call2 -> .)
    FLOAT           reduce using rule 102 (par_call2 -> .)
    BOOLEAN         reduce using rule 102 (par_call2 -> .)
    IF              reduce using rule 102 (par_call2 -> .)
    WHILE           reduce using rule 102 (par_call2 -> .)
    PRINT           reduce using rule 102 (par_call2 -> .)
    LIST            reduce using rule 102 (par_call2 -> .)
    MOVE            reduce using rule 102 (par_call2 -> .)
    EAT             reduce using rule 102 (par_call2 -> .)
    CLEAN           reduce using rule 102 (par_call2 -> .)
    PLAY            reduce using rule 102 (par_call2 -> .)
    TURNLEFT        reduce using rule 102 (par_call2 -> .)
    TURNRIGHT       reduce using rule 102 (par_call2 -> .)
    RETURN          reduce using rule 102 (par_call2 -> .)
    RCBRACKET       reduce using rule 102 (par_call2 -> .)
    PLUS            reduce using rule 102 (par_call2 -> .)
    LPAR            reduce using rule 102 (par_call2 -> .)
    MINUS           reduce using rule 102 (par_call2 -> .)
    NUMINT          reduce using rule 102 (par_call2 -> .)
    NUMFLOAT        reduce using rule 102 (par_call2 -> .)
    BOOLEANTYPE     reduce using rule 102 (par_call2 -> .)
    RPAR            reduce using rule 102 (par_call2 -> .)

    par_call2                      shift and go to state 167

state 149

    (99) call -> ID id_call LPAR par_call params . RPAR par_call2

    RPAR            shift and go to state 168


state 150

    (104) params -> ID . COMA params
    (106) params -> ID .
    (59) varcte -> ID .

  ! shift/reduce conflict for COMA resolved as shift
  ! reduce/reduce conflict for RPAR resolved using rule 59 (varcte -> ID .)
    COMA            shift and go to state 169
    MULTIPLY        reduce using rule 59 (varcte -> ID .)
    DIVIDE          reduce using rule 59 (varcte -> ID .)
    PLUS            reduce using rule 59 (varcte -> ID .)
    MINUS           reduce using rule 59 (varcte -> ID .)
    COMPARISON      reduce using rule 59 (varcte -> ID .)
    RPAR            reduce using rule 59 (varcte -> ID .)

  ! RPAR            [ reduce using rule 106 (params -> ID .) ]
  ! COMA            [ reduce using rule 59 (varcte -> ID .) ]


state 151

    (103) params -> expression . COMA params
    (105) params -> expression .

    COMA            shift and go to state 170
    RPAR            reduce using rule 105 (params -> expression .)


state 152

    (36) return -> RETURN LPAR par_call expression RPAR . par_call2
    (102) par_call2 -> .

    INT             reduce using rule 102 (par_call2 -> .)
    FLOAT           reduce using rule 102 (par_call2 -> .)
    BOOLEAN         reduce using rule 102 (par_call2 -> .)
    ID              reduce using rule 102 (par_call2 -> .)
    IF              reduce using rule 102 (par_call2 -> .)
    WHILE           reduce using rule 102 (par_call2 -> .)
    PRINT           reduce using rule 102 (par_call2 -> .)
    LIST            reduce using rule 102 (par_call2 -> .)
    MOVE            reduce using rule 102 (par_call2 -> .)
    EAT             reduce using rule 102 (par_call2 -> .)
    CLEAN           reduce using rule 102 (par_call2 -> .)
    PLAY            reduce using rule 102 (par_call2 -> .)
    TURNLEFT        reduce using rule 102 (par_call2 -> .)
    TURNRIGHT       reduce using rule 102 (par_call2 -> .)
    RETURN          reduce using rule 102 (par_call2 -> .)
    RCBRACKET       reduce using rule 102 (par_call2 -> .)

    par_call2                      shift and go to state 171

state 153

    (72) cycle -> WHILE cycle_1 LPAR exp RPAR . cycle_2 block cycle_3
    (74) cycle_2 -> .

    LCBRACKET       reduce using rule 74 (cycle_2 -> .)

    cycle_2                        shift and go to state 172

state 154

    (71) expCheck -> empty .

    RPAR            reduce using rule 71 (expCheck -> empty .)


state 155

    (63) print -> PRINT LPAR par_call printx expCheck . RPAR

    RPAR            shift and go to state 173


state 156

    (70) expCheck -> expression .

    RPAR            reduce using rule 70 (expCheck -> expression .)


state 157

    (69) printx -> call PLUS . op_val printx
    (55) op_val -> .

    ID              reduce using rule 55 (op_val -> .)
    LPAR            reduce using rule 55 (op_val -> .)
    MINUS           reduce using rule 55 (op_val -> .)
    NUMINT          reduce using rule 55 (op_val -> .)
    NUMFLOAT        reduce using rule 55 (op_val -> .)
    BOOLEANTYPE     reduce using rule 55 (op_val -> .)

    op_val                         shift and go to state 174

state 158

    (65) printx -> ID id_val .
    (68) printx -> ID id_val . PLUS op_val printx

    LPAR            reduce using rule 65 (printx -> ID id_val .)
    MINUS           reduce using rule 65 (printx -> ID id_val .)
    ID              reduce using rule 65 (printx -> ID id_val .)
    NUMINT          reduce using rule 65 (printx -> ID id_val .)
    NUMFLOAT        reduce using rule 65 (printx -> ID id_val .)
    BOOLEANTYPE     reduce using rule 65 (printx -> ID id_val .)
    RPAR            reduce using rule 65 (printx -> ID id_val .)
    PLUS            shift and go to state 175


state 159

    (67) printx -> expression PLUS . op_val printx
    (55) op_val -> .

    ID              reduce using rule 55 (op_val -> .)
    LPAR            reduce using rule 55 (op_val -> .)
    MINUS           reduce using rule 55 (op_val -> .)
    NUMINT          reduce using rule 55 (op_val -> .)
    NUMFLOAT        reduce using rule 55 (op_val -> .)
    BOOLEANTYPE     reduce using rule 55 (op_val -> .)

    op_val                         shift and go to state 176

state 160

    (82) list -> LIST idCheck_List EQUAL LBRACKET listx . RBRACKET

    RBRACKET        shift and go to state 177


state 161

    (85) listx -> NUMINT . id_param
    (86) listx -> NUMINT . id_param COMA listx
    (90) id_param -> .

    COMA            reduce using rule 90 (id_param -> .)
    RBRACKET        reduce using rule 90 (id_param -> .)

    id_param                       shift and go to state 178

state 162

    (87) listx -> NUMFLOAT . id_param
    (88) listx -> NUMFLOAT . id_param COMA listx
    (90) id_param -> .

    COMA            reduce using rule 90 (id_param -> .)
    RBRACKET        reduce using rule 90 (id_param -> .)

    id_param                       shift and go to state 179

state 163

    (83) listx -> ID . id_param
    (84) listx -> ID . id_param COMA listx
    (90) id_param -> .

    COMA            reduce using rule 90 (id_param -> .)
    RBRACKET        reduce using rule 90 (id_param -> .)

    id_param                       shift and go to state 180

state 164

    (97) remove -> ID idCheck_Add POINT REMOVE LPAR . RPAR

    RPAR            shift and go to state 181


state 165

    (95) add -> ID idCheck_Add POINT ADD LPAR . listx_add RPAR
    (92) listx_add -> . ID id_param2
    (93) listx_add -> . NUMINT id_param2
    (94) listx_add -> . NUMFLOAT id_param2

    ID              shift and go to state 183
    NUMINT          shift and go to state 182
    NUMFLOAT        shift and go to state 184

    listx_add                      shift and go to state 185

state 166

    (76) condition -> IF LPAR exp RPAR cond_1 . block else cond_2
    (16) block -> . LCBRACKET blockx RCBRACKET

    LCBRACKET       shift and go to state 37

    block                          shift and go to state 186

state 167

    (98) call -> ID id_call LPAR par_call RPAR par_call2 .

    PLUS            reduce using rule 98 (call -> ID id_call LPAR par_call RPAR par_call2 .)
    LPAR            reduce using rule 98 (call -> ID id_call LPAR par_call RPAR par_call2 .)
    MINUS           reduce using rule 98 (call -> ID id_call LPAR par_call RPAR par_call2 .)
    ID              reduce using rule 98 (call -> ID id_call LPAR par_call RPAR par_call2 .)
    NUMINT          reduce using rule 98 (call -> ID id_call LPAR par_call RPAR par_call2 .)
    NUMFLOAT        reduce using rule 98 (call -> ID id_call LPAR par_call RPAR par_call2 .)
    BOOLEANTYPE     reduce using rule 98 (call -> ID id_call LPAR par_call RPAR par_call2 .)
    RPAR            reduce using rule 98 (call -> ID id_call LPAR par_call RPAR par_call2 .)
    INT             reduce using rule 98 (call -> ID id_call LPAR par_call RPAR par_call2 .)
    FLOAT           reduce using rule 98 (call -> ID id_call LPAR par_call RPAR par_call2 .)
    BOOLEAN         reduce using rule 98 (call -> ID id_call LPAR par_call RPAR par_call2 .)
    IF              reduce using rule 98 (call -> ID id_call LPAR par_call RPAR par_call2 .)
    WHILE           reduce using rule 98 (call -> ID id_call LPAR par_call RPAR par_call2 .)
    PRINT           reduce using rule 98 (call -> ID id_call LPAR par_call RPAR par_call2 .)
    LIST            reduce using rule 98 (call -> ID id_call LPAR par_call RPAR par_call2 .)
    MOVE            reduce using rule 98 (call -> ID id_call LPAR par_call RPAR par_call2 .)
    EAT             reduce using rule 98 (call -> ID id_call LPAR par_call RPAR par_call2 .)
    CLEAN           reduce using rule 98 (call -> ID id_call LPAR par_call RPAR par_call2 .)
    PLAY            reduce using rule 98 (call -> ID id_call LPAR par_call RPAR par_call2 .)
    TURNLEFT        reduce using rule 98 (call -> ID id_call LPAR par_call RPAR par_call2 .)
    TURNRIGHT       reduce using rule 98 (call -> ID id_call LPAR par_call RPAR par_call2 .)
    RETURN          reduce using rule 98 (call -> ID id_call LPAR par_call RPAR par_call2 .)
    RCBRACKET       reduce using rule 98 (call -> ID id_call LPAR par_call RPAR par_call2 .)
    FUNC            reduce using rule 98 (call -> ID id_call LPAR par_call RPAR par_call2 .)
    $end            reduce using rule 98 (call -> ID id_call LPAR par_call RPAR par_call2 .)


state 168

    (99) call -> ID id_call LPAR par_call params RPAR . par_call2
    (102) par_call2 -> .

    ID              reduce using rule 102 (par_call2 -> .)
    FUNC            reduce using rule 102 (par_call2 -> .)
    $end            reduce using rule 102 (par_call2 -> .)
    INT             reduce using rule 102 (par_call2 -> .)
    FLOAT           reduce using rule 102 (par_call2 -> .)
    BOOLEAN         reduce using rule 102 (par_call2 -> .)
    IF              reduce using rule 102 (par_call2 -> .)
    WHILE           reduce using rule 102 (par_call2 -> .)
    PRINT           reduce using rule 102 (par_call2 -> .)
    LIST            reduce using rule 102 (par_call2 -> .)
    MOVE            reduce using rule 102 (par_call2 -> .)
    EAT             reduce using rule 102 (par_call2 -> .)
    CLEAN           reduce using rule 102 (par_call2 -> .)
    PLAY            reduce using rule 102 (par_call2 -> .)
    TURNLEFT        reduce using rule 102 (par_call2 -> .)
    TURNRIGHT       reduce using rule 102 (par_call2 -> .)
    RETURN          reduce using rule 102 (par_call2 -> .)
    RCBRACKET       reduce using rule 102 (par_call2 -> .)
    PLUS            reduce using rule 102 (par_call2 -> .)
    LPAR            reduce using rule 102 (par_call2 -> .)
    MINUS           reduce using rule 102 (par_call2 -> .)
    NUMINT          reduce using rule 102 (par_call2 -> .)
    NUMFLOAT        reduce using rule 102 (par_call2 -> .)
    BOOLEANTYPE     reduce using rule 102 (par_call2 -> .)
    RPAR            reduce using rule 102 (par_call2 -> .)

    par_call2                      shift and go to state 187

state 169

    (104) params -> ID COMA . params
    (103) params -> . expression COMA params
    (104) params -> . ID COMA params
    (105) params -> . expression
    (106) params -> . ID
    (46) expression -> . exp
    (47) expression -> . exp COMPARISON op_val expression
    (48) exp -> . termino
    (49) exp -> . termino PLUS op_val exp
    (50) exp -> . termino MINUS op_val exp
    (51) termino -> . factor
    (52) termino -> . factor MULTIPLY op_val termino
    (53) termino -> . factor DIVIDE op_val termino
    (56) factor -> . LPAR expression RPAR
    (57) factor -> . MINUS varcte
    (58) factor -> . varcte termino_val
    (59) varcte -> . ID
    (60) varcte -> . NUMINT
    (61) varcte -> . NUMFLOAT
    (62) varcte -> . BOOLEANTYPE

    ID              shift and go to state 150
    LPAR            shift and go to state 39
    MINUS           shift and go to state 42
    NUMINT          shift and go to state 47
    NUMFLOAT        shift and go to state 41
    BOOLEANTYPE     shift and go to state 49

    varcte                         shift and go to state 43
    params                         shift and go to state 188
    termino                        shift and go to state 40
    exp                            shift and go to state 48
    factor                         shift and go to state 45
    expression                     shift and go to state 151

state 170

    (103) params -> expression COMA . params
    (103) params -> . expression COMA params
    (104) params -> . ID COMA params
    (105) params -> . expression
    (106) params -> . ID
    (46) expression -> . exp
    (47) expression -> . exp COMPARISON op_val expression
    (48) exp -> . termino
    (49) exp -> . termino PLUS op_val exp
    (50) exp -> . termino MINUS op_val exp
    (51) termino -> . factor
    (52) termino -> . factor MULTIPLY op_val termino
    (53) termino -> . factor DIVIDE op_val termino
    (56) factor -> . LPAR expression RPAR
    (57) factor -> . MINUS varcte
    (58) factor -> . varcte termino_val
    (59) varcte -> . ID
    (60) varcte -> . NUMINT
    (61) varcte -> . NUMFLOAT
    (62) varcte -> . BOOLEANTYPE

    ID              shift and go to state 150
    LPAR            shift and go to state 39
    MINUS           shift and go to state 42
    NUMINT          shift and go to state 47
    NUMFLOAT        shift and go to state 41
    BOOLEANTYPE     shift and go to state 49

    varcte                         shift and go to state 43
    params                         shift and go to state 189
    termino                        shift and go to state 40
    exp                            shift and go to state 48
    factor                         shift and go to state 45
    expression                     shift and go to state 151

state 171

    (36) return -> RETURN LPAR par_call expression RPAR par_call2 .

    INT             reduce using rule 36 (return -> RETURN LPAR par_call expression RPAR par_call2 .)
    FLOAT           reduce using rule 36 (return -> RETURN LPAR par_call expression RPAR par_call2 .)
    BOOLEAN         reduce using rule 36 (return -> RETURN LPAR par_call expression RPAR par_call2 .)
    ID              reduce using rule 36 (return -> RETURN LPAR par_call expression RPAR par_call2 .)
    IF              reduce using rule 36 (return -> RETURN LPAR par_call expression RPAR par_call2 .)
    WHILE           reduce using rule 36 (return -> RETURN LPAR par_call expression RPAR par_call2 .)
    PRINT           reduce using rule 36 (return -> RETURN LPAR par_call expression RPAR par_call2 .)
    LIST            reduce using rule 36 (return -> RETURN LPAR par_call expression RPAR par_call2 .)
    MOVE            reduce using rule 36 (return -> RETURN LPAR par_call expression RPAR par_call2 .)
    EAT             reduce using rule 36 (return -> RETURN LPAR par_call expression RPAR par_call2 .)
    CLEAN           reduce using rule 36 (return -> RETURN LPAR par_call expression RPAR par_call2 .)
    PLAY            reduce using rule 36 (return -> RETURN LPAR par_call expression RPAR par_call2 .)
    TURNLEFT        reduce using rule 36 (return -> RETURN LPAR par_call expression RPAR par_call2 .)
    TURNRIGHT       reduce using rule 36 (return -> RETURN LPAR par_call expression RPAR par_call2 .)
    RETURN          reduce using rule 36 (return -> RETURN LPAR par_call expression RPAR par_call2 .)
    RCBRACKET       reduce using rule 36 (return -> RETURN LPAR par_call expression RPAR par_call2 .)


state 172

    (72) cycle -> WHILE cycle_1 LPAR exp RPAR cycle_2 . block cycle_3
    (16) block -> . LCBRACKET blockx RCBRACKET

    LCBRACKET       shift and go to state 37

    block                          shift and go to state 190

state 173

    (63) print -> PRINT LPAR par_call printx expCheck RPAR .

    INT             reduce using rule 63 (print -> PRINT LPAR par_call printx expCheck RPAR .)
    FLOAT           reduce using rule 63 (print -> PRINT LPAR par_call printx expCheck RPAR .)
    BOOLEAN         reduce using rule 63 (print -> PRINT LPAR par_call printx expCheck RPAR .)
    ID              reduce using rule 63 (print -> PRINT LPAR par_call printx expCheck RPAR .)
    IF              reduce using rule 63 (print -> PRINT LPAR par_call printx expCheck RPAR .)
    WHILE           reduce using rule 63 (print -> PRINT LPAR par_call printx expCheck RPAR .)
    PRINT           reduce using rule 63 (print -> PRINT LPAR par_call printx expCheck RPAR .)
    LIST            reduce using rule 63 (print -> PRINT LPAR par_call printx expCheck RPAR .)
    MOVE            reduce using rule 63 (print -> PRINT LPAR par_call printx expCheck RPAR .)
    EAT             reduce using rule 63 (print -> PRINT LPAR par_call printx expCheck RPAR .)
    CLEAN           reduce using rule 63 (print -> PRINT LPAR par_call printx expCheck RPAR .)
    PLAY            reduce using rule 63 (print -> PRINT LPAR par_call printx expCheck RPAR .)
    TURNLEFT        reduce using rule 63 (print -> PRINT LPAR par_call printx expCheck RPAR .)
    TURNRIGHT       reduce using rule 63 (print -> PRINT LPAR par_call printx expCheck RPAR .)
    RETURN          reduce using rule 63 (print -> PRINT LPAR par_call printx expCheck RPAR .)
    RCBRACKET       reduce using rule 63 (print -> PRINT LPAR par_call printx expCheck RPAR .)


state 174

    (69) printx -> call PLUS op_val . printx
    (64) printx -> . expression
    (65) printx -> . ID id_val
    (66) printx -> . call
    (67) printx -> . expression PLUS op_val printx
    (68) printx -> . ID id_val PLUS op_val printx
    (69) printx -> . call PLUS op_val printx
    (46) expression -> . exp
    (47) expression -> . exp COMPARISON op_val expression
    (98) call -> . ID id_call LPAR par_call RPAR par_call2
    (99) call -> . ID id_call LPAR par_call params RPAR par_call2
    (48) exp -> . termino
    (49) exp -> . termino PLUS op_val exp
    (50) exp -> . termino MINUS op_val exp
    (51) termino -> . factor
    (52) termino -> . factor MULTIPLY op_val termino
    (53) termino -> . factor DIVIDE op_val termino
    (56) factor -> . LPAR expression RPAR
    (57) factor -> . MINUS varcte
    (58) factor -> . varcte termino_val
    (59) varcte -> . ID
    (60) varcte -> . NUMINT
    (61) varcte -> . NUMFLOAT
    (62) varcte -> . BOOLEANTYPE

    ID              shift and go to state 138
    LPAR            shift and go to state 39
    MINUS           shift and go to state 42
    NUMINT          shift and go to state 47
    NUMFLOAT        shift and go to state 41
    BOOLEANTYPE     shift and go to state 49

    factor                         shift and go to state 45
    varcte                         shift and go to state 43
    printx                         shift and go to state 191
    call                           shift and go to state 137
    termino                        shift and go to state 40
    exp                            shift and go to state 48
    expression                     shift and go to state 139

state 175

    (68) printx -> ID id_val PLUS . op_val printx
    (55) op_val -> .

    ID              reduce using rule 55 (op_val -> .)
    LPAR            reduce using rule 55 (op_val -> .)
    MINUS           reduce using rule 55 (op_val -> .)
    NUMINT          reduce using rule 55 (op_val -> .)
    NUMFLOAT        reduce using rule 55 (op_val -> .)
    BOOLEANTYPE     reduce using rule 55 (op_val -> .)

    op_val                         shift and go to state 192

state 176

    (67) printx -> expression PLUS op_val . printx
    (64) printx -> . expression
    (65) printx -> . ID id_val
    (66) printx -> . call
    (67) printx -> . expression PLUS op_val printx
    (68) printx -> . ID id_val PLUS op_val printx
    (69) printx -> . call PLUS op_val printx
    (46) expression -> . exp
    (47) expression -> . exp COMPARISON op_val expression
    (98) call -> . ID id_call LPAR par_call RPAR par_call2
    (99) call -> . ID id_call LPAR par_call params RPAR par_call2
    (48) exp -> . termino
    (49) exp -> . termino PLUS op_val exp
    (50) exp -> . termino MINUS op_val exp
    (51) termino -> . factor
    (52) termino -> . factor MULTIPLY op_val termino
    (53) termino -> . factor DIVIDE op_val termino
    (56) factor -> . LPAR expression RPAR
    (57) factor -> . MINUS varcte
    (58) factor -> . varcte termino_val
    (59) varcte -> . ID
    (60) varcte -> . NUMINT
    (61) varcte -> . NUMFLOAT
    (62) varcte -> . BOOLEANTYPE

    ID              shift and go to state 138
    LPAR            shift and go to state 39
    MINUS           shift and go to state 42
    NUMINT          shift and go to state 47
    NUMFLOAT        shift and go to state 41
    BOOLEANTYPE     shift and go to state 49

    factor                         shift and go to state 45
    varcte                         shift and go to state 43
    printx                         shift and go to state 193
    call                           shift and go to state 137
    termino                        shift and go to state 40
    exp                            shift and go to state 48
    expression                     shift and go to state 139

state 177

    (82) list -> LIST idCheck_List EQUAL LBRACKET listx RBRACKET .

    INT             reduce using rule 82 (list -> LIST idCheck_List EQUAL LBRACKET listx RBRACKET .)
    FLOAT           reduce using rule 82 (list -> LIST idCheck_List EQUAL LBRACKET listx RBRACKET .)
    BOOLEAN         reduce using rule 82 (list -> LIST idCheck_List EQUAL LBRACKET listx RBRACKET .)
    ID              reduce using rule 82 (list -> LIST idCheck_List EQUAL LBRACKET listx RBRACKET .)
    IF              reduce using rule 82 (list -> LIST idCheck_List EQUAL LBRACKET listx RBRACKET .)
    WHILE           reduce using rule 82 (list -> LIST idCheck_List EQUAL LBRACKET listx RBRACKET .)
    PRINT           reduce using rule 82 (list -> LIST idCheck_List EQUAL LBRACKET listx RBRACKET .)
    LIST            reduce using rule 82 (list -> LIST idCheck_List EQUAL LBRACKET listx RBRACKET .)
    MOVE            reduce using rule 82 (list -> LIST idCheck_List EQUAL LBRACKET listx RBRACKET .)
    EAT             reduce using rule 82 (list -> LIST idCheck_List EQUAL LBRACKET listx RBRACKET .)
    CLEAN           reduce using rule 82 (list -> LIST idCheck_List EQUAL LBRACKET listx RBRACKET .)
    PLAY            reduce using rule 82 (list -> LIST idCheck_List EQUAL LBRACKET listx RBRACKET .)
    TURNLEFT        reduce using rule 82 (list -> LIST idCheck_List EQUAL LBRACKET listx RBRACKET .)
    TURNRIGHT       reduce using rule 82 (list -> LIST idCheck_List EQUAL LBRACKET listx RBRACKET .)
    RETURN          reduce using rule 82 (list -> LIST idCheck_List EQUAL LBRACKET listx RBRACKET .)
    RCBRACKET       reduce using rule 82 (list -> LIST idCheck_List EQUAL LBRACKET listx RBRACKET .)


state 178

    (85) listx -> NUMINT id_param .
    (86) listx -> NUMINT id_param . COMA listx

    RBRACKET        reduce using rule 85 (listx -> NUMINT id_param .)
    COMA            shift and go to state 194


state 179

    (87) listx -> NUMFLOAT id_param .
    (88) listx -> NUMFLOAT id_param . COMA listx

    RBRACKET        reduce using rule 87 (listx -> NUMFLOAT id_param .)
    COMA            shift and go to state 195


state 180

    (83) listx -> ID id_param .
    (84) listx -> ID id_param . COMA listx

    RBRACKET        reduce using rule 83 (listx -> ID id_param .)
    COMA            shift and go to state 196


state 181

    (97) remove -> ID idCheck_Add POINT REMOVE LPAR RPAR .

    INT             reduce using rule 97 (remove -> ID idCheck_Add POINT REMOVE LPAR RPAR .)
    FLOAT           reduce using rule 97 (remove -> ID idCheck_Add POINT REMOVE LPAR RPAR .)
    BOOLEAN         reduce using rule 97 (remove -> ID idCheck_Add POINT REMOVE LPAR RPAR .)
    ID              reduce using rule 97 (remove -> ID idCheck_Add POINT REMOVE LPAR RPAR .)
    IF              reduce using rule 97 (remove -> ID idCheck_Add POINT REMOVE LPAR RPAR .)
    WHILE           reduce using rule 97 (remove -> ID idCheck_Add POINT REMOVE LPAR RPAR .)
    PRINT           reduce using rule 97 (remove -> ID idCheck_Add POINT REMOVE LPAR RPAR .)
    LIST            reduce using rule 97 (remove -> ID idCheck_Add POINT REMOVE LPAR RPAR .)
    MOVE            reduce using rule 97 (remove -> ID idCheck_Add POINT REMOVE LPAR RPAR .)
    EAT             reduce using rule 97 (remove -> ID idCheck_Add POINT REMOVE LPAR RPAR .)
    CLEAN           reduce using rule 97 (remove -> ID idCheck_Add POINT REMOVE LPAR RPAR .)
    PLAY            reduce using rule 97 (remove -> ID idCheck_Add POINT REMOVE LPAR RPAR .)
    TURNLEFT        reduce using rule 97 (remove -> ID idCheck_Add POINT REMOVE LPAR RPAR .)
    TURNRIGHT       reduce using rule 97 (remove -> ID idCheck_Add POINT REMOVE LPAR RPAR .)
    RETURN          reduce using rule 97 (remove -> ID idCheck_Add POINT REMOVE LPAR RPAR .)
    RCBRACKET       reduce using rule 97 (remove -> ID idCheck_Add POINT REMOVE LPAR RPAR .)


state 182

    (93) listx_add -> NUMINT . id_param2
    (91) id_param2 -> .

    RPAR            reduce using rule 91 (id_param2 -> .)

    id_param2                      shift and go to state 197

state 183

    (92) listx_add -> ID . id_param2
    (91) id_param2 -> .

    RPAR            reduce using rule 91 (id_param2 -> .)

    id_param2                      shift and go to state 198

state 184

    (94) listx_add -> NUMFLOAT . id_param2
    (91) id_param2 -> .

    RPAR            reduce using rule 91 (id_param2 -> .)

    id_param2                      shift and go to state 199

state 185

    (95) add -> ID idCheck_Add POINT ADD LPAR listx_add . RPAR

    RPAR            shift and go to state 200


state 186

    (76) condition -> IF LPAR exp RPAR cond_1 block . else cond_2
    (77) else -> . ELSE cond_else block
    (78) else -> . empty
    (113) empty -> .

    ELSE            shift and go to state 201
    INT             reduce using rule 113 (empty -> .)
    FLOAT           reduce using rule 113 (empty -> .)
    BOOLEAN         reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    IF              reduce using rule 113 (empty -> .)
    WHILE           reduce using rule 113 (empty -> .)
    PRINT           reduce using rule 113 (empty -> .)
    LIST            reduce using rule 113 (empty -> .)
    MOVE            reduce using rule 113 (empty -> .)
    EAT             reduce using rule 113 (empty -> .)
    CLEAN           reduce using rule 113 (empty -> .)
    PLAY            reduce using rule 113 (empty -> .)
    TURNLEFT        reduce using rule 113 (empty -> .)
    TURNRIGHT       reduce using rule 113 (empty -> .)
    RETURN          reduce using rule 113 (empty -> .)
    RCBRACKET       reduce using rule 113 (empty -> .)

    else                           shift and go to state 203
    empty                          shift and go to state 202

state 187

    (99) call -> ID id_call LPAR par_call params RPAR par_call2 .

    PLUS            reduce using rule 99 (call -> ID id_call LPAR par_call params RPAR par_call2 .)
    LPAR            reduce using rule 99 (call -> ID id_call LPAR par_call params RPAR par_call2 .)
    MINUS           reduce using rule 99 (call -> ID id_call LPAR par_call params RPAR par_call2 .)
    ID              reduce using rule 99 (call -> ID id_call LPAR par_call params RPAR par_call2 .)
    NUMINT          reduce using rule 99 (call -> ID id_call LPAR par_call params RPAR par_call2 .)
    NUMFLOAT        reduce using rule 99 (call -> ID id_call LPAR par_call params RPAR par_call2 .)
    BOOLEANTYPE     reduce using rule 99 (call -> ID id_call LPAR par_call params RPAR par_call2 .)
    RPAR            reduce using rule 99 (call -> ID id_call LPAR par_call params RPAR par_call2 .)
    INT             reduce using rule 99 (call -> ID id_call LPAR par_call params RPAR par_call2 .)
    FLOAT           reduce using rule 99 (call -> ID id_call LPAR par_call params RPAR par_call2 .)
    BOOLEAN         reduce using rule 99 (call -> ID id_call LPAR par_call params RPAR par_call2 .)
    IF              reduce using rule 99 (call -> ID id_call LPAR par_call params RPAR par_call2 .)
    WHILE           reduce using rule 99 (call -> ID id_call LPAR par_call params RPAR par_call2 .)
    PRINT           reduce using rule 99 (call -> ID id_call LPAR par_call params RPAR par_call2 .)
    LIST            reduce using rule 99 (call -> ID id_call LPAR par_call params RPAR par_call2 .)
    MOVE            reduce using rule 99 (call -> ID id_call LPAR par_call params RPAR par_call2 .)
    EAT             reduce using rule 99 (call -> ID id_call LPAR par_call params RPAR par_call2 .)
    CLEAN           reduce using rule 99 (call -> ID id_call LPAR par_call params RPAR par_call2 .)
    PLAY            reduce using rule 99 (call -> ID id_call LPAR par_call params RPAR par_call2 .)
    TURNLEFT        reduce using rule 99 (call -> ID id_call LPAR par_call params RPAR par_call2 .)
    TURNRIGHT       reduce using rule 99 (call -> ID id_call LPAR par_call params RPAR par_call2 .)
    RETURN          reduce using rule 99 (call -> ID id_call LPAR par_call params RPAR par_call2 .)
    RCBRACKET       reduce using rule 99 (call -> ID id_call LPAR par_call params RPAR par_call2 .)
    FUNC            reduce using rule 99 (call -> ID id_call LPAR par_call params RPAR par_call2 .)
    $end            reduce using rule 99 (call -> ID id_call LPAR par_call params RPAR par_call2 .)


state 188

    (104) params -> ID COMA params .

    RPAR            reduce using rule 104 (params -> ID COMA params .)


state 189

    (103) params -> expression COMA params .

    RPAR            reduce using rule 103 (params -> expression COMA params .)


state 190

    (72) cycle -> WHILE cycle_1 LPAR exp RPAR cycle_2 block . cycle_3
    (75) cycle_3 -> .

    INT             reduce using rule 75 (cycle_3 -> .)
    FLOAT           reduce using rule 75 (cycle_3 -> .)
    BOOLEAN         reduce using rule 75 (cycle_3 -> .)
    ID              reduce using rule 75 (cycle_3 -> .)
    IF              reduce using rule 75 (cycle_3 -> .)
    WHILE           reduce using rule 75 (cycle_3 -> .)
    PRINT           reduce using rule 75 (cycle_3 -> .)
    LIST            reduce using rule 75 (cycle_3 -> .)
    MOVE            reduce using rule 75 (cycle_3 -> .)
    EAT             reduce using rule 75 (cycle_3 -> .)
    CLEAN           reduce using rule 75 (cycle_3 -> .)
    PLAY            reduce using rule 75 (cycle_3 -> .)
    TURNLEFT        reduce using rule 75 (cycle_3 -> .)
    TURNRIGHT       reduce using rule 75 (cycle_3 -> .)
    RETURN          reduce using rule 75 (cycle_3 -> .)
    RCBRACKET       reduce using rule 75 (cycle_3 -> .)

    cycle_3                        shift and go to state 204

state 191

    (69) printx -> call PLUS op_val printx .

    LPAR            reduce using rule 69 (printx -> call PLUS op_val printx .)
    MINUS           reduce using rule 69 (printx -> call PLUS op_val printx .)
    ID              reduce using rule 69 (printx -> call PLUS op_val printx .)
    NUMINT          reduce using rule 69 (printx -> call PLUS op_val printx .)
    NUMFLOAT        reduce using rule 69 (printx -> call PLUS op_val printx .)
    BOOLEANTYPE     reduce using rule 69 (printx -> call PLUS op_val printx .)
    RPAR            reduce using rule 69 (printx -> call PLUS op_val printx .)


state 192

    (68) printx -> ID id_val PLUS op_val . printx
    (64) printx -> . expression
    (65) printx -> . ID id_val
    (66) printx -> . call
    (67) printx -> . expression PLUS op_val printx
    (68) printx -> . ID id_val PLUS op_val printx
    (69) printx -> . call PLUS op_val printx
    (46) expression -> . exp
    (47) expression -> . exp COMPARISON op_val expression
    (98) call -> . ID id_call LPAR par_call RPAR par_call2
    (99) call -> . ID id_call LPAR par_call params RPAR par_call2
    (48) exp -> . termino
    (49) exp -> . termino PLUS op_val exp
    (50) exp -> . termino MINUS op_val exp
    (51) termino -> . factor
    (52) termino -> . factor MULTIPLY op_val termino
    (53) termino -> . factor DIVIDE op_val termino
    (56) factor -> . LPAR expression RPAR
    (57) factor -> . MINUS varcte
    (58) factor -> . varcte termino_val
    (59) varcte -> . ID
    (60) varcte -> . NUMINT
    (61) varcte -> . NUMFLOAT
    (62) varcte -> . BOOLEANTYPE

    ID              shift and go to state 138
    LPAR            shift and go to state 39
    MINUS           shift and go to state 42
    NUMINT          shift and go to state 47
    NUMFLOAT        shift and go to state 41
    BOOLEANTYPE     shift and go to state 49

    factor                         shift and go to state 45
    varcte                         shift and go to state 43
    printx                         shift and go to state 205
    call                           shift and go to state 137
    termino                        shift and go to state 40
    exp                            shift and go to state 48
    expression                     shift and go to state 139

state 193

    (67) printx -> expression PLUS op_val printx .

    LPAR            reduce using rule 67 (printx -> expression PLUS op_val printx .)
    MINUS           reduce using rule 67 (printx -> expression PLUS op_val printx .)
    ID              reduce using rule 67 (printx -> expression PLUS op_val printx .)
    NUMINT          reduce using rule 67 (printx -> expression PLUS op_val printx .)
    NUMFLOAT        reduce using rule 67 (printx -> expression PLUS op_val printx .)
    BOOLEANTYPE     reduce using rule 67 (printx -> expression PLUS op_val printx .)
    RPAR            reduce using rule 67 (printx -> expression PLUS op_val printx .)


state 194

    (86) listx -> NUMINT id_param COMA . listx
    (83) listx -> . ID id_param
    (84) listx -> . ID id_param COMA listx
    (85) listx -> . NUMINT id_param
    (86) listx -> . NUMINT id_param COMA listx
    (87) listx -> . NUMFLOAT id_param
    (88) listx -> . NUMFLOAT id_param COMA listx

    ID              shift and go to state 163
    NUMINT          shift and go to state 161
    NUMFLOAT        shift and go to state 162

    listx                          shift and go to state 206

state 195

    (88) listx -> NUMFLOAT id_param COMA . listx
    (83) listx -> . ID id_param
    (84) listx -> . ID id_param COMA listx
    (85) listx -> . NUMINT id_param
    (86) listx -> . NUMINT id_param COMA listx
    (87) listx -> . NUMFLOAT id_param
    (88) listx -> . NUMFLOAT id_param COMA listx

    ID              shift and go to state 163
    NUMINT          shift and go to state 161
    NUMFLOAT        shift and go to state 162

    listx                          shift and go to state 207

state 196

    (84) listx -> ID id_param COMA . listx
    (83) listx -> . ID id_param
    (84) listx -> . ID id_param COMA listx
    (85) listx -> . NUMINT id_param
    (86) listx -> . NUMINT id_param COMA listx
    (87) listx -> . NUMFLOAT id_param
    (88) listx -> . NUMFLOAT id_param COMA listx

    ID              shift and go to state 163
    NUMINT          shift and go to state 161
    NUMFLOAT        shift and go to state 162

    listx                          shift and go to state 208

state 197

    (93) listx_add -> NUMINT id_param2 .

    RPAR            reduce using rule 93 (listx_add -> NUMINT id_param2 .)


state 198

    (92) listx_add -> ID id_param2 .

    RPAR            reduce using rule 92 (listx_add -> ID id_param2 .)


state 199

    (94) listx_add -> NUMFLOAT id_param2 .

    RPAR            reduce using rule 94 (listx_add -> NUMFLOAT id_param2 .)


state 200

    (95) add -> ID idCheck_Add POINT ADD LPAR listx_add RPAR .

    INT             reduce using rule 95 (add -> ID idCheck_Add POINT ADD LPAR listx_add RPAR .)
    FLOAT           reduce using rule 95 (add -> ID idCheck_Add POINT ADD LPAR listx_add RPAR .)
    BOOLEAN         reduce using rule 95 (add -> ID idCheck_Add POINT ADD LPAR listx_add RPAR .)
    ID              reduce using rule 95 (add -> ID idCheck_Add POINT ADD LPAR listx_add RPAR .)
    IF              reduce using rule 95 (add -> ID idCheck_Add POINT ADD LPAR listx_add RPAR .)
    WHILE           reduce using rule 95 (add -> ID idCheck_Add POINT ADD LPAR listx_add RPAR .)
    PRINT           reduce using rule 95 (add -> ID idCheck_Add POINT ADD LPAR listx_add RPAR .)
    LIST            reduce using rule 95 (add -> ID idCheck_Add POINT ADD LPAR listx_add RPAR .)
    MOVE            reduce using rule 95 (add -> ID idCheck_Add POINT ADD LPAR listx_add RPAR .)
    EAT             reduce using rule 95 (add -> ID idCheck_Add POINT ADD LPAR listx_add RPAR .)
    CLEAN           reduce using rule 95 (add -> ID idCheck_Add POINT ADD LPAR listx_add RPAR .)
    PLAY            reduce using rule 95 (add -> ID idCheck_Add POINT ADD LPAR listx_add RPAR .)
    TURNLEFT        reduce using rule 95 (add -> ID idCheck_Add POINT ADD LPAR listx_add RPAR .)
    TURNRIGHT       reduce using rule 95 (add -> ID idCheck_Add POINT ADD LPAR listx_add RPAR .)
    RETURN          reduce using rule 95 (add -> ID idCheck_Add POINT ADD LPAR listx_add RPAR .)
    RCBRACKET       reduce using rule 95 (add -> ID idCheck_Add POINT ADD LPAR listx_add RPAR .)


state 201

    (77) else -> ELSE . cond_else block
    (81) cond_else -> .

    LCBRACKET       reduce using rule 81 (cond_else -> .)

    cond_else                      shift and go to state 209

state 202

    (78) else -> empty .

    INT             reduce using rule 78 (else -> empty .)
    FLOAT           reduce using rule 78 (else -> empty .)
    BOOLEAN         reduce using rule 78 (else -> empty .)
    ID              reduce using rule 78 (else -> empty .)
    IF              reduce using rule 78 (else -> empty .)
    WHILE           reduce using rule 78 (else -> empty .)
    PRINT           reduce using rule 78 (else -> empty .)
    LIST            reduce using rule 78 (else -> empty .)
    MOVE            reduce using rule 78 (else -> empty .)
    EAT             reduce using rule 78 (else -> empty .)
    CLEAN           reduce using rule 78 (else -> empty .)
    PLAY            reduce using rule 78 (else -> empty .)
    TURNLEFT        reduce using rule 78 (else -> empty .)
    TURNRIGHT       reduce using rule 78 (else -> empty .)
    RETURN          reduce using rule 78 (else -> empty .)
    RCBRACKET       reduce using rule 78 (else -> empty .)


state 203

    (76) condition -> IF LPAR exp RPAR cond_1 block else . cond_2
    (80) cond_2 -> .

    INT             reduce using rule 80 (cond_2 -> .)
    FLOAT           reduce using rule 80 (cond_2 -> .)
    BOOLEAN         reduce using rule 80 (cond_2 -> .)
    ID              reduce using rule 80 (cond_2 -> .)
    IF              reduce using rule 80 (cond_2 -> .)
    WHILE           reduce using rule 80 (cond_2 -> .)
    PRINT           reduce using rule 80 (cond_2 -> .)
    LIST            reduce using rule 80 (cond_2 -> .)
    MOVE            reduce using rule 80 (cond_2 -> .)
    EAT             reduce using rule 80 (cond_2 -> .)
    CLEAN           reduce using rule 80 (cond_2 -> .)
    PLAY            reduce using rule 80 (cond_2 -> .)
    TURNLEFT        reduce using rule 80 (cond_2 -> .)
    TURNRIGHT       reduce using rule 80 (cond_2 -> .)
    RETURN          reduce using rule 80 (cond_2 -> .)
    RCBRACKET       reduce using rule 80 (cond_2 -> .)

    cond_2                         shift and go to state 210

state 204

    (72) cycle -> WHILE cycle_1 LPAR exp RPAR cycle_2 block cycle_3 .

    INT             reduce using rule 72 (cycle -> WHILE cycle_1 LPAR exp RPAR cycle_2 block cycle_3 .)
    FLOAT           reduce using rule 72 (cycle -> WHILE cycle_1 LPAR exp RPAR cycle_2 block cycle_3 .)
    BOOLEAN         reduce using rule 72 (cycle -> WHILE cycle_1 LPAR exp RPAR cycle_2 block cycle_3 .)
    ID              reduce using rule 72 (cycle -> WHILE cycle_1 LPAR exp RPAR cycle_2 block cycle_3 .)
    IF              reduce using rule 72 (cycle -> WHILE cycle_1 LPAR exp RPAR cycle_2 block cycle_3 .)
    WHILE           reduce using rule 72 (cycle -> WHILE cycle_1 LPAR exp RPAR cycle_2 block cycle_3 .)
    PRINT           reduce using rule 72 (cycle -> WHILE cycle_1 LPAR exp RPAR cycle_2 block cycle_3 .)
    LIST            reduce using rule 72 (cycle -> WHILE cycle_1 LPAR exp RPAR cycle_2 block cycle_3 .)
    MOVE            reduce using rule 72 (cycle -> WHILE cycle_1 LPAR exp RPAR cycle_2 block cycle_3 .)
    EAT             reduce using rule 72 (cycle -> WHILE cycle_1 LPAR exp RPAR cycle_2 block cycle_3 .)
    CLEAN           reduce using rule 72 (cycle -> WHILE cycle_1 LPAR exp RPAR cycle_2 block cycle_3 .)
    PLAY            reduce using rule 72 (cycle -> WHILE cycle_1 LPAR exp RPAR cycle_2 block cycle_3 .)
    TURNLEFT        reduce using rule 72 (cycle -> WHILE cycle_1 LPAR exp RPAR cycle_2 block cycle_3 .)
    TURNRIGHT       reduce using rule 72 (cycle -> WHILE cycle_1 LPAR exp RPAR cycle_2 block cycle_3 .)
    RETURN          reduce using rule 72 (cycle -> WHILE cycle_1 LPAR exp RPAR cycle_2 block cycle_3 .)
    RCBRACKET       reduce using rule 72 (cycle -> WHILE cycle_1 LPAR exp RPAR cycle_2 block cycle_3 .)


state 205

    (68) printx -> ID id_val PLUS op_val printx .

    LPAR            reduce using rule 68 (printx -> ID id_val PLUS op_val printx .)
    MINUS           reduce using rule 68 (printx -> ID id_val PLUS op_val printx .)
    ID              reduce using rule 68 (printx -> ID id_val PLUS op_val printx .)
    NUMINT          reduce using rule 68 (printx -> ID id_val PLUS op_val printx .)
    NUMFLOAT        reduce using rule 68 (printx -> ID id_val PLUS op_val printx .)
    BOOLEANTYPE     reduce using rule 68 (printx -> ID id_val PLUS op_val printx .)
    RPAR            reduce using rule 68 (printx -> ID id_val PLUS op_val printx .)


state 206

    (86) listx -> NUMINT id_param COMA listx .

    RBRACKET        reduce using rule 86 (listx -> NUMINT id_param COMA listx .)


state 207

    (88) listx -> NUMFLOAT id_param COMA listx .

    RBRACKET        reduce using rule 88 (listx -> NUMFLOAT id_param COMA listx .)


state 208

    (84) listx -> ID id_param COMA listx .

    RBRACKET        reduce using rule 84 (listx -> ID id_param COMA listx .)


state 209

    (77) else -> ELSE cond_else . block
    (16) block -> . LCBRACKET blockx RCBRACKET

    LCBRACKET       shift and go to state 37

    block                          shift and go to state 211

state 210

    (76) condition -> IF LPAR exp RPAR cond_1 block else cond_2 .

    INT             reduce using rule 76 (condition -> IF LPAR exp RPAR cond_1 block else cond_2 .)
    FLOAT           reduce using rule 76 (condition -> IF LPAR exp RPAR cond_1 block else cond_2 .)
    BOOLEAN         reduce using rule 76 (condition -> IF LPAR exp RPAR cond_1 block else cond_2 .)
    ID              reduce using rule 76 (condition -> IF LPAR exp RPAR cond_1 block else cond_2 .)
    IF              reduce using rule 76 (condition -> IF LPAR exp RPAR cond_1 block else cond_2 .)
    WHILE           reduce using rule 76 (condition -> IF LPAR exp RPAR cond_1 block else cond_2 .)
    PRINT           reduce using rule 76 (condition -> IF LPAR exp RPAR cond_1 block else cond_2 .)
    LIST            reduce using rule 76 (condition -> IF LPAR exp RPAR cond_1 block else cond_2 .)
    MOVE            reduce using rule 76 (condition -> IF LPAR exp RPAR cond_1 block else cond_2 .)
    EAT             reduce using rule 76 (condition -> IF LPAR exp RPAR cond_1 block else cond_2 .)
    CLEAN           reduce using rule 76 (condition -> IF LPAR exp RPAR cond_1 block else cond_2 .)
    PLAY            reduce using rule 76 (condition -> IF LPAR exp RPAR cond_1 block else cond_2 .)
    TURNLEFT        reduce using rule 76 (condition -> IF LPAR exp RPAR cond_1 block else cond_2 .)
    TURNRIGHT       reduce using rule 76 (condition -> IF LPAR exp RPAR cond_1 block else cond_2 .)
    RETURN          reduce using rule 76 (condition -> IF LPAR exp RPAR cond_1 block else cond_2 .)
    RCBRACKET       reduce using rule 76 (condition -> IF LPAR exp RPAR cond_1 block else cond_2 .)


state 211

    (77) else -> ELSE cond_else block .

    INT             reduce using rule 77 (else -> ELSE cond_else block .)
    FLOAT           reduce using rule 77 (else -> ELSE cond_else block .)
    BOOLEAN         reduce using rule 77 (else -> ELSE cond_else block .)
    ID              reduce using rule 77 (else -> ELSE cond_else block .)
    IF              reduce using rule 77 (else -> ELSE cond_else block .)
    WHILE           reduce using rule 77 (else -> ELSE cond_else block .)
    PRINT           reduce using rule 77 (else -> ELSE cond_else block .)
    LIST            reduce using rule 77 (else -> ELSE cond_else block .)
    MOVE            reduce using rule 77 (else -> ELSE cond_else block .)
    EAT             reduce using rule 77 (else -> ELSE cond_else block .)
    CLEAN           reduce using rule 77 (else -> ELSE cond_else block .)
    PLAY            reduce using rule 77 (else -> ELSE cond_else block .)
    TURNLEFT        reduce using rule 77 (else -> ELSE cond_else block .)
    TURNRIGHT       reduce using rule 77 (else -> ELSE cond_else block .)
    RETURN          reduce using rule 77 (else -> ELSE cond_else block .)
    RCBRACKET       reduce using rule 77 (else -> ELSE cond_else block .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for FUNC in state 0 resolved as shift
WARNING: shift/reduce conflict for FUNC in state 6 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 40 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 40 resolved as shift
WARNING: shift/reduce conflict for COMA in state 150 resolved as shift
WARNING: reduce/reduce conflict in state 138 resolved using rule (id_val -> <empty>)
WARNING: rejected rule (varcte -> ID) in state 138
WARNING: reduce/reduce conflict in state 138 resolved using rule (id_val -> <empty>)
WARNING: rejected rule (id_call -> <empty>) in state 138
WARNING: reduce/reduce conflict in state 150 resolved using rule (varcte -> ID)
WARNING: rejected rule (params -> ID) in state 150
WARNING: Rule (params -> ID) is never reduced
