Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Unused terminals:

    TRUE
    STRING
    SEMICOLON
    COLON
    SORT
    CANDY
    FALSE

Grammar

Rule 0     S' -> class
Rule 1     class -> main_add vars_global init_vars func_list MAIN main_retorno block
Rule 2     main_add -> <empty>
Rule 3     main_retorno -> <empty>
Rule 4     vars_global -> varsGlobal vars_global
Rule 5     vars_global -> empty
Rule 6     init_vars -> asign init_vars
Rule 7     init_vars -> empty
Rule 8     func_list -> func func_list
Rule 9     func_list -> empty
Rule 10    func -> FUNC idCheck LPAR funcx RPAR block func_end
Rule 11    func_end -> <empty>
Rule 12    idCheck -> ID
Rule 13    funcx -> vars paramCheck
Rule 14    funcx -> vars paramCheck COMA funcx
Rule 15    funcx -> empty
Rule 16    paramCheck -> <empty>
Rule 17    block -> LCBRACKET blockx RCBRACKET
Rule 18    blockx -> vars
Rule 19    blockx -> vars blockx
Rule 20    blockx -> statement
Rule 21    blockx -> statement blockx
Rule 22    statement -> asign
Rule 23    statement -> condition
Rule 24    statement -> cycle
Rule 25    statement -> print
Rule 26    statement -> list
Rule 27    statement -> call
Rule 28    statement -> add
Rule 29    statement -> find
Rule 30    statement -> printList
Rule 31    statement -> move
Rule 32    statement -> toy
Rule 33    statement -> clean
Rule 34    statement -> play
Rule 35    statement -> return
Rule 36    return -> RETURN LPAR par_call expression RPAR par_call2
Rule 37    return -> RETURN LPAR par_call call RPAR par_call2
Rule 38    varsGlobal -> type ID
Rule 39    vars -> type ID
Rule 40    type -> INT
Rule 41    type -> FLOAT
Rule 42    type -> BOOLEAN
Rule 43    asign -> ID id_val EQUAL equal_val expression
Rule 44    asign -> ID id_val EQUAL equal_val call
Rule 45    asign -> ID id_val EQUAL equal_val remove
Rule 46    id_val -> <empty>
Rule 47    equal_val -> <empty>
Rule 48    expression -> exp
Rule 49    expression -> exp COMPARISON op_val expression
Rule 50    exp -> termino
Rule 51    exp -> termino PLUS op_val exp
Rule 52    exp -> termino MINUS op_val exp
Rule 53    termino -> factor
Rule 54    termino -> factor MULTIPLY op_val termino
Rule 55    termino -> factor DIVIDE op_val termino
Rule 56    termino_val -> <empty>
Rule 57    op_val -> <empty>
Rule 58    factor -> LPAR expression RPAR
Rule 59    factor -> MINUS varcte
Rule 60    factor -> varcte termino_val
Rule 61    varcte -> ID
Rule 62    varcte -> NUMINT
Rule 63    varcte -> NUMFLOAT
Rule 64    varcte -> BOOLEANTYPE
Rule 65    print -> PRINT LPAR par_call printx RPAR par_call2
Rule 66    printx -> expression
Rule 67    printx -> ID id_val
Rule 68    printx -> call
Rule 69    printx -> expression PLUS op_val printx
Rule 70    printx -> ID id_val PLUS op_val printx
Rule 71    printx -> call PLUS op_val printx
Rule 72    cycle -> WHILE cycle_1 LPAR expression RPAR cycle_2 block cycle_3
Rule 73    cycle -> WHILE cycle_1 LPAR vaciaList RPAR cycle_2 block cycle_3
Rule 74    cycle_1 -> <empty>
Rule 75    cycle_2 -> <empty>
Rule 76    cycle_3 -> <empty>
Rule 77    condition -> IF LPAR expression RPAR cond_1 block else cond_2
Rule 78    condition -> IF LPAR vaciaList RPAR cond_1 block else cond_2
Rule 79    else -> ELSE cond_else block
Rule 80    else -> empty
Rule 81    cond_1 -> <empty>
Rule 82    cond_2 -> <empty>
Rule 83    cond_else -> <empty>
Rule 84    vaciaList -> ID idCheck_Add POINT VACIA LPAR RPAR
Rule 85    list -> LIST idCheck_List EQUAL LBRACKET listx RBRACKET
Rule 86    listx -> ID id_param
Rule 87    listx -> ID id_param COMA listx
Rule 88    listx -> NUMINT id_param
Rule 89    listx -> NUMINT id_param COMA listx
Rule 90    listx -> NUMFLOAT id_param
Rule 91    listx -> NUMFLOAT id_param COMA listx
Rule 92    listx -> empty
Rule 93    idCheck_List -> ID
Rule 94    id_param -> <empty>
Rule 95    id_param2 -> <empty>
Rule 96    listx_add -> ID id_param2
Rule 97    listx_add -> NUMINT id_param2
Rule 98    listx_add -> NUMFLOAT id_param2
Rule 99    add -> ID idCheck_Add POINT ADD LPAR listx_add RPAR
Rule 100   idCheck_Add -> <empty>
Rule 101   remove -> ID idCheck_Remove POINT REMOVE LPAR RPAR
Rule 102   idCheck_Remove -> <empty>
Rule 103   find -> ID idCheck_Add POINT FIND LPAR NUMINT RPAR
Rule 104   printList -> ID idCheck_Add POINT PRINTLIST LPAR RPAR
Rule 105   call -> ID id_call LPAR par_call RPAR par_call2
Rule 106   call -> ID id_call LPAR par_call params RPAR par_call2
Rule 107   id_call -> <empty>
Rule 108   par_call -> <empty>
Rule 109   par_call2 -> <empty>
Rule 110   params -> expression COMA params
Rule 111   params -> ID COMA params
Rule 112   params -> expression
Rule 113   params -> ID
Rule 114   move -> CAT POINT MOVE LPAR NUMINT COMA NUMINT RPAR
Rule 115   toy -> ADD POINT TOY LPAR RPAR
Rule 116   clean -> CAT POINT CLEAN LPAR RPAR
Rule 117   play -> CAT POINT PLAY LPAR RPAR
Rule 118   empty -> <empty>

Terminals, with rules where they appear

ADD                  : 99 115
BOOLEAN              : 42
BOOLEANTYPE          : 64
CANDY                : 
CAT                  : 114 116 117
CLEAN                : 116
COLON                : 
COMA                 : 14 87 89 91 110 111 114
COMPARISON           : 49
DIVIDE               : 55
ELSE                 : 79
EQUAL                : 43 44 45 85
FALSE                : 
FIND                 : 103
FLOAT                : 41
FUNC                 : 10
ID                   : 12 38 39 43 44 45 61 67 70 84 86 87 93 96 99 101 103 104 105 106 111 113
IF                   : 77 78
INT                  : 40
LBRACKET             : 85
LCBRACKET            : 17
LIST                 : 85
LPAR                 : 10 36 37 58 65 72 73 77 78 84 99 101 103 104 105 106 114 115 116 117
MAIN                 : 1
MINUS                : 52 59
MOVE                 : 114
MULTIPLY             : 54
NUMFLOAT             : 63 90 91 98
NUMINT               : 62 88 89 97 103 114 114
PLAY                 : 117
PLUS                 : 51 69 70 71
POINT                : 84 99 101 103 104 114 115 116 117
PRINT                : 65
PRINTLIST            : 104
RBRACKET             : 85
RCBRACKET            : 17
REMOVE               : 101
RETURN               : 36 37
RPAR                 : 10 36 37 58 65 72 73 77 78 84 99 101 103 104 105 106 114 115 116 117
SEMICOLON            : 
SORT                 : 
STRING               : 
TOY                  : 115
TRUE                 : 
VACIA                : 84
WHILE                : 72 73
error                : 

Nonterminals, with rules where they appear

add                  : 28
asign                : 6 22
block                : 1 10 72 73 77 78 79
blockx               : 17 19 21
call                 : 27 37 44 68 71
class                : 0
clean                : 33
cond_1               : 77 78
cond_2               : 77 78
cond_else            : 79
condition            : 23
cycle                : 24
cycle_1              : 72 73
cycle_2              : 72 73
cycle_3              : 72 73
else                 : 77 78
empty                : 5 7 9 15 80 92
equal_val            : 43 44 45
exp                  : 48 49 51 52
expression           : 36 43 49 58 66 69 72 77 110 112
factor               : 53 54 55
find                 : 29
func                 : 8
func_end             : 10
func_list            : 1 8
funcx                : 10 14
idCheck              : 10
idCheck_Add          : 84 99 103 104
idCheck_List         : 85
idCheck_Remove       : 101
id_call              : 105 106
id_param             : 86 87 88 89 90 91
id_param2            : 96 97 98
id_val               : 43 44 45 67 70
init_vars            : 1 6
list                 : 26
listx                : 85 87 89 91
listx_add            : 99
main_add             : 1
main_retorno         : 1
move                 : 31
op_val               : 49 51 52 54 55 69 70 71
par_call             : 36 37 65 105 106
par_call2            : 36 37 65 105 106
paramCheck           : 13 14
params               : 106 110 111
play                 : 34
print                : 25
printList            : 30
printx               : 65 69 70 71
remove               : 45
return               : 35
statement            : 20 21
termino              : 50 51 52 54 55
termino_val          : 60
toy                  : 32
type                 : 38 39
vaciaList            : 73 78
varcte               : 59 60
vars                 : 13 14 18 19
varsGlobal           : 4
vars_global          : 1 4

Parsing method: LALR

state 0

    (0) S' -> . class
    (1) class -> . main_add vars_global init_vars func_list MAIN main_retorno block
    (2) main_add -> .

    INT             reduce using rule 2 (main_add -> .)
    FLOAT           reduce using rule 2 (main_add -> .)
    BOOLEAN         reduce using rule 2 (main_add -> .)
    ID              reduce using rule 2 (main_add -> .)
    FUNC            reduce using rule 2 (main_add -> .)
    MAIN            reduce using rule 2 (main_add -> .)

    class                          shift and go to state 1
    main_add                       shift and go to state 2

state 1

    (0) S' -> class .



state 2

    (1) class -> main_add . vars_global init_vars func_list MAIN main_retorno block
    (4) vars_global -> . varsGlobal vars_global
    (5) vars_global -> . empty
    (38) varsGlobal -> . type ID
    (118) empty -> .
    (40) type -> . INT
    (41) type -> . FLOAT
    (42) type -> . BOOLEAN

    ID              reduce using rule 118 (empty -> .)
    FUNC            reduce using rule 118 (empty -> .)
    MAIN            reduce using rule 118 (empty -> .)
    INT             shift and go to state 4
    FLOAT           shift and go to state 5
    BOOLEAN         shift and go to state 6

    varsGlobal                     shift and go to state 3
    empty                          shift and go to state 7
    vars_global                    shift and go to state 8
    type                           shift and go to state 9

state 3

    (4) vars_global -> varsGlobal . vars_global
    (4) vars_global -> . varsGlobal vars_global
    (5) vars_global -> . empty
    (38) varsGlobal -> . type ID
    (118) empty -> .
    (40) type -> . INT
    (41) type -> . FLOAT
    (42) type -> . BOOLEAN

    ID              reduce using rule 118 (empty -> .)
    FUNC            reduce using rule 118 (empty -> .)
    MAIN            reduce using rule 118 (empty -> .)
    INT             shift and go to state 4
    FLOAT           shift and go to state 5
    BOOLEAN         shift and go to state 6

    varsGlobal                     shift and go to state 3
    vars_global                    shift and go to state 10
    type                           shift and go to state 9
    empty                          shift and go to state 7

state 4

    (40) type -> INT .

    ID              reduce using rule 40 (type -> INT .)


state 5

    (41) type -> FLOAT .

    ID              reduce using rule 41 (type -> FLOAT .)


state 6

    (42) type -> BOOLEAN .

    ID              reduce using rule 42 (type -> BOOLEAN .)


state 7

    (5) vars_global -> empty .

    ID              reduce using rule 5 (vars_global -> empty .)
    FUNC            reduce using rule 5 (vars_global -> empty .)
    MAIN            reduce using rule 5 (vars_global -> empty .)


state 8

    (1) class -> main_add vars_global . init_vars func_list MAIN main_retorno block
    (6) init_vars -> . asign init_vars
    (7) init_vars -> . empty
    (43) asign -> . ID id_val EQUAL equal_val expression
    (44) asign -> . ID id_val EQUAL equal_val call
    (45) asign -> . ID id_val EQUAL equal_val remove
    (118) empty -> .

    ID              shift and go to state 14
    FUNC            reduce using rule 118 (empty -> .)
    MAIN            reduce using rule 118 (empty -> .)

    init_vars                      shift and go to state 11
    asign                          shift and go to state 12
    empty                          shift and go to state 13

state 9

    (38) varsGlobal -> type . ID

    ID              shift and go to state 15


state 10

    (4) vars_global -> varsGlobal vars_global .

    ID              reduce using rule 4 (vars_global -> varsGlobal vars_global .)
    FUNC            reduce using rule 4 (vars_global -> varsGlobal vars_global .)
    MAIN            reduce using rule 4 (vars_global -> varsGlobal vars_global .)


state 11

    (1) class -> main_add vars_global init_vars . func_list MAIN main_retorno block
    (8) func_list -> . func func_list
    (9) func_list -> . empty
    (10) func -> . FUNC idCheck LPAR funcx RPAR block func_end
    (118) empty -> .

    FUNC            shift and go to state 16
    MAIN            reduce using rule 118 (empty -> .)

    empty                          shift and go to state 17
    func                           shift and go to state 18
    func_list                      shift and go to state 19

state 12

    (6) init_vars -> asign . init_vars
    (6) init_vars -> . asign init_vars
    (7) init_vars -> . empty
    (43) asign -> . ID id_val EQUAL equal_val expression
    (44) asign -> . ID id_val EQUAL equal_val call
    (45) asign -> . ID id_val EQUAL equal_val remove
    (118) empty -> .

    ID              shift and go to state 14
    FUNC            reduce using rule 118 (empty -> .)
    MAIN            reduce using rule 118 (empty -> .)

    init_vars                      shift and go to state 20
    asign                          shift and go to state 12
    empty                          shift and go to state 13

state 13

    (7) init_vars -> empty .

    FUNC            reduce using rule 7 (init_vars -> empty .)
    MAIN            reduce using rule 7 (init_vars -> empty .)


state 14

    (43) asign -> ID . id_val EQUAL equal_val expression
    (44) asign -> ID . id_val EQUAL equal_val call
    (45) asign -> ID . id_val EQUAL equal_val remove
    (46) id_val -> .

    EQUAL           reduce using rule 46 (id_val -> .)

    id_val                         shift and go to state 21

state 15

    (38) varsGlobal -> type ID .

    INT             reduce using rule 38 (varsGlobal -> type ID .)
    FLOAT           reduce using rule 38 (varsGlobal -> type ID .)
    BOOLEAN         reduce using rule 38 (varsGlobal -> type ID .)
    ID              reduce using rule 38 (varsGlobal -> type ID .)
    FUNC            reduce using rule 38 (varsGlobal -> type ID .)
    MAIN            reduce using rule 38 (varsGlobal -> type ID .)


state 16

    (10) func -> FUNC . idCheck LPAR funcx RPAR block func_end
    (12) idCheck -> . ID

    ID              shift and go to state 23

    idCheck                        shift and go to state 22

state 17

    (9) func_list -> empty .

    MAIN            reduce using rule 9 (func_list -> empty .)


state 18

    (8) func_list -> func . func_list
    (8) func_list -> . func func_list
    (9) func_list -> . empty
    (10) func -> . FUNC idCheck LPAR funcx RPAR block func_end
    (118) empty -> .

    FUNC            shift and go to state 16
    MAIN            reduce using rule 118 (empty -> .)

    empty                          shift and go to state 17
    func                           shift and go to state 18
    func_list                      shift and go to state 24

state 19

    (1) class -> main_add vars_global init_vars func_list . MAIN main_retorno block

    MAIN            shift and go to state 25


state 20

    (6) init_vars -> asign init_vars .

    FUNC            reduce using rule 6 (init_vars -> asign init_vars .)
    MAIN            reduce using rule 6 (init_vars -> asign init_vars .)


state 21

    (43) asign -> ID id_val . EQUAL equal_val expression
    (44) asign -> ID id_val . EQUAL equal_val call
    (45) asign -> ID id_val . EQUAL equal_val remove

    EQUAL           shift and go to state 26


state 22

    (10) func -> FUNC idCheck . LPAR funcx RPAR block func_end

    LPAR            shift and go to state 27


state 23

    (12) idCheck -> ID .

    LPAR            reduce using rule 12 (idCheck -> ID .)


state 24

    (8) func_list -> func func_list .

    MAIN            reduce using rule 8 (func_list -> func func_list .)


state 25

    (1) class -> main_add vars_global init_vars func_list MAIN . main_retorno block
    (3) main_retorno -> .

    LCBRACKET       reduce using rule 3 (main_retorno -> .)

    main_retorno                   shift and go to state 28

state 26

    (43) asign -> ID id_val EQUAL . equal_val expression
    (44) asign -> ID id_val EQUAL . equal_val call
    (45) asign -> ID id_val EQUAL . equal_val remove
    (47) equal_val -> .

    ID              reduce using rule 47 (equal_val -> .)
    LPAR            reduce using rule 47 (equal_val -> .)
    MINUS           reduce using rule 47 (equal_val -> .)
    NUMINT          reduce using rule 47 (equal_val -> .)
    NUMFLOAT        reduce using rule 47 (equal_val -> .)
    BOOLEANTYPE     reduce using rule 47 (equal_val -> .)

    equal_val                      shift and go to state 29

state 27

    (10) func -> FUNC idCheck LPAR . funcx RPAR block func_end
    (13) funcx -> . vars paramCheck
    (14) funcx -> . vars paramCheck COMA funcx
    (15) funcx -> . empty
    (39) vars -> . type ID
    (118) empty -> .
    (40) type -> . INT
    (41) type -> . FLOAT
    (42) type -> . BOOLEAN

    RPAR            reduce using rule 118 (empty -> .)
    INT             shift and go to state 4
    FLOAT           shift and go to state 5
    BOOLEAN         shift and go to state 6

    funcx                          shift and go to state 31
    vars                           shift and go to state 30
    empty                          shift and go to state 32
    type                           shift and go to state 33

state 28

    (1) class -> main_add vars_global init_vars func_list MAIN main_retorno . block
    (17) block -> . LCBRACKET blockx RCBRACKET

    LCBRACKET       shift and go to state 34

    block                          shift and go to state 35

state 29

    (43) asign -> ID id_val EQUAL equal_val . expression
    (44) asign -> ID id_val EQUAL equal_val . call
    (45) asign -> ID id_val EQUAL equal_val . remove
    (48) expression -> . exp
    (49) expression -> . exp COMPARISON op_val expression
    (105) call -> . ID id_call LPAR par_call RPAR par_call2
    (106) call -> . ID id_call LPAR par_call params RPAR par_call2
    (101) remove -> . ID idCheck_Remove POINT REMOVE LPAR RPAR
    (50) exp -> . termino
    (51) exp -> . termino PLUS op_val exp
    (52) exp -> . termino MINUS op_val exp
    (53) termino -> . factor
    (54) termino -> . factor MULTIPLY op_val termino
    (55) termino -> . factor DIVIDE op_val termino
    (58) factor -> . LPAR expression RPAR
    (59) factor -> . MINUS varcte
    (60) factor -> . varcte termino_val
    (61) varcte -> . ID
    (62) varcte -> . NUMINT
    (63) varcte -> . NUMFLOAT
    (64) varcte -> . BOOLEANTYPE

    ID              shift and go to state 43
    LPAR            shift and go to state 36
    MINUS           shift and go to state 39
    NUMINT          shift and go to state 44
    NUMFLOAT        shift and go to state 37
    BOOLEANTYPE     shift and go to state 47

    varcte                         shift and go to state 40
    factor                         shift and go to state 41
    remove                         shift and go to state 45
    call                           shift and go to state 42
    termino                        shift and go to state 38
    exp                            shift and go to state 46
    expression                     shift and go to state 48

state 30

    (13) funcx -> vars . paramCheck
    (14) funcx -> vars . paramCheck COMA funcx
    (16) paramCheck -> .

    COMA            reduce using rule 16 (paramCheck -> .)
    RPAR            reduce using rule 16 (paramCheck -> .)

    paramCheck                     shift and go to state 49

state 31

    (10) func -> FUNC idCheck LPAR funcx . RPAR block func_end

    RPAR            shift and go to state 50


state 32

    (15) funcx -> empty .

    RPAR            reduce using rule 15 (funcx -> empty .)


state 33

    (39) vars -> type . ID

    ID              shift and go to state 51


state 34

    (17) block -> LCBRACKET . blockx RCBRACKET
    (18) blockx -> . vars
    (19) blockx -> . vars blockx
    (20) blockx -> . statement
    (21) blockx -> . statement blockx
    (39) vars -> . type ID
    (22) statement -> . asign
    (23) statement -> . condition
    (24) statement -> . cycle
    (25) statement -> . print
    (26) statement -> . list
    (27) statement -> . call
    (28) statement -> . add
    (29) statement -> . find
    (30) statement -> . printList
    (31) statement -> . move
    (32) statement -> . toy
    (33) statement -> . clean
    (34) statement -> . play
    (35) statement -> . return
    (40) type -> . INT
    (41) type -> . FLOAT
    (42) type -> . BOOLEAN
    (43) asign -> . ID id_val EQUAL equal_val expression
    (44) asign -> . ID id_val EQUAL equal_val call
    (45) asign -> . ID id_val EQUAL equal_val remove
    (77) condition -> . IF LPAR expression RPAR cond_1 block else cond_2
    (78) condition -> . IF LPAR vaciaList RPAR cond_1 block else cond_2
    (72) cycle -> . WHILE cycle_1 LPAR expression RPAR cycle_2 block cycle_3
    (73) cycle -> . WHILE cycle_1 LPAR vaciaList RPAR cycle_2 block cycle_3
    (65) print -> . PRINT LPAR par_call printx RPAR par_call2
    (85) list -> . LIST idCheck_List EQUAL LBRACKET listx RBRACKET
    (105) call -> . ID id_call LPAR par_call RPAR par_call2
    (106) call -> . ID id_call LPAR par_call params RPAR par_call2
    (99) add -> . ID idCheck_Add POINT ADD LPAR listx_add RPAR
    (103) find -> . ID idCheck_Add POINT FIND LPAR NUMINT RPAR
    (104) printList -> . ID idCheck_Add POINT PRINTLIST LPAR RPAR
    (114) move -> . CAT POINT MOVE LPAR NUMINT COMA NUMINT RPAR
    (115) toy -> . ADD POINT TOY LPAR RPAR
    (116) clean -> . CAT POINT CLEAN LPAR RPAR
    (117) play -> . CAT POINT PLAY LPAR RPAR
    (36) return -> . RETURN LPAR par_call expression RPAR par_call2
    (37) return -> . RETURN LPAR par_call call RPAR par_call2

    INT             shift and go to state 4
    FLOAT           shift and go to state 5
    BOOLEAN         shift and go to state 6
    ID              shift and go to state 71
    IF              shift and go to state 65
    WHILE           shift and go to state 56
    PRINT           shift and go to state 57
    LIST            shift and go to state 59
    CAT             shift and go to state 70
    ADD             shift and go to state 69
    RETURN          shift and go to state 52

    vars                           shift and go to state 53
    move                           shift and go to state 54
    printList                      shift and go to state 55
    toy                            shift and go to state 60
    find                           shift and go to state 58
    add                            shift and go to state 61
    call                           shift and go to state 62
    statement                      shift and go to state 63
    print                          shift and go to state 64
    type                           shift and go to state 33
    play                           shift and go to state 66
    return                         shift and go to state 67
    blockx                         shift and go to state 68
    condition                      shift and go to state 72
    cycle                          shift and go to state 73
    list                           shift and go to state 74
    asign                          shift and go to state 75
    clean                          shift and go to state 76

state 35

    (1) class -> main_add vars_global init_vars func_list MAIN main_retorno block .

    $end            reduce using rule 1 (class -> main_add vars_global init_vars func_list MAIN main_retorno block .)


state 36

    (58) factor -> LPAR . expression RPAR
    (48) expression -> . exp
    (49) expression -> . exp COMPARISON op_val expression
    (50) exp -> . termino
    (51) exp -> . termino PLUS op_val exp
    (52) exp -> . termino MINUS op_val exp
    (53) termino -> . factor
    (54) termino -> . factor MULTIPLY op_val termino
    (55) termino -> . factor DIVIDE op_val termino
    (58) factor -> . LPAR expression RPAR
    (59) factor -> . MINUS varcte
    (60) factor -> . varcte termino_val
    (61) varcte -> . ID
    (62) varcte -> . NUMINT
    (63) varcte -> . NUMFLOAT
    (64) varcte -> . BOOLEANTYPE

    LPAR            shift and go to state 36
    MINUS           shift and go to state 39
    ID              shift and go to state 77
    NUMINT          shift and go to state 44
    NUMFLOAT        shift and go to state 37
    BOOLEANTYPE     shift and go to state 47

    varcte                         shift and go to state 40
    termino                        shift and go to state 38
    exp                            shift and go to state 46
    factor                         shift and go to state 41
    expression                     shift and go to state 78

state 37

    (63) varcte -> NUMFLOAT .

    MULTIPLY        reduce using rule 63 (varcte -> NUMFLOAT .)
    DIVIDE          reduce using rule 63 (varcte -> NUMFLOAT .)
    PLUS            reduce using rule 63 (varcte -> NUMFLOAT .)
    MINUS           reduce using rule 63 (varcte -> NUMFLOAT .)
    COMPARISON      reduce using rule 63 (varcte -> NUMFLOAT .)
    ID              reduce using rule 63 (varcte -> NUMFLOAT .)
    FUNC            reduce using rule 63 (varcte -> NUMFLOAT .)
    MAIN            reduce using rule 63 (varcte -> NUMFLOAT .)
    INT             reduce using rule 63 (varcte -> NUMFLOAT .)
    FLOAT           reduce using rule 63 (varcte -> NUMFLOAT .)
    BOOLEAN         reduce using rule 63 (varcte -> NUMFLOAT .)
    IF              reduce using rule 63 (varcte -> NUMFLOAT .)
    WHILE           reduce using rule 63 (varcte -> NUMFLOAT .)
    PRINT           reduce using rule 63 (varcte -> NUMFLOAT .)
    LIST            reduce using rule 63 (varcte -> NUMFLOAT .)
    CAT             reduce using rule 63 (varcte -> NUMFLOAT .)
    ADD             reduce using rule 63 (varcte -> NUMFLOAT .)
    RETURN          reduce using rule 63 (varcte -> NUMFLOAT .)
    RCBRACKET       reduce using rule 63 (varcte -> NUMFLOAT .)
    RPAR            reduce using rule 63 (varcte -> NUMFLOAT .)
    COMA            reduce using rule 63 (varcte -> NUMFLOAT .)


state 38

    (50) exp -> termino .
    (51) exp -> termino . PLUS op_val exp
    (52) exp -> termino . MINUS op_val exp

  ! shift/reduce conflict for PLUS resolved as shift
    COMPARISON      reduce using rule 50 (exp -> termino .)
    RPAR            reduce using rule 50 (exp -> termino .)
    ID              reduce using rule 50 (exp -> termino .)
    FUNC            reduce using rule 50 (exp -> termino .)
    MAIN            reduce using rule 50 (exp -> termino .)
    INT             reduce using rule 50 (exp -> termino .)
    FLOAT           reduce using rule 50 (exp -> termino .)
    BOOLEAN         reduce using rule 50 (exp -> termino .)
    IF              reduce using rule 50 (exp -> termino .)
    WHILE           reduce using rule 50 (exp -> termino .)
    PRINT           reduce using rule 50 (exp -> termino .)
    LIST            reduce using rule 50 (exp -> termino .)
    CAT             reduce using rule 50 (exp -> termino .)
    ADD             reduce using rule 50 (exp -> termino .)
    RETURN          reduce using rule 50 (exp -> termino .)
    RCBRACKET       reduce using rule 50 (exp -> termino .)
    COMA            reduce using rule 50 (exp -> termino .)
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80

  ! PLUS            [ reduce using rule 50 (exp -> termino .) ]


state 39

    (59) factor -> MINUS . varcte
    (61) varcte -> . ID
    (62) varcte -> . NUMINT
    (63) varcte -> . NUMFLOAT
    (64) varcte -> . BOOLEANTYPE

    ID              shift and go to state 77
    NUMINT          shift and go to state 44
    NUMFLOAT        shift and go to state 37
    BOOLEANTYPE     shift and go to state 47

    varcte                         shift and go to state 81

state 40

    (60) factor -> varcte . termino_val
    (56) termino_val -> .

    MULTIPLY        reduce using rule 56 (termino_val -> .)
    DIVIDE          reduce using rule 56 (termino_val -> .)
    PLUS            reduce using rule 56 (termino_val -> .)
    MINUS           reduce using rule 56 (termino_val -> .)
    COMPARISON      reduce using rule 56 (termino_val -> .)
    ID              reduce using rule 56 (termino_val -> .)
    FUNC            reduce using rule 56 (termino_val -> .)
    MAIN            reduce using rule 56 (termino_val -> .)
    INT             reduce using rule 56 (termino_val -> .)
    FLOAT           reduce using rule 56 (termino_val -> .)
    BOOLEAN         reduce using rule 56 (termino_val -> .)
    IF              reduce using rule 56 (termino_val -> .)
    WHILE           reduce using rule 56 (termino_val -> .)
    PRINT           reduce using rule 56 (termino_val -> .)
    LIST            reduce using rule 56 (termino_val -> .)
    CAT             reduce using rule 56 (termino_val -> .)
    ADD             reduce using rule 56 (termino_val -> .)
    RETURN          reduce using rule 56 (termino_val -> .)
    RCBRACKET       reduce using rule 56 (termino_val -> .)
    RPAR            reduce using rule 56 (termino_val -> .)
    COMA            reduce using rule 56 (termino_val -> .)

    termino_val                    shift and go to state 82

state 41

    (53) termino -> factor .
    (54) termino -> factor . MULTIPLY op_val termino
    (55) termino -> factor . DIVIDE op_val termino

    PLUS            reduce using rule 53 (termino -> factor .)
    MINUS           reduce using rule 53 (termino -> factor .)
    COMPARISON      reduce using rule 53 (termino -> factor .)
    COMA            reduce using rule 53 (termino -> factor .)
    RPAR            reduce using rule 53 (termino -> factor .)
    ID              reduce using rule 53 (termino -> factor .)
    FUNC            reduce using rule 53 (termino -> factor .)
    MAIN            reduce using rule 53 (termino -> factor .)
    INT             reduce using rule 53 (termino -> factor .)
    FLOAT           reduce using rule 53 (termino -> factor .)
    BOOLEAN         reduce using rule 53 (termino -> factor .)
    IF              reduce using rule 53 (termino -> factor .)
    WHILE           reduce using rule 53 (termino -> factor .)
    PRINT           reduce using rule 53 (termino -> factor .)
    LIST            reduce using rule 53 (termino -> factor .)
    CAT             reduce using rule 53 (termino -> factor .)
    ADD             reduce using rule 53 (termino -> factor .)
    RETURN          reduce using rule 53 (termino -> factor .)
    RCBRACKET       reduce using rule 53 (termino -> factor .)
    MULTIPLY        shift and go to state 83
    DIVIDE          shift and go to state 84


state 42

    (44) asign -> ID id_val EQUAL equal_val call .

    INT             reduce using rule 44 (asign -> ID id_val EQUAL equal_val call .)
    FLOAT           reduce using rule 44 (asign -> ID id_val EQUAL equal_val call .)
    BOOLEAN         reduce using rule 44 (asign -> ID id_val EQUAL equal_val call .)
    ID              reduce using rule 44 (asign -> ID id_val EQUAL equal_val call .)
    IF              reduce using rule 44 (asign -> ID id_val EQUAL equal_val call .)
    WHILE           reduce using rule 44 (asign -> ID id_val EQUAL equal_val call .)
    PRINT           reduce using rule 44 (asign -> ID id_val EQUAL equal_val call .)
    LIST            reduce using rule 44 (asign -> ID id_val EQUAL equal_val call .)
    CAT             reduce using rule 44 (asign -> ID id_val EQUAL equal_val call .)
    ADD             reduce using rule 44 (asign -> ID id_val EQUAL equal_val call .)
    RETURN          reduce using rule 44 (asign -> ID id_val EQUAL equal_val call .)
    RCBRACKET       reduce using rule 44 (asign -> ID id_val EQUAL equal_val call .)
    FUNC            reduce using rule 44 (asign -> ID id_val EQUAL equal_val call .)
    MAIN            reduce using rule 44 (asign -> ID id_val EQUAL equal_val call .)


state 43

    (105) call -> ID . id_call LPAR par_call RPAR par_call2
    (106) call -> ID . id_call LPAR par_call params RPAR par_call2
    (101) remove -> ID . idCheck_Remove POINT REMOVE LPAR RPAR
    (61) varcte -> ID .
    (107) id_call -> .
    (102) idCheck_Remove -> .

    MULTIPLY        reduce using rule 61 (varcte -> ID .)
    DIVIDE          reduce using rule 61 (varcte -> ID .)
    PLUS            reduce using rule 61 (varcte -> ID .)
    MINUS           reduce using rule 61 (varcte -> ID .)
    COMPARISON      reduce using rule 61 (varcte -> ID .)
    ID              reduce using rule 61 (varcte -> ID .)
    FUNC            reduce using rule 61 (varcte -> ID .)
    MAIN            reduce using rule 61 (varcte -> ID .)
    INT             reduce using rule 61 (varcte -> ID .)
    FLOAT           reduce using rule 61 (varcte -> ID .)
    BOOLEAN         reduce using rule 61 (varcte -> ID .)
    IF              reduce using rule 61 (varcte -> ID .)
    WHILE           reduce using rule 61 (varcte -> ID .)
    PRINT           reduce using rule 61 (varcte -> ID .)
    LIST            reduce using rule 61 (varcte -> ID .)
    CAT             reduce using rule 61 (varcte -> ID .)
    ADD             reduce using rule 61 (varcte -> ID .)
    RETURN          reduce using rule 61 (varcte -> ID .)
    RCBRACKET       reduce using rule 61 (varcte -> ID .)
    LPAR            reduce using rule 107 (id_call -> .)
    POINT           reduce using rule 102 (idCheck_Remove -> .)

    id_call                        shift and go to state 86
    idCheck_Remove                 shift and go to state 85

state 44

    (62) varcte -> NUMINT .

    MULTIPLY        reduce using rule 62 (varcte -> NUMINT .)
    DIVIDE          reduce using rule 62 (varcte -> NUMINT .)
    PLUS            reduce using rule 62 (varcte -> NUMINT .)
    MINUS           reduce using rule 62 (varcte -> NUMINT .)
    COMPARISON      reduce using rule 62 (varcte -> NUMINT .)
    ID              reduce using rule 62 (varcte -> NUMINT .)
    FUNC            reduce using rule 62 (varcte -> NUMINT .)
    MAIN            reduce using rule 62 (varcte -> NUMINT .)
    INT             reduce using rule 62 (varcte -> NUMINT .)
    FLOAT           reduce using rule 62 (varcte -> NUMINT .)
    BOOLEAN         reduce using rule 62 (varcte -> NUMINT .)
    IF              reduce using rule 62 (varcte -> NUMINT .)
    WHILE           reduce using rule 62 (varcte -> NUMINT .)
    PRINT           reduce using rule 62 (varcte -> NUMINT .)
    LIST            reduce using rule 62 (varcte -> NUMINT .)
    CAT             reduce using rule 62 (varcte -> NUMINT .)
    ADD             reduce using rule 62 (varcte -> NUMINT .)
    RETURN          reduce using rule 62 (varcte -> NUMINT .)
    RCBRACKET       reduce using rule 62 (varcte -> NUMINT .)
    RPAR            reduce using rule 62 (varcte -> NUMINT .)
    COMA            reduce using rule 62 (varcte -> NUMINT .)


state 45

    (45) asign -> ID id_val EQUAL equal_val remove .

    INT             reduce using rule 45 (asign -> ID id_val EQUAL equal_val remove .)
    FLOAT           reduce using rule 45 (asign -> ID id_val EQUAL equal_val remove .)
    BOOLEAN         reduce using rule 45 (asign -> ID id_val EQUAL equal_val remove .)
    ID              reduce using rule 45 (asign -> ID id_val EQUAL equal_val remove .)
    IF              reduce using rule 45 (asign -> ID id_val EQUAL equal_val remove .)
    WHILE           reduce using rule 45 (asign -> ID id_val EQUAL equal_val remove .)
    PRINT           reduce using rule 45 (asign -> ID id_val EQUAL equal_val remove .)
    LIST            reduce using rule 45 (asign -> ID id_val EQUAL equal_val remove .)
    CAT             reduce using rule 45 (asign -> ID id_val EQUAL equal_val remove .)
    ADD             reduce using rule 45 (asign -> ID id_val EQUAL equal_val remove .)
    RETURN          reduce using rule 45 (asign -> ID id_val EQUAL equal_val remove .)
    RCBRACKET       reduce using rule 45 (asign -> ID id_val EQUAL equal_val remove .)
    FUNC            reduce using rule 45 (asign -> ID id_val EQUAL equal_val remove .)
    MAIN            reduce using rule 45 (asign -> ID id_val EQUAL equal_val remove .)


state 46

    (48) expression -> exp .
    (49) expression -> exp . COMPARISON op_val expression

    ID              reduce using rule 48 (expression -> exp .)
    FUNC            reduce using rule 48 (expression -> exp .)
    MAIN            reduce using rule 48 (expression -> exp .)
    INT             reduce using rule 48 (expression -> exp .)
    FLOAT           reduce using rule 48 (expression -> exp .)
    BOOLEAN         reduce using rule 48 (expression -> exp .)
    IF              reduce using rule 48 (expression -> exp .)
    WHILE           reduce using rule 48 (expression -> exp .)
    PRINT           reduce using rule 48 (expression -> exp .)
    LIST            reduce using rule 48 (expression -> exp .)
    CAT             reduce using rule 48 (expression -> exp .)
    ADD             reduce using rule 48 (expression -> exp .)
    RETURN          reduce using rule 48 (expression -> exp .)
    RCBRACKET       reduce using rule 48 (expression -> exp .)
    RPAR            reduce using rule 48 (expression -> exp .)
    PLUS            reduce using rule 48 (expression -> exp .)
    COMA            reduce using rule 48 (expression -> exp .)
    COMPARISON      shift and go to state 87


state 47

    (64) varcte -> BOOLEANTYPE .

    MULTIPLY        reduce using rule 64 (varcte -> BOOLEANTYPE .)
    DIVIDE          reduce using rule 64 (varcte -> BOOLEANTYPE .)
    PLUS            reduce using rule 64 (varcte -> BOOLEANTYPE .)
    MINUS           reduce using rule 64 (varcte -> BOOLEANTYPE .)
    COMPARISON      reduce using rule 64 (varcte -> BOOLEANTYPE .)
    ID              reduce using rule 64 (varcte -> BOOLEANTYPE .)
    FUNC            reduce using rule 64 (varcte -> BOOLEANTYPE .)
    MAIN            reduce using rule 64 (varcte -> BOOLEANTYPE .)
    INT             reduce using rule 64 (varcte -> BOOLEANTYPE .)
    FLOAT           reduce using rule 64 (varcte -> BOOLEANTYPE .)
    BOOLEAN         reduce using rule 64 (varcte -> BOOLEANTYPE .)
    IF              reduce using rule 64 (varcte -> BOOLEANTYPE .)
    WHILE           reduce using rule 64 (varcte -> BOOLEANTYPE .)
    PRINT           reduce using rule 64 (varcte -> BOOLEANTYPE .)
    LIST            reduce using rule 64 (varcte -> BOOLEANTYPE .)
    CAT             reduce using rule 64 (varcte -> BOOLEANTYPE .)
    ADD             reduce using rule 64 (varcte -> BOOLEANTYPE .)
    RETURN          reduce using rule 64 (varcte -> BOOLEANTYPE .)
    RCBRACKET       reduce using rule 64 (varcte -> BOOLEANTYPE .)
    RPAR            reduce using rule 64 (varcte -> BOOLEANTYPE .)
    COMA            reduce using rule 64 (varcte -> BOOLEANTYPE .)


state 48

    (43) asign -> ID id_val EQUAL equal_val expression .

    INT             reduce using rule 43 (asign -> ID id_val EQUAL equal_val expression .)
    FLOAT           reduce using rule 43 (asign -> ID id_val EQUAL equal_val expression .)
    BOOLEAN         reduce using rule 43 (asign -> ID id_val EQUAL equal_val expression .)
    ID              reduce using rule 43 (asign -> ID id_val EQUAL equal_val expression .)
    IF              reduce using rule 43 (asign -> ID id_val EQUAL equal_val expression .)
    WHILE           reduce using rule 43 (asign -> ID id_val EQUAL equal_val expression .)
    PRINT           reduce using rule 43 (asign -> ID id_val EQUAL equal_val expression .)
    LIST            reduce using rule 43 (asign -> ID id_val EQUAL equal_val expression .)
    CAT             reduce using rule 43 (asign -> ID id_val EQUAL equal_val expression .)
    ADD             reduce using rule 43 (asign -> ID id_val EQUAL equal_val expression .)
    RETURN          reduce using rule 43 (asign -> ID id_val EQUAL equal_val expression .)
    RCBRACKET       reduce using rule 43 (asign -> ID id_val EQUAL equal_val expression .)
    FUNC            reduce using rule 43 (asign -> ID id_val EQUAL equal_val expression .)
    MAIN            reduce using rule 43 (asign -> ID id_val EQUAL equal_val expression .)


state 49

    (13) funcx -> vars paramCheck .
    (14) funcx -> vars paramCheck . COMA funcx

    RPAR            reduce using rule 13 (funcx -> vars paramCheck .)
    COMA            shift and go to state 88


state 50

    (10) func -> FUNC idCheck LPAR funcx RPAR . block func_end
    (17) block -> . LCBRACKET blockx RCBRACKET

    LCBRACKET       shift and go to state 34

    block                          shift and go to state 89

state 51

    (39) vars -> type ID .

    COMA            reduce using rule 39 (vars -> type ID .)
    RPAR            reduce using rule 39 (vars -> type ID .)
    INT             reduce using rule 39 (vars -> type ID .)
    FLOAT           reduce using rule 39 (vars -> type ID .)
    BOOLEAN         reduce using rule 39 (vars -> type ID .)
    ID              reduce using rule 39 (vars -> type ID .)
    IF              reduce using rule 39 (vars -> type ID .)
    WHILE           reduce using rule 39 (vars -> type ID .)
    PRINT           reduce using rule 39 (vars -> type ID .)
    LIST            reduce using rule 39 (vars -> type ID .)
    CAT             reduce using rule 39 (vars -> type ID .)
    ADD             reduce using rule 39 (vars -> type ID .)
    RETURN          reduce using rule 39 (vars -> type ID .)
    RCBRACKET       reduce using rule 39 (vars -> type ID .)


state 52

    (36) return -> RETURN . LPAR par_call expression RPAR par_call2
    (37) return -> RETURN . LPAR par_call call RPAR par_call2

    LPAR            shift and go to state 90


state 53

    (18) blockx -> vars .
    (19) blockx -> vars . blockx
    (18) blockx -> . vars
    (19) blockx -> . vars blockx
    (20) blockx -> . statement
    (21) blockx -> . statement blockx
    (39) vars -> . type ID
    (22) statement -> . asign
    (23) statement -> . condition
    (24) statement -> . cycle
    (25) statement -> . print
    (26) statement -> . list
    (27) statement -> . call
    (28) statement -> . add
    (29) statement -> . find
    (30) statement -> . printList
    (31) statement -> . move
    (32) statement -> . toy
    (33) statement -> . clean
    (34) statement -> . play
    (35) statement -> . return
    (40) type -> . INT
    (41) type -> . FLOAT
    (42) type -> . BOOLEAN
    (43) asign -> . ID id_val EQUAL equal_val expression
    (44) asign -> . ID id_val EQUAL equal_val call
    (45) asign -> . ID id_val EQUAL equal_val remove
    (77) condition -> . IF LPAR expression RPAR cond_1 block else cond_2
    (78) condition -> . IF LPAR vaciaList RPAR cond_1 block else cond_2
    (72) cycle -> . WHILE cycle_1 LPAR expression RPAR cycle_2 block cycle_3
    (73) cycle -> . WHILE cycle_1 LPAR vaciaList RPAR cycle_2 block cycle_3
    (65) print -> . PRINT LPAR par_call printx RPAR par_call2
    (85) list -> . LIST idCheck_List EQUAL LBRACKET listx RBRACKET
    (105) call -> . ID id_call LPAR par_call RPAR par_call2
    (106) call -> . ID id_call LPAR par_call params RPAR par_call2
    (99) add -> . ID idCheck_Add POINT ADD LPAR listx_add RPAR
    (103) find -> . ID idCheck_Add POINT FIND LPAR NUMINT RPAR
    (104) printList -> . ID idCheck_Add POINT PRINTLIST LPAR RPAR
    (114) move -> . CAT POINT MOVE LPAR NUMINT COMA NUMINT RPAR
    (115) toy -> . ADD POINT TOY LPAR RPAR
    (116) clean -> . CAT POINT CLEAN LPAR RPAR
    (117) play -> . CAT POINT PLAY LPAR RPAR
    (36) return -> . RETURN LPAR par_call expression RPAR par_call2
    (37) return -> . RETURN LPAR par_call call RPAR par_call2

    RCBRACKET       reduce using rule 18 (blockx -> vars .)
    INT             shift and go to state 4
    FLOAT           shift and go to state 5
    BOOLEAN         shift and go to state 6
    ID              shift and go to state 71
    IF              shift and go to state 65
    WHILE           shift and go to state 56
    PRINT           shift and go to state 57
    LIST            shift and go to state 59
    CAT             shift and go to state 70
    ADD             shift and go to state 69
    RETURN          shift and go to state 52

    vars                           shift and go to state 53
    move                           shift and go to state 54
    printList                      shift and go to state 55
    toy                            shift and go to state 60
    find                           shift and go to state 58
    add                            shift and go to state 61
    call                           shift and go to state 62
    statement                      shift and go to state 63
    print                          shift and go to state 64
    type                           shift and go to state 33
    play                           shift and go to state 66
    return                         shift and go to state 67
    blockx                         shift and go to state 91
    condition                      shift and go to state 72
    cycle                          shift and go to state 73
    list                           shift and go to state 74
    asign                          shift and go to state 75
    clean                          shift and go to state 76

state 54

    (31) statement -> move .

    INT             reduce using rule 31 (statement -> move .)
    FLOAT           reduce using rule 31 (statement -> move .)
    BOOLEAN         reduce using rule 31 (statement -> move .)
    ID              reduce using rule 31 (statement -> move .)
    IF              reduce using rule 31 (statement -> move .)
    WHILE           reduce using rule 31 (statement -> move .)
    PRINT           reduce using rule 31 (statement -> move .)
    LIST            reduce using rule 31 (statement -> move .)
    CAT             reduce using rule 31 (statement -> move .)
    ADD             reduce using rule 31 (statement -> move .)
    RETURN          reduce using rule 31 (statement -> move .)
    RCBRACKET       reduce using rule 31 (statement -> move .)


state 55

    (30) statement -> printList .

    INT             reduce using rule 30 (statement -> printList .)
    FLOAT           reduce using rule 30 (statement -> printList .)
    BOOLEAN         reduce using rule 30 (statement -> printList .)
    ID              reduce using rule 30 (statement -> printList .)
    IF              reduce using rule 30 (statement -> printList .)
    WHILE           reduce using rule 30 (statement -> printList .)
    PRINT           reduce using rule 30 (statement -> printList .)
    LIST            reduce using rule 30 (statement -> printList .)
    CAT             reduce using rule 30 (statement -> printList .)
    ADD             reduce using rule 30 (statement -> printList .)
    RETURN          reduce using rule 30 (statement -> printList .)
    RCBRACKET       reduce using rule 30 (statement -> printList .)


state 56

    (72) cycle -> WHILE . cycle_1 LPAR expression RPAR cycle_2 block cycle_3
    (73) cycle -> WHILE . cycle_1 LPAR vaciaList RPAR cycle_2 block cycle_3
    (74) cycle_1 -> .

    LPAR            reduce using rule 74 (cycle_1 -> .)

    cycle_1                        shift and go to state 92

state 57

    (65) print -> PRINT . LPAR par_call printx RPAR par_call2

    LPAR            shift and go to state 93


state 58

    (29) statement -> find .

    INT             reduce using rule 29 (statement -> find .)
    FLOAT           reduce using rule 29 (statement -> find .)
    BOOLEAN         reduce using rule 29 (statement -> find .)
    ID              reduce using rule 29 (statement -> find .)
    IF              reduce using rule 29 (statement -> find .)
    WHILE           reduce using rule 29 (statement -> find .)
    PRINT           reduce using rule 29 (statement -> find .)
    LIST            reduce using rule 29 (statement -> find .)
    CAT             reduce using rule 29 (statement -> find .)
    ADD             reduce using rule 29 (statement -> find .)
    RETURN          reduce using rule 29 (statement -> find .)
    RCBRACKET       reduce using rule 29 (statement -> find .)


state 59

    (85) list -> LIST . idCheck_List EQUAL LBRACKET listx RBRACKET
    (93) idCheck_List -> . ID

    ID              shift and go to state 95

    idCheck_List                   shift and go to state 94

state 60

    (32) statement -> toy .

    INT             reduce using rule 32 (statement -> toy .)
    FLOAT           reduce using rule 32 (statement -> toy .)
    BOOLEAN         reduce using rule 32 (statement -> toy .)
    ID              reduce using rule 32 (statement -> toy .)
    IF              reduce using rule 32 (statement -> toy .)
    WHILE           reduce using rule 32 (statement -> toy .)
    PRINT           reduce using rule 32 (statement -> toy .)
    LIST            reduce using rule 32 (statement -> toy .)
    CAT             reduce using rule 32 (statement -> toy .)
    ADD             reduce using rule 32 (statement -> toy .)
    RETURN          reduce using rule 32 (statement -> toy .)
    RCBRACKET       reduce using rule 32 (statement -> toy .)


state 61

    (28) statement -> add .

    INT             reduce using rule 28 (statement -> add .)
    FLOAT           reduce using rule 28 (statement -> add .)
    BOOLEAN         reduce using rule 28 (statement -> add .)
    ID              reduce using rule 28 (statement -> add .)
    IF              reduce using rule 28 (statement -> add .)
    WHILE           reduce using rule 28 (statement -> add .)
    PRINT           reduce using rule 28 (statement -> add .)
    LIST            reduce using rule 28 (statement -> add .)
    CAT             reduce using rule 28 (statement -> add .)
    ADD             reduce using rule 28 (statement -> add .)
    RETURN          reduce using rule 28 (statement -> add .)
    RCBRACKET       reduce using rule 28 (statement -> add .)


state 62

    (27) statement -> call .

    INT             reduce using rule 27 (statement -> call .)
    FLOAT           reduce using rule 27 (statement -> call .)
    BOOLEAN         reduce using rule 27 (statement -> call .)
    ID              reduce using rule 27 (statement -> call .)
    IF              reduce using rule 27 (statement -> call .)
    WHILE           reduce using rule 27 (statement -> call .)
    PRINT           reduce using rule 27 (statement -> call .)
    LIST            reduce using rule 27 (statement -> call .)
    CAT             reduce using rule 27 (statement -> call .)
    ADD             reduce using rule 27 (statement -> call .)
    RETURN          reduce using rule 27 (statement -> call .)
    RCBRACKET       reduce using rule 27 (statement -> call .)


state 63

    (20) blockx -> statement .
    (21) blockx -> statement . blockx
    (18) blockx -> . vars
    (19) blockx -> . vars blockx
    (20) blockx -> . statement
    (21) blockx -> . statement blockx
    (39) vars -> . type ID
    (22) statement -> . asign
    (23) statement -> . condition
    (24) statement -> . cycle
    (25) statement -> . print
    (26) statement -> . list
    (27) statement -> . call
    (28) statement -> . add
    (29) statement -> . find
    (30) statement -> . printList
    (31) statement -> . move
    (32) statement -> . toy
    (33) statement -> . clean
    (34) statement -> . play
    (35) statement -> . return
    (40) type -> . INT
    (41) type -> . FLOAT
    (42) type -> . BOOLEAN
    (43) asign -> . ID id_val EQUAL equal_val expression
    (44) asign -> . ID id_val EQUAL equal_val call
    (45) asign -> . ID id_val EQUAL equal_val remove
    (77) condition -> . IF LPAR expression RPAR cond_1 block else cond_2
    (78) condition -> . IF LPAR vaciaList RPAR cond_1 block else cond_2
    (72) cycle -> . WHILE cycle_1 LPAR expression RPAR cycle_2 block cycle_3
    (73) cycle -> . WHILE cycle_1 LPAR vaciaList RPAR cycle_2 block cycle_3
    (65) print -> . PRINT LPAR par_call printx RPAR par_call2
    (85) list -> . LIST idCheck_List EQUAL LBRACKET listx RBRACKET
    (105) call -> . ID id_call LPAR par_call RPAR par_call2
    (106) call -> . ID id_call LPAR par_call params RPAR par_call2
    (99) add -> . ID idCheck_Add POINT ADD LPAR listx_add RPAR
    (103) find -> . ID idCheck_Add POINT FIND LPAR NUMINT RPAR
    (104) printList -> . ID idCheck_Add POINT PRINTLIST LPAR RPAR
    (114) move -> . CAT POINT MOVE LPAR NUMINT COMA NUMINT RPAR
    (115) toy -> . ADD POINT TOY LPAR RPAR
    (116) clean -> . CAT POINT CLEAN LPAR RPAR
    (117) play -> . CAT POINT PLAY LPAR RPAR
    (36) return -> . RETURN LPAR par_call expression RPAR par_call2
    (37) return -> . RETURN LPAR par_call call RPAR par_call2

    RCBRACKET       reduce using rule 20 (blockx -> statement .)
    INT             shift and go to state 4
    FLOAT           shift and go to state 5
    BOOLEAN         shift and go to state 6
    ID              shift and go to state 71
    IF              shift and go to state 65
    WHILE           shift and go to state 56
    PRINT           shift and go to state 57
    LIST            shift and go to state 59
    CAT             shift and go to state 70
    ADD             shift and go to state 69
    RETURN          shift and go to state 52

    vars                           shift and go to state 53
    move                           shift and go to state 54
    printList                      shift and go to state 55
    toy                            shift and go to state 60
    find                           shift and go to state 58
    add                            shift and go to state 61
    call                           shift and go to state 62
    statement                      shift and go to state 63
    print                          shift and go to state 64
    type                           shift and go to state 33
    play                           shift and go to state 66
    return                         shift and go to state 67
    blockx                         shift and go to state 96
    condition                      shift and go to state 72
    cycle                          shift and go to state 73
    list                           shift and go to state 74
    asign                          shift and go to state 75
    clean                          shift and go to state 76

state 64

    (25) statement -> print .

    INT             reduce using rule 25 (statement -> print .)
    FLOAT           reduce using rule 25 (statement -> print .)
    BOOLEAN         reduce using rule 25 (statement -> print .)
    ID              reduce using rule 25 (statement -> print .)
    IF              reduce using rule 25 (statement -> print .)
    WHILE           reduce using rule 25 (statement -> print .)
    PRINT           reduce using rule 25 (statement -> print .)
    LIST            reduce using rule 25 (statement -> print .)
    CAT             reduce using rule 25 (statement -> print .)
    ADD             reduce using rule 25 (statement -> print .)
    RETURN          reduce using rule 25 (statement -> print .)
    RCBRACKET       reduce using rule 25 (statement -> print .)


state 65

    (77) condition -> IF . LPAR expression RPAR cond_1 block else cond_2
    (78) condition -> IF . LPAR vaciaList RPAR cond_1 block else cond_2

    LPAR            shift and go to state 97


state 66

    (34) statement -> play .

    INT             reduce using rule 34 (statement -> play .)
    FLOAT           reduce using rule 34 (statement -> play .)
    BOOLEAN         reduce using rule 34 (statement -> play .)
    ID              reduce using rule 34 (statement -> play .)
    IF              reduce using rule 34 (statement -> play .)
    WHILE           reduce using rule 34 (statement -> play .)
    PRINT           reduce using rule 34 (statement -> play .)
    LIST            reduce using rule 34 (statement -> play .)
    CAT             reduce using rule 34 (statement -> play .)
    ADD             reduce using rule 34 (statement -> play .)
    RETURN          reduce using rule 34 (statement -> play .)
    RCBRACKET       reduce using rule 34 (statement -> play .)


state 67

    (35) statement -> return .

    INT             reduce using rule 35 (statement -> return .)
    FLOAT           reduce using rule 35 (statement -> return .)
    BOOLEAN         reduce using rule 35 (statement -> return .)
    ID              reduce using rule 35 (statement -> return .)
    IF              reduce using rule 35 (statement -> return .)
    WHILE           reduce using rule 35 (statement -> return .)
    PRINT           reduce using rule 35 (statement -> return .)
    LIST            reduce using rule 35 (statement -> return .)
    CAT             reduce using rule 35 (statement -> return .)
    ADD             reduce using rule 35 (statement -> return .)
    RETURN          reduce using rule 35 (statement -> return .)
    RCBRACKET       reduce using rule 35 (statement -> return .)


state 68

    (17) block -> LCBRACKET blockx . RCBRACKET

    RCBRACKET       shift and go to state 98


state 69

    (115) toy -> ADD . POINT TOY LPAR RPAR

    POINT           shift and go to state 99


state 70

    (114) move -> CAT . POINT MOVE LPAR NUMINT COMA NUMINT RPAR
    (116) clean -> CAT . POINT CLEAN LPAR RPAR
    (117) play -> CAT . POINT PLAY LPAR RPAR

    POINT           shift and go to state 100


state 71

    (43) asign -> ID . id_val EQUAL equal_val expression
    (44) asign -> ID . id_val EQUAL equal_val call
    (45) asign -> ID . id_val EQUAL equal_val remove
    (105) call -> ID . id_call LPAR par_call RPAR par_call2
    (106) call -> ID . id_call LPAR par_call params RPAR par_call2
    (99) add -> ID . idCheck_Add POINT ADD LPAR listx_add RPAR
    (103) find -> ID . idCheck_Add POINT FIND LPAR NUMINT RPAR
    (104) printList -> ID . idCheck_Add POINT PRINTLIST LPAR RPAR
    (46) id_val -> .
    (107) id_call -> .
    (100) idCheck_Add -> .

    EQUAL           reduce using rule 46 (id_val -> .)
    LPAR            reduce using rule 107 (id_call -> .)
    POINT           reduce using rule 100 (idCheck_Add -> .)

    idCheck_Add                    shift and go to state 101
    id_call                        shift and go to state 86
    id_val                         shift and go to state 21

state 72

    (23) statement -> condition .

    INT             reduce using rule 23 (statement -> condition .)
    FLOAT           reduce using rule 23 (statement -> condition .)
    BOOLEAN         reduce using rule 23 (statement -> condition .)
    ID              reduce using rule 23 (statement -> condition .)
    IF              reduce using rule 23 (statement -> condition .)
    WHILE           reduce using rule 23 (statement -> condition .)
    PRINT           reduce using rule 23 (statement -> condition .)
    LIST            reduce using rule 23 (statement -> condition .)
    CAT             reduce using rule 23 (statement -> condition .)
    ADD             reduce using rule 23 (statement -> condition .)
    RETURN          reduce using rule 23 (statement -> condition .)
    RCBRACKET       reduce using rule 23 (statement -> condition .)


state 73

    (24) statement -> cycle .

    INT             reduce using rule 24 (statement -> cycle .)
    FLOAT           reduce using rule 24 (statement -> cycle .)
    BOOLEAN         reduce using rule 24 (statement -> cycle .)
    ID              reduce using rule 24 (statement -> cycle .)
    IF              reduce using rule 24 (statement -> cycle .)
    WHILE           reduce using rule 24 (statement -> cycle .)
    PRINT           reduce using rule 24 (statement -> cycle .)
    LIST            reduce using rule 24 (statement -> cycle .)
    CAT             reduce using rule 24 (statement -> cycle .)
    ADD             reduce using rule 24 (statement -> cycle .)
    RETURN          reduce using rule 24 (statement -> cycle .)
    RCBRACKET       reduce using rule 24 (statement -> cycle .)


state 74

    (26) statement -> list .

    INT             reduce using rule 26 (statement -> list .)
    FLOAT           reduce using rule 26 (statement -> list .)
    BOOLEAN         reduce using rule 26 (statement -> list .)
    ID              reduce using rule 26 (statement -> list .)
    IF              reduce using rule 26 (statement -> list .)
    WHILE           reduce using rule 26 (statement -> list .)
    PRINT           reduce using rule 26 (statement -> list .)
    LIST            reduce using rule 26 (statement -> list .)
    CAT             reduce using rule 26 (statement -> list .)
    ADD             reduce using rule 26 (statement -> list .)
    RETURN          reduce using rule 26 (statement -> list .)
    RCBRACKET       reduce using rule 26 (statement -> list .)


state 75

    (22) statement -> asign .

    INT             reduce using rule 22 (statement -> asign .)
    FLOAT           reduce using rule 22 (statement -> asign .)
    BOOLEAN         reduce using rule 22 (statement -> asign .)
    ID              reduce using rule 22 (statement -> asign .)
    IF              reduce using rule 22 (statement -> asign .)
    WHILE           reduce using rule 22 (statement -> asign .)
    PRINT           reduce using rule 22 (statement -> asign .)
    LIST            reduce using rule 22 (statement -> asign .)
    CAT             reduce using rule 22 (statement -> asign .)
    ADD             reduce using rule 22 (statement -> asign .)
    RETURN          reduce using rule 22 (statement -> asign .)
    RCBRACKET       reduce using rule 22 (statement -> asign .)


state 76

    (33) statement -> clean .

    INT             reduce using rule 33 (statement -> clean .)
    FLOAT           reduce using rule 33 (statement -> clean .)
    BOOLEAN         reduce using rule 33 (statement -> clean .)
    ID              reduce using rule 33 (statement -> clean .)
    IF              reduce using rule 33 (statement -> clean .)
    WHILE           reduce using rule 33 (statement -> clean .)
    PRINT           reduce using rule 33 (statement -> clean .)
    LIST            reduce using rule 33 (statement -> clean .)
    CAT             reduce using rule 33 (statement -> clean .)
    ADD             reduce using rule 33 (statement -> clean .)
    RETURN          reduce using rule 33 (statement -> clean .)
    RCBRACKET       reduce using rule 33 (statement -> clean .)


state 77

    (61) varcte -> ID .

    MULTIPLY        reduce using rule 61 (varcte -> ID .)
    DIVIDE          reduce using rule 61 (varcte -> ID .)
    PLUS            reduce using rule 61 (varcte -> ID .)
    MINUS           reduce using rule 61 (varcte -> ID .)
    COMPARISON      reduce using rule 61 (varcte -> ID .)
    ID              reduce using rule 61 (varcte -> ID .)
    FUNC            reduce using rule 61 (varcte -> ID .)
    MAIN            reduce using rule 61 (varcte -> ID .)
    INT             reduce using rule 61 (varcte -> ID .)
    FLOAT           reduce using rule 61 (varcte -> ID .)
    BOOLEAN         reduce using rule 61 (varcte -> ID .)
    IF              reduce using rule 61 (varcte -> ID .)
    WHILE           reduce using rule 61 (varcte -> ID .)
    PRINT           reduce using rule 61 (varcte -> ID .)
    LIST            reduce using rule 61 (varcte -> ID .)
    CAT             reduce using rule 61 (varcte -> ID .)
    ADD             reduce using rule 61 (varcte -> ID .)
    RETURN          reduce using rule 61 (varcte -> ID .)
    RCBRACKET       reduce using rule 61 (varcte -> ID .)
    RPAR            reduce using rule 61 (varcte -> ID .)
    COMA            reduce using rule 61 (varcte -> ID .)


state 78

    (58) factor -> LPAR expression . RPAR

    RPAR            shift and go to state 102


state 79

    (51) exp -> termino PLUS . op_val exp
    (57) op_val -> .

    LPAR            reduce using rule 57 (op_val -> .)
    MINUS           reduce using rule 57 (op_val -> .)
    ID              reduce using rule 57 (op_val -> .)
    NUMINT          reduce using rule 57 (op_val -> .)
    NUMFLOAT        reduce using rule 57 (op_val -> .)
    BOOLEANTYPE     reduce using rule 57 (op_val -> .)

    op_val                         shift and go to state 103

state 80

    (52) exp -> termino MINUS . op_val exp
    (57) op_val -> .

    LPAR            reduce using rule 57 (op_val -> .)
    MINUS           reduce using rule 57 (op_val -> .)
    ID              reduce using rule 57 (op_val -> .)
    NUMINT          reduce using rule 57 (op_val -> .)
    NUMFLOAT        reduce using rule 57 (op_val -> .)
    BOOLEANTYPE     reduce using rule 57 (op_val -> .)

    op_val                         shift and go to state 104

state 81

    (59) factor -> MINUS varcte .

    MULTIPLY        reduce using rule 59 (factor -> MINUS varcte .)
    DIVIDE          reduce using rule 59 (factor -> MINUS varcte .)
    PLUS            reduce using rule 59 (factor -> MINUS varcte .)
    MINUS           reduce using rule 59 (factor -> MINUS varcte .)
    COMPARISON      reduce using rule 59 (factor -> MINUS varcte .)
    ID              reduce using rule 59 (factor -> MINUS varcte .)
    FUNC            reduce using rule 59 (factor -> MINUS varcte .)
    MAIN            reduce using rule 59 (factor -> MINUS varcte .)
    INT             reduce using rule 59 (factor -> MINUS varcte .)
    FLOAT           reduce using rule 59 (factor -> MINUS varcte .)
    BOOLEAN         reduce using rule 59 (factor -> MINUS varcte .)
    IF              reduce using rule 59 (factor -> MINUS varcte .)
    WHILE           reduce using rule 59 (factor -> MINUS varcte .)
    PRINT           reduce using rule 59 (factor -> MINUS varcte .)
    LIST            reduce using rule 59 (factor -> MINUS varcte .)
    CAT             reduce using rule 59 (factor -> MINUS varcte .)
    ADD             reduce using rule 59 (factor -> MINUS varcte .)
    RETURN          reduce using rule 59 (factor -> MINUS varcte .)
    RCBRACKET       reduce using rule 59 (factor -> MINUS varcte .)
    RPAR            reduce using rule 59 (factor -> MINUS varcte .)
    COMA            reduce using rule 59 (factor -> MINUS varcte .)


state 82

    (60) factor -> varcte termino_val .

    MULTIPLY        reduce using rule 60 (factor -> varcte termino_val .)
    DIVIDE          reduce using rule 60 (factor -> varcte termino_val .)
    PLUS            reduce using rule 60 (factor -> varcte termino_val .)
    MINUS           reduce using rule 60 (factor -> varcte termino_val .)
    COMPARISON      reduce using rule 60 (factor -> varcte termino_val .)
    ID              reduce using rule 60 (factor -> varcte termino_val .)
    FUNC            reduce using rule 60 (factor -> varcte termino_val .)
    MAIN            reduce using rule 60 (factor -> varcte termino_val .)
    INT             reduce using rule 60 (factor -> varcte termino_val .)
    FLOAT           reduce using rule 60 (factor -> varcte termino_val .)
    BOOLEAN         reduce using rule 60 (factor -> varcte termino_val .)
    IF              reduce using rule 60 (factor -> varcte termino_val .)
    WHILE           reduce using rule 60 (factor -> varcte termino_val .)
    PRINT           reduce using rule 60 (factor -> varcte termino_val .)
    LIST            reduce using rule 60 (factor -> varcte termino_val .)
    CAT             reduce using rule 60 (factor -> varcte termino_val .)
    ADD             reduce using rule 60 (factor -> varcte termino_val .)
    RETURN          reduce using rule 60 (factor -> varcte termino_val .)
    RCBRACKET       reduce using rule 60 (factor -> varcte termino_val .)
    RPAR            reduce using rule 60 (factor -> varcte termino_val .)
    COMA            reduce using rule 60 (factor -> varcte termino_val .)


state 83

    (54) termino -> factor MULTIPLY . op_val termino
    (57) op_val -> .

    LPAR            reduce using rule 57 (op_val -> .)
    MINUS           reduce using rule 57 (op_val -> .)
    ID              reduce using rule 57 (op_val -> .)
    NUMINT          reduce using rule 57 (op_val -> .)
    NUMFLOAT        reduce using rule 57 (op_val -> .)
    BOOLEANTYPE     reduce using rule 57 (op_val -> .)

    op_val                         shift and go to state 105

state 84

    (55) termino -> factor DIVIDE . op_val termino
    (57) op_val -> .

    LPAR            reduce using rule 57 (op_val -> .)
    MINUS           reduce using rule 57 (op_val -> .)
    ID              reduce using rule 57 (op_val -> .)
    NUMINT          reduce using rule 57 (op_val -> .)
    NUMFLOAT        reduce using rule 57 (op_val -> .)
    BOOLEANTYPE     reduce using rule 57 (op_val -> .)

    op_val                         shift and go to state 106

state 85

    (101) remove -> ID idCheck_Remove . POINT REMOVE LPAR RPAR

    POINT           shift and go to state 107


state 86

    (105) call -> ID id_call . LPAR par_call RPAR par_call2
    (106) call -> ID id_call . LPAR par_call params RPAR par_call2

    LPAR            shift and go to state 108


state 87

    (49) expression -> exp COMPARISON . op_val expression
    (57) op_val -> .

    LPAR            reduce using rule 57 (op_val -> .)
    MINUS           reduce using rule 57 (op_val -> .)
    ID              reduce using rule 57 (op_val -> .)
    NUMINT          reduce using rule 57 (op_val -> .)
    NUMFLOAT        reduce using rule 57 (op_val -> .)
    BOOLEANTYPE     reduce using rule 57 (op_val -> .)

    op_val                         shift and go to state 109

state 88

    (14) funcx -> vars paramCheck COMA . funcx
    (13) funcx -> . vars paramCheck
    (14) funcx -> . vars paramCheck COMA funcx
    (15) funcx -> . empty
    (39) vars -> . type ID
    (118) empty -> .
    (40) type -> . INT
    (41) type -> . FLOAT
    (42) type -> . BOOLEAN

    RPAR            reduce using rule 118 (empty -> .)
    INT             shift and go to state 4
    FLOAT           shift and go to state 5
    BOOLEAN         shift and go to state 6

    funcx                          shift and go to state 110
    type                           shift and go to state 33
    empty                          shift and go to state 32
    vars                           shift and go to state 30

state 89

    (10) func -> FUNC idCheck LPAR funcx RPAR block . func_end
    (11) func_end -> .

    FUNC            reduce using rule 11 (func_end -> .)
    MAIN            reduce using rule 11 (func_end -> .)

    func_end                       shift and go to state 111

state 90

    (36) return -> RETURN LPAR . par_call expression RPAR par_call2
    (37) return -> RETURN LPAR . par_call call RPAR par_call2
    (108) par_call -> .

    ID              reduce using rule 108 (par_call -> .)
    LPAR            reduce using rule 108 (par_call -> .)
    MINUS           reduce using rule 108 (par_call -> .)
    NUMINT          reduce using rule 108 (par_call -> .)
    NUMFLOAT        reduce using rule 108 (par_call -> .)
    BOOLEANTYPE     reduce using rule 108 (par_call -> .)

    par_call                       shift and go to state 112

state 91

    (19) blockx -> vars blockx .

    RCBRACKET       reduce using rule 19 (blockx -> vars blockx .)


state 92

    (72) cycle -> WHILE cycle_1 . LPAR expression RPAR cycle_2 block cycle_3
    (73) cycle -> WHILE cycle_1 . LPAR vaciaList RPAR cycle_2 block cycle_3

    LPAR            shift and go to state 113


state 93

    (65) print -> PRINT LPAR . par_call printx RPAR par_call2
    (108) par_call -> .

    ID              reduce using rule 108 (par_call -> .)
    LPAR            reduce using rule 108 (par_call -> .)
    MINUS           reduce using rule 108 (par_call -> .)
    NUMINT          reduce using rule 108 (par_call -> .)
    NUMFLOAT        reduce using rule 108 (par_call -> .)
    BOOLEANTYPE     reduce using rule 108 (par_call -> .)

    par_call                       shift and go to state 114

state 94

    (85) list -> LIST idCheck_List . EQUAL LBRACKET listx RBRACKET

    EQUAL           shift and go to state 115


state 95

    (93) idCheck_List -> ID .

    EQUAL           reduce using rule 93 (idCheck_List -> ID .)


state 96

    (21) blockx -> statement blockx .

    RCBRACKET       reduce using rule 21 (blockx -> statement blockx .)


state 97

    (77) condition -> IF LPAR . expression RPAR cond_1 block else cond_2
    (78) condition -> IF LPAR . vaciaList RPAR cond_1 block else cond_2
    (48) expression -> . exp
    (49) expression -> . exp COMPARISON op_val expression
    (84) vaciaList -> . ID idCheck_Add POINT VACIA LPAR RPAR
    (50) exp -> . termino
    (51) exp -> . termino PLUS op_val exp
    (52) exp -> . termino MINUS op_val exp
    (53) termino -> . factor
    (54) termino -> . factor MULTIPLY op_val termino
    (55) termino -> . factor DIVIDE op_val termino
    (58) factor -> . LPAR expression RPAR
    (59) factor -> . MINUS varcte
    (60) factor -> . varcte termino_val
    (61) varcte -> . ID
    (62) varcte -> . NUMINT
    (63) varcte -> . NUMFLOAT
    (64) varcte -> . BOOLEANTYPE

    ID              shift and go to state 117
    LPAR            shift and go to state 36
    MINUS           shift and go to state 39
    NUMINT          shift and go to state 44
    NUMFLOAT        shift and go to state 37
    BOOLEANTYPE     shift and go to state 47

    vaciaList                      shift and go to state 116
    termino                        shift and go to state 38
    exp                            shift and go to state 46
    factor                         shift and go to state 41
    expression                     shift and go to state 118
    varcte                         shift and go to state 40

state 98

    (17) block -> LCBRACKET blockx RCBRACKET .

    ELSE            reduce using rule 17 (block -> LCBRACKET blockx RCBRACKET .)
    INT             reduce using rule 17 (block -> LCBRACKET blockx RCBRACKET .)
    FLOAT           reduce using rule 17 (block -> LCBRACKET blockx RCBRACKET .)
    BOOLEAN         reduce using rule 17 (block -> LCBRACKET blockx RCBRACKET .)
    ID              reduce using rule 17 (block -> LCBRACKET blockx RCBRACKET .)
    IF              reduce using rule 17 (block -> LCBRACKET blockx RCBRACKET .)
    WHILE           reduce using rule 17 (block -> LCBRACKET blockx RCBRACKET .)
    PRINT           reduce using rule 17 (block -> LCBRACKET blockx RCBRACKET .)
    LIST            reduce using rule 17 (block -> LCBRACKET blockx RCBRACKET .)
    CAT             reduce using rule 17 (block -> LCBRACKET blockx RCBRACKET .)
    ADD             reduce using rule 17 (block -> LCBRACKET blockx RCBRACKET .)
    RETURN          reduce using rule 17 (block -> LCBRACKET blockx RCBRACKET .)
    RCBRACKET       reduce using rule 17 (block -> LCBRACKET blockx RCBRACKET .)
    FUNC            reduce using rule 17 (block -> LCBRACKET blockx RCBRACKET .)
    MAIN            reduce using rule 17 (block -> LCBRACKET blockx RCBRACKET .)
    $end            reduce using rule 17 (block -> LCBRACKET blockx RCBRACKET .)


state 99

    (115) toy -> ADD POINT . TOY LPAR RPAR

    TOY             shift and go to state 119


state 100

    (114) move -> CAT POINT . MOVE LPAR NUMINT COMA NUMINT RPAR
    (116) clean -> CAT POINT . CLEAN LPAR RPAR
    (117) play -> CAT POINT . PLAY LPAR RPAR

    MOVE            shift and go to state 121
    CLEAN           shift and go to state 122
    PLAY            shift and go to state 120


state 101

    (99) add -> ID idCheck_Add . POINT ADD LPAR listx_add RPAR
    (103) find -> ID idCheck_Add . POINT FIND LPAR NUMINT RPAR
    (104) printList -> ID idCheck_Add . POINT PRINTLIST LPAR RPAR

    POINT           shift and go to state 123


state 102

    (58) factor -> LPAR expression RPAR .

    MULTIPLY        reduce using rule 58 (factor -> LPAR expression RPAR .)
    DIVIDE          reduce using rule 58 (factor -> LPAR expression RPAR .)
    PLUS            reduce using rule 58 (factor -> LPAR expression RPAR .)
    MINUS           reduce using rule 58 (factor -> LPAR expression RPAR .)
    COMPARISON      reduce using rule 58 (factor -> LPAR expression RPAR .)
    ID              reduce using rule 58 (factor -> LPAR expression RPAR .)
    FUNC            reduce using rule 58 (factor -> LPAR expression RPAR .)
    MAIN            reduce using rule 58 (factor -> LPAR expression RPAR .)
    INT             reduce using rule 58 (factor -> LPAR expression RPAR .)
    FLOAT           reduce using rule 58 (factor -> LPAR expression RPAR .)
    BOOLEAN         reduce using rule 58 (factor -> LPAR expression RPAR .)
    IF              reduce using rule 58 (factor -> LPAR expression RPAR .)
    WHILE           reduce using rule 58 (factor -> LPAR expression RPAR .)
    PRINT           reduce using rule 58 (factor -> LPAR expression RPAR .)
    LIST            reduce using rule 58 (factor -> LPAR expression RPAR .)
    CAT             reduce using rule 58 (factor -> LPAR expression RPAR .)
    ADD             reduce using rule 58 (factor -> LPAR expression RPAR .)
    RETURN          reduce using rule 58 (factor -> LPAR expression RPAR .)
    RCBRACKET       reduce using rule 58 (factor -> LPAR expression RPAR .)
    RPAR            reduce using rule 58 (factor -> LPAR expression RPAR .)
    COMA            reduce using rule 58 (factor -> LPAR expression RPAR .)


state 103

    (51) exp -> termino PLUS op_val . exp
    (50) exp -> . termino
    (51) exp -> . termino PLUS op_val exp
    (52) exp -> . termino MINUS op_val exp
    (53) termino -> . factor
    (54) termino -> . factor MULTIPLY op_val termino
    (55) termino -> . factor DIVIDE op_val termino
    (58) factor -> . LPAR expression RPAR
    (59) factor -> . MINUS varcte
    (60) factor -> . varcte termino_val
    (61) varcte -> . ID
    (62) varcte -> . NUMINT
    (63) varcte -> . NUMFLOAT
    (64) varcte -> . BOOLEANTYPE

    LPAR            shift and go to state 36
    MINUS           shift and go to state 39
    ID              shift and go to state 77
    NUMINT          shift and go to state 44
    NUMFLOAT        shift and go to state 37
    BOOLEANTYPE     shift and go to state 47

    varcte                         shift and go to state 40
    termino                        shift and go to state 38
    exp                            shift and go to state 124
    factor                         shift and go to state 41

state 104

    (52) exp -> termino MINUS op_val . exp
    (50) exp -> . termino
    (51) exp -> . termino PLUS op_val exp
    (52) exp -> . termino MINUS op_val exp
    (53) termino -> . factor
    (54) termino -> . factor MULTIPLY op_val termino
    (55) termino -> . factor DIVIDE op_val termino
    (58) factor -> . LPAR expression RPAR
    (59) factor -> . MINUS varcte
    (60) factor -> . varcte termino_val
    (61) varcte -> . ID
    (62) varcte -> . NUMINT
    (63) varcte -> . NUMFLOAT
    (64) varcte -> . BOOLEANTYPE

    LPAR            shift and go to state 36
    MINUS           shift and go to state 39
    ID              shift and go to state 77
    NUMINT          shift and go to state 44
    NUMFLOAT        shift and go to state 37
    BOOLEANTYPE     shift and go to state 47

    varcte                         shift and go to state 40
    termino                        shift and go to state 38
    exp                            shift and go to state 125
    factor                         shift and go to state 41

state 105

    (54) termino -> factor MULTIPLY op_val . termino
    (53) termino -> . factor
    (54) termino -> . factor MULTIPLY op_val termino
    (55) termino -> . factor DIVIDE op_val termino
    (58) factor -> . LPAR expression RPAR
    (59) factor -> . MINUS varcte
    (60) factor -> . varcte termino_val
    (61) varcte -> . ID
    (62) varcte -> . NUMINT
    (63) varcte -> . NUMFLOAT
    (64) varcte -> . BOOLEANTYPE

    LPAR            shift and go to state 36
    MINUS           shift and go to state 39
    ID              shift and go to state 77
    NUMINT          shift and go to state 44
    NUMFLOAT        shift and go to state 37
    BOOLEANTYPE     shift and go to state 47

    varcte                         shift and go to state 40
    factor                         shift and go to state 41
    termino                        shift and go to state 126

state 106

    (55) termino -> factor DIVIDE op_val . termino
    (53) termino -> . factor
    (54) termino -> . factor MULTIPLY op_val termino
    (55) termino -> . factor DIVIDE op_val termino
    (58) factor -> . LPAR expression RPAR
    (59) factor -> . MINUS varcte
    (60) factor -> . varcte termino_val
    (61) varcte -> . ID
    (62) varcte -> . NUMINT
    (63) varcte -> . NUMFLOAT
    (64) varcte -> . BOOLEANTYPE

    LPAR            shift and go to state 36
    MINUS           shift and go to state 39
    ID              shift and go to state 77
    NUMINT          shift and go to state 44
    NUMFLOAT        shift and go to state 37
    BOOLEANTYPE     shift and go to state 47

    varcte                         shift and go to state 40
    factor                         shift and go to state 41
    termino                        shift and go to state 127

state 107

    (101) remove -> ID idCheck_Remove POINT . REMOVE LPAR RPAR

    REMOVE          shift and go to state 128


state 108

    (105) call -> ID id_call LPAR . par_call RPAR par_call2
    (106) call -> ID id_call LPAR . par_call params RPAR par_call2
    (108) par_call -> .

    RPAR            reduce using rule 108 (par_call -> .)
    ID              reduce using rule 108 (par_call -> .)
    LPAR            reduce using rule 108 (par_call -> .)
    MINUS           reduce using rule 108 (par_call -> .)
    NUMINT          reduce using rule 108 (par_call -> .)
    NUMFLOAT        reduce using rule 108 (par_call -> .)
    BOOLEANTYPE     reduce using rule 108 (par_call -> .)

    par_call                       shift and go to state 129

state 109

    (49) expression -> exp COMPARISON op_val . expression
    (48) expression -> . exp
    (49) expression -> . exp COMPARISON op_val expression
    (50) exp -> . termino
    (51) exp -> . termino PLUS op_val exp
    (52) exp -> . termino MINUS op_val exp
    (53) termino -> . factor
    (54) termino -> . factor MULTIPLY op_val termino
    (55) termino -> . factor DIVIDE op_val termino
    (58) factor -> . LPAR expression RPAR
    (59) factor -> . MINUS varcte
    (60) factor -> . varcte termino_val
    (61) varcte -> . ID
    (62) varcte -> . NUMINT
    (63) varcte -> . NUMFLOAT
    (64) varcte -> . BOOLEANTYPE

    LPAR            shift and go to state 36
    MINUS           shift and go to state 39
    ID              shift and go to state 77
    NUMINT          shift and go to state 44
    NUMFLOAT        shift and go to state 37
    BOOLEANTYPE     shift and go to state 47

    varcte                         shift and go to state 40
    termino                        shift and go to state 38
    exp                            shift and go to state 46
    factor                         shift and go to state 41
    expression                     shift and go to state 130

state 110

    (14) funcx -> vars paramCheck COMA funcx .

    RPAR            reduce using rule 14 (funcx -> vars paramCheck COMA funcx .)


state 111

    (10) func -> FUNC idCheck LPAR funcx RPAR block func_end .

    FUNC            reduce using rule 10 (func -> FUNC idCheck LPAR funcx RPAR block func_end .)
    MAIN            reduce using rule 10 (func -> FUNC idCheck LPAR funcx RPAR block func_end .)


state 112

    (36) return -> RETURN LPAR par_call . expression RPAR par_call2
    (37) return -> RETURN LPAR par_call . call RPAR par_call2
    (48) expression -> . exp
    (49) expression -> . exp COMPARISON op_val expression
    (105) call -> . ID id_call LPAR par_call RPAR par_call2
    (106) call -> . ID id_call LPAR par_call params RPAR par_call2
    (50) exp -> . termino
    (51) exp -> . termino PLUS op_val exp
    (52) exp -> . termino MINUS op_val exp
    (53) termino -> . factor
    (54) termino -> . factor MULTIPLY op_val termino
    (55) termino -> . factor DIVIDE op_val termino
    (58) factor -> . LPAR expression RPAR
    (59) factor -> . MINUS varcte
    (60) factor -> . varcte termino_val
    (61) varcte -> . ID
    (62) varcte -> . NUMINT
    (63) varcte -> . NUMFLOAT
    (64) varcte -> . BOOLEANTYPE

    ID              shift and go to state 132
    LPAR            shift and go to state 36
    MINUS           shift and go to state 39
    NUMINT          shift and go to state 44
    NUMFLOAT        shift and go to state 37
    BOOLEANTYPE     shift and go to state 47

    factor                         shift and go to state 41
    varcte                         shift and go to state 40
    call                           shift and go to state 131
    termino                        shift and go to state 38
    exp                            shift and go to state 46
    expression                     shift and go to state 133

state 113

    (72) cycle -> WHILE cycle_1 LPAR . expression RPAR cycle_2 block cycle_3
    (73) cycle -> WHILE cycle_1 LPAR . vaciaList RPAR cycle_2 block cycle_3
    (48) expression -> . exp
    (49) expression -> . exp COMPARISON op_val expression
    (84) vaciaList -> . ID idCheck_Add POINT VACIA LPAR RPAR
    (50) exp -> . termino
    (51) exp -> . termino PLUS op_val exp
    (52) exp -> . termino MINUS op_val exp
    (53) termino -> . factor
    (54) termino -> . factor MULTIPLY op_val termino
    (55) termino -> . factor DIVIDE op_val termino
    (58) factor -> . LPAR expression RPAR
    (59) factor -> . MINUS varcte
    (60) factor -> . varcte termino_val
    (61) varcte -> . ID
    (62) varcte -> . NUMINT
    (63) varcte -> . NUMFLOAT
    (64) varcte -> . BOOLEANTYPE

    ID              shift and go to state 117
    LPAR            shift and go to state 36
    MINUS           shift and go to state 39
    NUMINT          shift and go to state 44
    NUMFLOAT        shift and go to state 37
    BOOLEANTYPE     shift and go to state 47

    varcte                         shift and go to state 40
    vaciaList                      shift and go to state 134
    termino                        shift and go to state 38
    exp                            shift and go to state 46
    factor                         shift and go to state 41
    expression                     shift and go to state 135

state 114

    (65) print -> PRINT LPAR par_call . printx RPAR par_call2
    (66) printx -> . expression
    (67) printx -> . ID id_val
    (68) printx -> . call
    (69) printx -> . expression PLUS op_val printx
    (70) printx -> . ID id_val PLUS op_val printx
    (71) printx -> . call PLUS op_val printx
    (48) expression -> . exp
    (49) expression -> . exp COMPARISON op_val expression
    (105) call -> . ID id_call LPAR par_call RPAR par_call2
    (106) call -> . ID id_call LPAR par_call params RPAR par_call2
    (50) exp -> . termino
    (51) exp -> . termino PLUS op_val exp
    (52) exp -> . termino MINUS op_val exp
    (53) termino -> . factor
    (54) termino -> . factor MULTIPLY op_val termino
    (55) termino -> . factor DIVIDE op_val termino
    (58) factor -> . LPAR expression RPAR
    (59) factor -> . MINUS varcte
    (60) factor -> . varcte termino_val
    (61) varcte -> . ID
    (62) varcte -> . NUMINT
    (63) varcte -> . NUMFLOAT
    (64) varcte -> . BOOLEANTYPE

    ID              shift and go to state 138
    LPAR            shift and go to state 36
    MINUS           shift and go to state 39
    NUMINT          shift and go to state 44
    NUMFLOAT        shift and go to state 37
    BOOLEANTYPE     shift and go to state 47

    factor                         shift and go to state 41
    varcte                         shift and go to state 40
    printx                         shift and go to state 136
    call                           shift and go to state 137
    termino                        shift and go to state 38
    exp                            shift and go to state 46
    expression                     shift and go to state 139

state 115

    (85) list -> LIST idCheck_List EQUAL . LBRACKET listx RBRACKET

    LBRACKET        shift and go to state 140


state 116

    (78) condition -> IF LPAR vaciaList . RPAR cond_1 block else cond_2

    RPAR            shift and go to state 141


state 117

    (84) vaciaList -> ID . idCheck_Add POINT VACIA LPAR RPAR
    (61) varcte -> ID .
    (100) idCheck_Add -> .

    MULTIPLY        reduce using rule 61 (varcte -> ID .)
    DIVIDE          reduce using rule 61 (varcte -> ID .)
    PLUS            reduce using rule 61 (varcte -> ID .)
    MINUS           reduce using rule 61 (varcte -> ID .)
    COMPARISON      reduce using rule 61 (varcte -> ID .)
    RPAR            reduce using rule 61 (varcte -> ID .)
    POINT           reduce using rule 100 (idCheck_Add -> .)

    idCheck_Add                    shift and go to state 142

state 118

    (77) condition -> IF LPAR expression . RPAR cond_1 block else cond_2

    RPAR            shift and go to state 143


state 119

    (115) toy -> ADD POINT TOY . LPAR RPAR

    LPAR            shift and go to state 144


state 120

    (117) play -> CAT POINT PLAY . LPAR RPAR

    LPAR            shift and go to state 145


state 121

    (114) move -> CAT POINT MOVE . LPAR NUMINT COMA NUMINT RPAR

    LPAR            shift and go to state 146


state 122

    (116) clean -> CAT POINT CLEAN . LPAR RPAR

    LPAR            shift and go to state 147


state 123

    (99) add -> ID idCheck_Add POINT . ADD LPAR listx_add RPAR
    (103) find -> ID idCheck_Add POINT . FIND LPAR NUMINT RPAR
    (104) printList -> ID idCheck_Add POINT . PRINTLIST LPAR RPAR

    ADD             shift and go to state 150
    FIND            shift and go to state 148
    PRINTLIST       shift and go to state 149


state 124

    (51) exp -> termino PLUS op_val exp .

    COMPARISON      reduce using rule 51 (exp -> termino PLUS op_val exp .)
    RPAR            reduce using rule 51 (exp -> termino PLUS op_val exp .)
    ID              reduce using rule 51 (exp -> termino PLUS op_val exp .)
    FUNC            reduce using rule 51 (exp -> termino PLUS op_val exp .)
    MAIN            reduce using rule 51 (exp -> termino PLUS op_val exp .)
    INT             reduce using rule 51 (exp -> termino PLUS op_val exp .)
    FLOAT           reduce using rule 51 (exp -> termino PLUS op_val exp .)
    BOOLEAN         reduce using rule 51 (exp -> termino PLUS op_val exp .)
    IF              reduce using rule 51 (exp -> termino PLUS op_val exp .)
    WHILE           reduce using rule 51 (exp -> termino PLUS op_val exp .)
    PRINT           reduce using rule 51 (exp -> termino PLUS op_val exp .)
    LIST            reduce using rule 51 (exp -> termino PLUS op_val exp .)
    CAT             reduce using rule 51 (exp -> termino PLUS op_val exp .)
    ADD             reduce using rule 51 (exp -> termino PLUS op_val exp .)
    RETURN          reduce using rule 51 (exp -> termino PLUS op_val exp .)
    RCBRACKET       reduce using rule 51 (exp -> termino PLUS op_val exp .)
    PLUS            reduce using rule 51 (exp -> termino PLUS op_val exp .)
    COMA            reduce using rule 51 (exp -> termino PLUS op_val exp .)


state 125

    (52) exp -> termino MINUS op_val exp .

    COMPARISON      reduce using rule 52 (exp -> termino MINUS op_val exp .)
    RPAR            reduce using rule 52 (exp -> termino MINUS op_val exp .)
    ID              reduce using rule 52 (exp -> termino MINUS op_val exp .)
    FUNC            reduce using rule 52 (exp -> termino MINUS op_val exp .)
    MAIN            reduce using rule 52 (exp -> termino MINUS op_val exp .)
    INT             reduce using rule 52 (exp -> termino MINUS op_val exp .)
    FLOAT           reduce using rule 52 (exp -> termino MINUS op_val exp .)
    BOOLEAN         reduce using rule 52 (exp -> termino MINUS op_val exp .)
    IF              reduce using rule 52 (exp -> termino MINUS op_val exp .)
    WHILE           reduce using rule 52 (exp -> termino MINUS op_val exp .)
    PRINT           reduce using rule 52 (exp -> termino MINUS op_val exp .)
    LIST            reduce using rule 52 (exp -> termino MINUS op_val exp .)
    CAT             reduce using rule 52 (exp -> termino MINUS op_val exp .)
    ADD             reduce using rule 52 (exp -> termino MINUS op_val exp .)
    RETURN          reduce using rule 52 (exp -> termino MINUS op_val exp .)
    RCBRACKET       reduce using rule 52 (exp -> termino MINUS op_val exp .)
    PLUS            reduce using rule 52 (exp -> termino MINUS op_val exp .)
    COMA            reduce using rule 52 (exp -> termino MINUS op_val exp .)


state 126

    (54) termino -> factor MULTIPLY op_val termino .

    PLUS            reduce using rule 54 (termino -> factor MULTIPLY op_val termino .)
    MINUS           reduce using rule 54 (termino -> factor MULTIPLY op_val termino .)
    COMPARISON      reduce using rule 54 (termino -> factor MULTIPLY op_val termino .)
    COMA            reduce using rule 54 (termino -> factor MULTIPLY op_val termino .)
    RPAR            reduce using rule 54 (termino -> factor MULTIPLY op_val termino .)
    ID              reduce using rule 54 (termino -> factor MULTIPLY op_val termino .)
    FUNC            reduce using rule 54 (termino -> factor MULTIPLY op_val termino .)
    MAIN            reduce using rule 54 (termino -> factor MULTIPLY op_val termino .)
    INT             reduce using rule 54 (termino -> factor MULTIPLY op_val termino .)
    FLOAT           reduce using rule 54 (termino -> factor MULTIPLY op_val termino .)
    BOOLEAN         reduce using rule 54 (termino -> factor MULTIPLY op_val termino .)
    IF              reduce using rule 54 (termino -> factor MULTIPLY op_val termino .)
    WHILE           reduce using rule 54 (termino -> factor MULTIPLY op_val termino .)
    PRINT           reduce using rule 54 (termino -> factor MULTIPLY op_val termino .)
    LIST            reduce using rule 54 (termino -> factor MULTIPLY op_val termino .)
    CAT             reduce using rule 54 (termino -> factor MULTIPLY op_val termino .)
    ADD             reduce using rule 54 (termino -> factor MULTIPLY op_val termino .)
    RETURN          reduce using rule 54 (termino -> factor MULTIPLY op_val termino .)
    RCBRACKET       reduce using rule 54 (termino -> factor MULTIPLY op_val termino .)


state 127

    (55) termino -> factor DIVIDE op_val termino .

    PLUS            reduce using rule 55 (termino -> factor DIVIDE op_val termino .)
    MINUS           reduce using rule 55 (termino -> factor DIVIDE op_val termino .)
    COMPARISON      reduce using rule 55 (termino -> factor DIVIDE op_val termino .)
    COMA            reduce using rule 55 (termino -> factor DIVIDE op_val termino .)
    RPAR            reduce using rule 55 (termino -> factor DIVIDE op_val termino .)
    ID              reduce using rule 55 (termino -> factor DIVIDE op_val termino .)
    FUNC            reduce using rule 55 (termino -> factor DIVIDE op_val termino .)
    MAIN            reduce using rule 55 (termino -> factor DIVIDE op_val termino .)
    INT             reduce using rule 55 (termino -> factor DIVIDE op_val termino .)
    FLOAT           reduce using rule 55 (termino -> factor DIVIDE op_val termino .)
    BOOLEAN         reduce using rule 55 (termino -> factor DIVIDE op_val termino .)
    IF              reduce using rule 55 (termino -> factor DIVIDE op_val termino .)
    WHILE           reduce using rule 55 (termino -> factor DIVIDE op_val termino .)
    PRINT           reduce using rule 55 (termino -> factor DIVIDE op_val termino .)
    LIST            reduce using rule 55 (termino -> factor DIVIDE op_val termino .)
    CAT             reduce using rule 55 (termino -> factor DIVIDE op_val termino .)
    ADD             reduce using rule 55 (termino -> factor DIVIDE op_val termino .)
    RETURN          reduce using rule 55 (termino -> factor DIVIDE op_val termino .)
    RCBRACKET       reduce using rule 55 (termino -> factor DIVIDE op_val termino .)


state 128

    (101) remove -> ID idCheck_Remove POINT REMOVE . LPAR RPAR

    LPAR            shift and go to state 151


state 129

    (105) call -> ID id_call LPAR par_call . RPAR par_call2
    (106) call -> ID id_call LPAR par_call . params RPAR par_call2
    (110) params -> . expression COMA params
    (111) params -> . ID COMA params
    (112) params -> . expression
    (113) params -> . ID
    (48) expression -> . exp
    (49) expression -> . exp COMPARISON op_val expression
    (50) exp -> . termino
    (51) exp -> . termino PLUS op_val exp
    (52) exp -> . termino MINUS op_val exp
    (53) termino -> . factor
    (54) termino -> . factor MULTIPLY op_val termino
    (55) termino -> . factor DIVIDE op_val termino
    (58) factor -> . LPAR expression RPAR
    (59) factor -> . MINUS varcte
    (60) factor -> . varcte termino_val
    (61) varcte -> . ID
    (62) varcte -> . NUMINT
    (63) varcte -> . NUMFLOAT
    (64) varcte -> . BOOLEANTYPE

    RPAR            shift and go to state 152
    ID              shift and go to state 154
    LPAR            shift and go to state 36
    MINUS           shift and go to state 39
    NUMINT          shift and go to state 44
    NUMFLOAT        shift and go to state 37
    BOOLEANTYPE     shift and go to state 47

    varcte                         shift and go to state 40
    params                         shift and go to state 153
    termino                        shift and go to state 38
    exp                            shift and go to state 46
    factor                         shift and go to state 41
    expression                     shift and go to state 155

state 130

    (49) expression -> exp COMPARISON op_val expression .

    ID              reduce using rule 49 (expression -> exp COMPARISON op_val expression .)
    FUNC            reduce using rule 49 (expression -> exp COMPARISON op_val expression .)
    MAIN            reduce using rule 49 (expression -> exp COMPARISON op_val expression .)
    INT             reduce using rule 49 (expression -> exp COMPARISON op_val expression .)
    FLOAT           reduce using rule 49 (expression -> exp COMPARISON op_val expression .)
    BOOLEAN         reduce using rule 49 (expression -> exp COMPARISON op_val expression .)
    IF              reduce using rule 49 (expression -> exp COMPARISON op_val expression .)
    WHILE           reduce using rule 49 (expression -> exp COMPARISON op_val expression .)
    PRINT           reduce using rule 49 (expression -> exp COMPARISON op_val expression .)
    LIST            reduce using rule 49 (expression -> exp COMPARISON op_val expression .)
    CAT             reduce using rule 49 (expression -> exp COMPARISON op_val expression .)
    ADD             reduce using rule 49 (expression -> exp COMPARISON op_val expression .)
    RETURN          reduce using rule 49 (expression -> exp COMPARISON op_val expression .)
    RCBRACKET       reduce using rule 49 (expression -> exp COMPARISON op_val expression .)
    RPAR            reduce using rule 49 (expression -> exp COMPARISON op_val expression .)
    PLUS            reduce using rule 49 (expression -> exp COMPARISON op_val expression .)
    COMA            reduce using rule 49 (expression -> exp COMPARISON op_val expression .)


state 131

    (37) return -> RETURN LPAR par_call call . RPAR par_call2

    RPAR            shift and go to state 156


state 132

    (105) call -> ID . id_call LPAR par_call RPAR par_call2
    (106) call -> ID . id_call LPAR par_call params RPAR par_call2
    (61) varcte -> ID .
    (107) id_call -> .

    MULTIPLY        reduce using rule 61 (varcte -> ID .)
    DIVIDE          reduce using rule 61 (varcte -> ID .)
    PLUS            reduce using rule 61 (varcte -> ID .)
    MINUS           reduce using rule 61 (varcte -> ID .)
    COMPARISON      reduce using rule 61 (varcte -> ID .)
    RPAR            reduce using rule 61 (varcte -> ID .)
    LPAR            reduce using rule 107 (id_call -> .)

    id_call                        shift and go to state 86

state 133

    (36) return -> RETURN LPAR par_call expression . RPAR par_call2

    RPAR            shift and go to state 157


state 134

    (73) cycle -> WHILE cycle_1 LPAR vaciaList . RPAR cycle_2 block cycle_3

    RPAR            shift and go to state 158


state 135

    (72) cycle -> WHILE cycle_1 LPAR expression . RPAR cycle_2 block cycle_3

    RPAR            shift and go to state 159


state 136

    (65) print -> PRINT LPAR par_call printx . RPAR par_call2

    RPAR            shift and go to state 160


state 137

    (68) printx -> call .
    (71) printx -> call . PLUS op_val printx

    RPAR            reduce using rule 68 (printx -> call .)
    PLUS            shift and go to state 161


state 138

    (67) printx -> ID . id_val
    (70) printx -> ID . id_val PLUS op_val printx
    (105) call -> ID . id_call LPAR par_call RPAR par_call2
    (106) call -> ID . id_call LPAR par_call params RPAR par_call2
    (61) varcte -> ID .
    (46) id_val -> .
    (107) id_call -> .

  ! reduce/reduce conflict for PLUS resolved using rule 46 (id_val -> .)
  ! reduce/reduce conflict for RPAR resolved using rule 46 (id_val -> .)
    MULTIPLY        reduce using rule 61 (varcte -> ID .)
    DIVIDE          reduce using rule 61 (varcte -> ID .)
    MINUS           reduce using rule 61 (varcte -> ID .)
    COMPARISON      reduce using rule 61 (varcte -> ID .)
    PLUS            reduce using rule 46 (id_val -> .)
    RPAR            reduce using rule 46 (id_val -> .)
    LPAR            reduce using rule 107 (id_call -> .)

  ! PLUS            [ reduce using rule 61 (varcte -> ID .) ]
  ! RPAR            [ reduce using rule 61 (varcte -> ID .) ]

    id_val                         shift and go to state 162
    id_call                        shift and go to state 86

state 139

    (66) printx -> expression .
    (69) printx -> expression . PLUS op_val printx

    RPAR            reduce using rule 66 (printx -> expression .)
    PLUS            shift and go to state 163


state 140

    (85) list -> LIST idCheck_List EQUAL LBRACKET . listx RBRACKET
    (86) listx -> . ID id_param
    (87) listx -> . ID id_param COMA listx
    (88) listx -> . NUMINT id_param
    (89) listx -> . NUMINT id_param COMA listx
    (90) listx -> . NUMFLOAT id_param
    (91) listx -> . NUMFLOAT id_param COMA listx
    (92) listx -> . empty
    (118) empty -> .

    ID              shift and go to state 167
    NUMINT          shift and go to state 165
    NUMFLOAT        shift and go to state 166
    RBRACKET        reduce using rule 118 (empty -> .)

    listx                          shift and go to state 164
    empty                          shift and go to state 168

state 141

    (78) condition -> IF LPAR vaciaList RPAR . cond_1 block else cond_2
    (81) cond_1 -> .

    LCBRACKET       reduce using rule 81 (cond_1 -> .)

    cond_1                         shift and go to state 169

state 142

    (84) vaciaList -> ID idCheck_Add . POINT VACIA LPAR RPAR

    POINT           shift and go to state 170


state 143

    (77) condition -> IF LPAR expression RPAR . cond_1 block else cond_2
    (81) cond_1 -> .

    LCBRACKET       reduce using rule 81 (cond_1 -> .)

    cond_1                         shift and go to state 171

state 144

    (115) toy -> ADD POINT TOY LPAR . RPAR

    RPAR            shift and go to state 172


state 145

    (117) play -> CAT POINT PLAY LPAR . RPAR

    RPAR            shift and go to state 173


state 146

    (114) move -> CAT POINT MOVE LPAR . NUMINT COMA NUMINT RPAR

    NUMINT          shift and go to state 174


state 147

    (116) clean -> CAT POINT CLEAN LPAR . RPAR

    RPAR            shift and go to state 175


state 148

    (103) find -> ID idCheck_Add POINT FIND . LPAR NUMINT RPAR

    LPAR            shift and go to state 176


state 149

    (104) printList -> ID idCheck_Add POINT PRINTLIST . LPAR RPAR

    LPAR            shift and go to state 177


state 150

    (99) add -> ID idCheck_Add POINT ADD . LPAR listx_add RPAR

    LPAR            shift and go to state 178


state 151

    (101) remove -> ID idCheck_Remove POINT REMOVE LPAR . RPAR

    RPAR            shift and go to state 179


state 152

    (105) call -> ID id_call LPAR par_call RPAR . par_call2
    (109) par_call2 -> .

    ID              reduce using rule 109 (par_call2 -> .)
    FUNC            reduce using rule 109 (par_call2 -> .)
    MAIN            reduce using rule 109 (par_call2 -> .)
    INT             reduce using rule 109 (par_call2 -> .)
    FLOAT           reduce using rule 109 (par_call2 -> .)
    BOOLEAN         reduce using rule 109 (par_call2 -> .)
    IF              reduce using rule 109 (par_call2 -> .)
    WHILE           reduce using rule 109 (par_call2 -> .)
    PRINT           reduce using rule 109 (par_call2 -> .)
    LIST            reduce using rule 109 (par_call2 -> .)
    CAT             reduce using rule 109 (par_call2 -> .)
    ADD             reduce using rule 109 (par_call2 -> .)
    RETURN          reduce using rule 109 (par_call2 -> .)
    RCBRACKET       reduce using rule 109 (par_call2 -> .)
    RPAR            reduce using rule 109 (par_call2 -> .)
    PLUS            reduce using rule 109 (par_call2 -> .)

    par_call2                      shift and go to state 180

state 153

    (106) call -> ID id_call LPAR par_call params . RPAR par_call2

    RPAR            shift and go to state 181


state 154

    (111) params -> ID . COMA params
    (113) params -> ID .
    (61) varcte -> ID .

  ! shift/reduce conflict for COMA resolved as shift
  ! reduce/reduce conflict for RPAR resolved using rule 61 (varcte -> ID .)
    COMA            shift and go to state 182
    MULTIPLY        reduce using rule 61 (varcte -> ID .)
    DIVIDE          reduce using rule 61 (varcte -> ID .)
    PLUS            reduce using rule 61 (varcte -> ID .)
    MINUS           reduce using rule 61 (varcte -> ID .)
    COMPARISON      reduce using rule 61 (varcte -> ID .)
    RPAR            reduce using rule 61 (varcte -> ID .)

  ! RPAR            [ reduce using rule 113 (params -> ID .) ]
  ! COMA            [ reduce using rule 61 (varcte -> ID .) ]


state 155

    (110) params -> expression . COMA params
    (112) params -> expression .

    COMA            shift and go to state 183
    RPAR            reduce using rule 112 (params -> expression .)


state 156

    (37) return -> RETURN LPAR par_call call RPAR . par_call2
    (109) par_call2 -> .

    INT             reduce using rule 109 (par_call2 -> .)
    FLOAT           reduce using rule 109 (par_call2 -> .)
    BOOLEAN         reduce using rule 109 (par_call2 -> .)
    ID              reduce using rule 109 (par_call2 -> .)
    IF              reduce using rule 109 (par_call2 -> .)
    WHILE           reduce using rule 109 (par_call2 -> .)
    PRINT           reduce using rule 109 (par_call2 -> .)
    LIST            reduce using rule 109 (par_call2 -> .)
    CAT             reduce using rule 109 (par_call2 -> .)
    ADD             reduce using rule 109 (par_call2 -> .)
    RETURN          reduce using rule 109 (par_call2 -> .)
    RCBRACKET       reduce using rule 109 (par_call2 -> .)

    par_call2                      shift and go to state 184

state 157

    (36) return -> RETURN LPAR par_call expression RPAR . par_call2
    (109) par_call2 -> .

    INT             reduce using rule 109 (par_call2 -> .)
    FLOAT           reduce using rule 109 (par_call2 -> .)
    BOOLEAN         reduce using rule 109 (par_call2 -> .)
    ID              reduce using rule 109 (par_call2 -> .)
    IF              reduce using rule 109 (par_call2 -> .)
    WHILE           reduce using rule 109 (par_call2 -> .)
    PRINT           reduce using rule 109 (par_call2 -> .)
    LIST            reduce using rule 109 (par_call2 -> .)
    CAT             reduce using rule 109 (par_call2 -> .)
    ADD             reduce using rule 109 (par_call2 -> .)
    RETURN          reduce using rule 109 (par_call2 -> .)
    RCBRACKET       reduce using rule 109 (par_call2 -> .)

    par_call2                      shift and go to state 185

state 158

    (73) cycle -> WHILE cycle_1 LPAR vaciaList RPAR . cycle_2 block cycle_3
    (75) cycle_2 -> .

    LCBRACKET       reduce using rule 75 (cycle_2 -> .)

    cycle_2                        shift and go to state 186

state 159

    (72) cycle -> WHILE cycle_1 LPAR expression RPAR . cycle_2 block cycle_3
    (75) cycle_2 -> .

    LCBRACKET       reduce using rule 75 (cycle_2 -> .)

    cycle_2                        shift and go to state 187

state 160

    (65) print -> PRINT LPAR par_call printx RPAR . par_call2
    (109) par_call2 -> .

    INT             reduce using rule 109 (par_call2 -> .)
    FLOAT           reduce using rule 109 (par_call2 -> .)
    BOOLEAN         reduce using rule 109 (par_call2 -> .)
    ID              reduce using rule 109 (par_call2 -> .)
    IF              reduce using rule 109 (par_call2 -> .)
    WHILE           reduce using rule 109 (par_call2 -> .)
    PRINT           reduce using rule 109 (par_call2 -> .)
    LIST            reduce using rule 109 (par_call2 -> .)
    CAT             reduce using rule 109 (par_call2 -> .)
    ADD             reduce using rule 109 (par_call2 -> .)
    RETURN          reduce using rule 109 (par_call2 -> .)
    RCBRACKET       reduce using rule 109 (par_call2 -> .)

    par_call2                      shift and go to state 188

state 161

    (71) printx -> call PLUS . op_val printx
    (57) op_val -> .

    ID              reduce using rule 57 (op_val -> .)
    LPAR            reduce using rule 57 (op_val -> .)
    MINUS           reduce using rule 57 (op_val -> .)
    NUMINT          reduce using rule 57 (op_val -> .)
    NUMFLOAT        reduce using rule 57 (op_val -> .)
    BOOLEANTYPE     reduce using rule 57 (op_val -> .)

    op_val                         shift and go to state 189

state 162

    (67) printx -> ID id_val .
    (70) printx -> ID id_val . PLUS op_val printx

    RPAR            reduce using rule 67 (printx -> ID id_val .)
    PLUS            shift and go to state 190


state 163

    (69) printx -> expression PLUS . op_val printx
    (57) op_val -> .

    ID              reduce using rule 57 (op_val -> .)
    LPAR            reduce using rule 57 (op_val -> .)
    MINUS           reduce using rule 57 (op_val -> .)
    NUMINT          reduce using rule 57 (op_val -> .)
    NUMFLOAT        reduce using rule 57 (op_val -> .)
    BOOLEANTYPE     reduce using rule 57 (op_val -> .)

    op_val                         shift and go to state 191

state 164

    (85) list -> LIST idCheck_List EQUAL LBRACKET listx . RBRACKET

    RBRACKET        shift and go to state 192


state 165

    (88) listx -> NUMINT . id_param
    (89) listx -> NUMINT . id_param COMA listx
    (94) id_param -> .

    COMA            reduce using rule 94 (id_param -> .)
    RBRACKET        reduce using rule 94 (id_param -> .)

    id_param                       shift and go to state 193

state 166

    (90) listx -> NUMFLOAT . id_param
    (91) listx -> NUMFLOAT . id_param COMA listx
    (94) id_param -> .

    COMA            reduce using rule 94 (id_param -> .)
    RBRACKET        reduce using rule 94 (id_param -> .)

    id_param                       shift and go to state 194

state 167

    (86) listx -> ID . id_param
    (87) listx -> ID . id_param COMA listx
    (94) id_param -> .

    COMA            reduce using rule 94 (id_param -> .)
    RBRACKET        reduce using rule 94 (id_param -> .)

    id_param                       shift and go to state 195

state 168

    (92) listx -> empty .

    RBRACKET        reduce using rule 92 (listx -> empty .)


state 169

    (78) condition -> IF LPAR vaciaList RPAR cond_1 . block else cond_2
    (17) block -> . LCBRACKET blockx RCBRACKET

    LCBRACKET       shift and go to state 34

    block                          shift and go to state 196

state 170

    (84) vaciaList -> ID idCheck_Add POINT . VACIA LPAR RPAR

    VACIA           shift and go to state 197


state 171

    (77) condition -> IF LPAR expression RPAR cond_1 . block else cond_2
    (17) block -> . LCBRACKET blockx RCBRACKET

    LCBRACKET       shift and go to state 34

    block                          shift and go to state 198

state 172

    (115) toy -> ADD POINT TOY LPAR RPAR .

    INT             reduce using rule 115 (toy -> ADD POINT TOY LPAR RPAR .)
    FLOAT           reduce using rule 115 (toy -> ADD POINT TOY LPAR RPAR .)
    BOOLEAN         reduce using rule 115 (toy -> ADD POINT TOY LPAR RPAR .)
    ID              reduce using rule 115 (toy -> ADD POINT TOY LPAR RPAR .)
    IF              reduce using rule 115 (toy -> ADD POINT TOY LPAR RPAR .)
    WHILE           reduce using rule 115 (toy -> ADD POINT TOY LPAR RPAR .)
    PRINT           reduce using rule 115 (toy -> ADD POINT TOY LPAR RPAR .)
    LIST            reduce using rule 115 (toy -> ADD POINT TOY LPAR RPAR .)
    CAT             reduce using rule 115 (toy -> ADD POINT TOY LPAR RPAR .)
    ADD             reduce using rule 115 (toy -> ADD POINT TOY LPAR RPAR .)
    RETURN          reduce using rule 115 (toy -> ADD POINT TOY LPAR RPAR .)
    RCBRACKET       reduce using rule 115 (toy -> ADD POINT TOY LPAR RPAR .)


state 173

    (117) play -> CAT POINT PLAY LPAR RPAR .

    INT             reduce using rule 117 (play -> CAT POINT PLAY LPAR RPAR .)
    FLOAT           reduce using rule 117 (play -> CAT POINT PLAY LPAR RPAR .)
    BOOLEAN         reduce using rule 117 (play -> CAT POINT PLAY LPAR RPAR .)
    ID              reduce using rule 117 (play -> CAT POINT PLAY LPAR RPAR .)
    IF              reduce using rule 117 (play -> CAT POINT PLAY LPAR RPAR .)
    WHILE           reduce using rule 117 (play -> CAT POINT PLAY LPAR RPAR .)
    PRINT           reduce using rule 117 (play -> CAT POINT PLAY LPAR RPAR .)
    LIST            reduce using rule 117 (play -> CAT POINT PLAY LPAR RPAR .)
    CAT             reduce using rule 117 (play -> CAT POINT PLAY LPAR RPAR .)
    ADD             reduce using rule 117 (play -> CAT POINT PLAY LPAR RPAR .)
    RETURN          reduce using rule 117 (play -> CAT POINT PLAY LPAR RPAR .)
    RCBRACKET       reduce using rule 117 (play -> CAT POINT PLAY LPAR RPAR .)


state 174

    (114) move -> CAT POINT MOVE LPAR NUMINT . COMA NUMINT RPAR

    COMA            shift and go to state 199


state 175

    (116) clean -> CAT POINT CLEAN LPAR RPAR .

    INT             reduce using rule 116 (clean -> CAT POINT CLEAN LPAR RPAR .)
    FLOAT           reduce using rule 116 (clean -> CAT POINT CLEAN LPAR RPAR .)
    BOOLEAN         reduce using rule 116 (clean -> CAT POINT CLEAN LPAR RPAR .)
    ID              reduce using rule 116 (clean -> CAT POINT CLEAN LPAR RPAR .)
    IF              reduce using rule 116 (clean -> CAT POINT CLEAN LPAR RPAR .)
    WHILE           reduce using rule 116 (clean -> CAT POINT CLEAN LPAR RPAR .)
    PRINT           reduce using rule 116 (clean -> CAT POINT CLEAN LPAR RPAR .)
    LIST            reduce using rule 116 (clean -> CAT POINT CLEAN LPAR RPAR .)
    CAT             reduce using rule 116 (clean -> CAT POINT CLEAN LPAR RPAR .)
    ADD             reduce using rule 116 (clean -> CAT POINT CLEAN LPAR RPAR .)
    RETURN          reduce using rule 116 (clean -> CAT POINT CLEAN LPAR RPAR .)
    RCBRACKET       reduce using rule 116 (clean -> CAT POINT CLEAN LPAR RPAR .)


state 176

    (103) find -> ID idCheck_Add POINT FIND LPAR . NUMINT RPAR

    NUMINT          shift and go to state 200


state 177

    (104) printList -> ID idCheck_Add POINT PRINTLIST LPAR . RPAR

    RPAR            shift and go to state 201


state 178

    (99) add -> ID idCheck_Add POINT ADD LPAR . listx_add RPAR
    (96) listx_add -> . ID id_param2
    (97) listx_add -> . NUMINT id_param2
    (98) listx_add -> . NUMFLOAT id_param2

    ID              shift and go to state 203
    NUMINT          shift and go to state 202
    NUMFLOAT        shift and go to state 204

    listx_add                      shift and go to state 205

state 179

    (101) remove -> ID idCheck_Remove POINT REMOVE LPAR RPAR .

    ID              reduce using rule 101 (remove -> ID idCheck_Remove POINT REMOVE LPAR RPAR .)
    FUNC            reduce using rule 101 (remove -> ID idCheck_Remove POINT REMOVE LPAR RPAR .)
    MAIN            reduce using rule 101 (remove -> ID idCheck_Remove POINT REMOVE LPAR RPAR .)
    INT             reduce using rule 101 (remove -> ID idCheck_Remove POINT REMOVE LPAR RPAR .)
    FLOAT           reduce using rule 101 (remove -> ID idCheck_Remove POINT REMOVE LPAR RPAR .)
    BOOLEAN         reduce using rule 101 (remove -> ID idCheck_Remove POINT REMOVE LPAR RPAR .)
    IF              reduce using rule 101 (remove -> ID idCheck_Remove POINT REMOVE LPAR RPAR .)
    WHILE           reduce using rule 101 (remove -> ID idCheck_Remove POINT REMOVE LPAR RPAR .)
    PRINT           reduce using rule 101 (remove -> ID idCheck_Remove POINT REMOVE LPAR RPAR .)
    LIST            reduce using rule 101 (remove -> ID idCheck_Remove POINT REMOVE LPAR RPAR .)
    CAT             reduce using rule 101 (remove -> ID idCheck_Remove POINT REMOVE LPAR RPAR .)
    ADD             reduce using rule 101 (remove -> ID idCheck_Remove POINT REMOVE LPAR RPAR .)
    RETURN          reduce using rule 101 (remove -> ID idCheck_Remove POINT REMOVE LPAR RPAR .)
    RCBRACKET       reduce using rule 101 (remove -> ID idCheck_Remove POINT REMOVE LPAR RPAR .)


state 180

    (105) call -> ID id_call LPAR par_call RPAR par_call2 .

    PLUS            reduce using rule 105 (call -> ID id_call LPAR par_call RPAR par_call2 .)
    RPAR            reduce using rule 105 (call -> ID id_call LPAR par_call RPAR par_call2 .)
    INT             reduce using rule 105 (call -> ID id_call LPAR par_call RPAR par_call2 .)
    FLOAT           reduce using rule 105 (call -> ID id_call LPAR par_call RPAR par_call2 .)
    BOOLEAN         reduce using rule 105 (call -> ID id_call LPAR par_call RPAR par_call2 .)
    ID              reduce using rule 105 (call -> ID id_call LPAR par_call RPAR par_call2 .)
    IF              reduce using rule 105 (call -> ID id_call LPAR par_call RPAR par_call2 .)
    WHILE           reduce using rule 105 (call -> ID id_call LPAR par_call RPAR par_call2 .)
    PRINT           reduce using rule 105 (call -> ID id_call LPAR par_call RPAR par_call2 .)
    LIST            reduce using rule 105 (call -> ID id_call LPAR par_call RPAR par_call2 .)
    CAT             reduce using rule 105 (call -> ID id_call LPAR par_call RPAR par_call2 .)
    ADD             reduce using rule 105 (call -> ID id_call LPAR par_call RPAR par_call2 .)
    RETURN          reduce using rule 105 (call -> ID id_call LPAR par_call RPAR par_call2 .)
    RCBRACKET       reduce using rule 105 (call -> ID id_call LPAR par_call RPAR par_call2 .)
    FUNC            reduce using rule 105 (call -> ID id_call LPAR par_call RPAR par_call2 .)
    MAIN            reduce using rule 105 (call -> ID id_call LPAR par_call RPAR par_call2 .)


state 181

    (106) call -> ID id_call LPAR par_call params RPAR . par_call2
    (109) par_call2 -> .

    ID              reduce using rule 109 (par_call2 -> .)
    FUNC            reduce using rule 109 (par_call2 -> .)
    MAIN            reduce using rule 109 (par_call2 -> .)
    INT             reduce using rule 109 (par_call2 -> .)
    FLOAT           reduce using rule 109 (par_call2 -> .)
    BOOLEAN         reduce using rule 109 (par_call2 -> .)
    IF              reduce using rule 109 (par_call2 -> .)
    WHILE           reduce using rule 109 (par_call2 -> .)
    PRINT           reduce using rule 109 (par_call2 -> .)
    LIST            reduce using rule 109 (par_call2 -> .)
    CAT             reduce using rule 109 (par_call2 -> .)
    ADD             reduce using rule 109 (par_call2 -> .)
    RETURN          reduce using rule 109 (par_call2 -> .)
    RCBRACKET       reduce using rule 109 (par_call2 -> .)
    RPAR            reduce using rule 109 (par_call2 -> .)
    PLUS            reduce using rule 109 (par_call2 -> .)

    par_call2                      shift and go to state 206

state 182

    (111) params -> ID COMA . params
    (110) params -> . expression COMA params
    (111) params -> . ID COMA params
    (112) params -> . expression
    (113) params -> . ID
    (48) expression -> . exp
    (49) expression -> . exp COMPARISON op_val expression
    (50) exp -> . termino
    (51) exp -> . termino PLUS op_val exp
    (52) exp -> . termino MINUS op_val exp
    (53) termino -> . factor
    (54) termino -> . factor MULTIPLY op_val termino
    (55) termino -> . factor DIVIDE op_val termino
    (58) factor -> . LPAR expression RPAR
    (59) factor -> . MINUS varcte
    (60) factor -> . varcte termino_val
    (61) varcte -> . ID
    (62) varcte -> . NUMINT
    (63) varcte -> . NUMFLOAT
    (64) varcte -> . BOOLEANTYPE

    ID              shift and go to state 154
    LPAR            shift and go to state 36
    MINUS           shift and go to state 39
    NUMINT          shift and go to state 44
    NUMFLOAT        shift and go to state 37
    BOOLEANTYPE     shift and go to state 47

    varcte                         shift and go to state 40
    params                         shift and go to state 207
    termino                        shift and go to state 38
    exp                            shift and go to state 46
    factor                         shift and go to state 41
    expression                     shift and go to state 155

state 183

    (110) params -> expression COMA . params
    (110) params -> . expression COMA params
    (111) params -> . ID COMA params
    (112) params -> . expression
    (113) params -> . ID
    (48) expression -> . exp
    (49) expression -> . exp COMPARISON op_val expression
    (50) exp -> . termino
    (51) exp -> . termino PLUS op_val exp
    (52) exp -> . termino MINUS op_val exp
    (53) termino -> . factor
    (54) termino -> . factor MULTIPLY op_val termino
    (55) termino -> . factor DIVIDE op_val termino
    (58) factor -> . LPAR expression RPAR
    (59) factor -> . MINUS varcte
    (60) factor -> . varcte termino_val
    (61) varcte -> . ID
    (62) varcte -> . NUMINT
    (63) varcte -> . NUMFLOAT
    (64) varcte -> . BOOLEANTYPE

    ID              shift and go to state 154
    LPAR            shift and go to state 36
    MINUS           shift and go to state 39
    NUMINT          shift and go to state 44
    NUMFLOAT        shift and go to state 37
    BOOLEANTYPE     shift and go to state 47

    varcte                         shift and go to state 40
    params                         shift and go to state 208
    termino                        shift and go to state 38
    exp                            shift and go to state 46
    factor                         shift and go to state 41
    expression                     shift and go to state 155

state 184

    (37) return -> RETURN LPAR par_call call RPAR par_call2 .

    INT             reduce using rule 37 (return -> RETURN LPAR par_call call RPAR par_call2 .)
    FLOAT           reduce using rule 37 (return -> RETURN LPAR par_call call RPAR par_call2 .)
    BOOLEAN         reduce using rule 37 (return -> RETURN LPAR par_call call RPAR par_call2 .)
    ID              reduce using rule 37 (return -> RETURN LPAR par_call call RPAR par_call2 .)
    IF              reduce using rule 37 (return -> RETURN LPAR par_call call RPAR par_call2 .)
    WHILE           reduce using rule 37 (return -> RETURN LPAR par_call call RPAR par_call2 .)
    PRINT           reduce using rule 37 (return -> RETURN LPAR par_call call RPAR par_call2 .)
    LIST            reduce using rule 37 (return -> RETURN LPAR par_call call RPAR par_call2 .)
    CAT             reduce using rule 37 (return -> RETURN LPAR par_call call RPAR par_call2 .)
    ADD             reduce using rule 37 (return -> RETURN LPAR par_call call RPAR par_call2 .)
    RETURN          reduce using rule 37 (return -> RETURN LPAR par_call call RPAR par_call2 .)
    RCBRACKET       reduce using rule 37 (return -> RETURN LPAR par_call call RPAR par_call2 .)


state 185

    (36) return -> RETURN LPAR par_call expression RPAR par_call2 .

    INT             reduce using rule 36 (return -> RETURN LPAR par_call expression RPAR par_call2 .)
    FLOAT           reduce using rule 36 (return -> RETURN LPAR par_call expression RPAR par_call2 .)
    BOOLEAN         reduce using rule 36 (return -> RETURN LPAR par_call expression RPAR par_call2 .)
    ID              reduce using rule 36 (return -> RETURN LPAR par_call expression RPAR par_call2 .)
    IF              reduce using rule 36 (return -> RETURN LPAR par_call expression RPAR par_call2 .)
    WHILE           reduce using rule 36 (return -> RETURN LPAR par_call expression RPAR par_call2 .)
    PRINT           reduce using rule 36 (return -> RETURN LPAR par_call expression RPAR par_call2 .)
    LIST            reduce using rule 36 (return -> RETURN LPAR par_call expression RPAR par_call2 .)
    CAT             reduce using rule 36 (return -> RETURN LPAR par_call expression RPAR par_call2 .)
    ADD             reduce using rule 36 (return -> RETURN LPAR par_call expression RPAR par_call2 .)
    RETURN          reduce using rule 36 (return -> RETURN LPAR par_call expression RPAR par_call2 .)
    RCBRACKET       reduce using rule 36 (return -> RETURN LPAR par_call expression RPAR par_call2 .)


state 186

    (73) cycle -> WHILE cycle_1 LPAR vaciaList RPAR cycle_2 . block cycle_3
    (17) block -> . LCBRACKET blockx RCBRACKET

    LCBRACKET       shift and go to state 34

    block                          shift and go to state 209

state 187

    (72) cycle -> WHILE cycle_1 LPAR expression RPAR cycle_2 . block cycle_3
    (17) block -> . LCBRACKET blockx RCBRACKET

    LCBRACKET       shift and go to state 34

    block                          shift and go to state 210

state 188

    (65) print -> PRINT LPAR par_call printx RPAR par_call2 .

    INT             reduce using rule 65 (print -> PRINT LPAR par_call printx RPAR par_call2 .)
    FLOAT           reduce using rule 65 (print -> PRINT LPAR par_call printx RPAR par_call2 .)
    BOOLEAN         reduce using rule 65 (print -> PRINT LPAR par_call printx RPAR par_call2 .)
    ID              reduce using rule 65 (print -> PRINT LPAR par_call printx RPAR par_call2 .)
    IF              reduce using rule 65 (print -> PRINT LPAR par_call printx RPAR par_call2 .)
    WHILE           reduce using rule 65 (print -> PRINT LPAR par_call printx RPAR par_call2 .)
    PRINT           reduce using rule 65 (print -> PRINT LPAR par_call printx RPAR par_call2 .)
    LIST            reduce using rule 65 (print -> PRINT LPAR par_call printx RPAR par_call2 .)
    CAT             reduce using rule 65 (print -> PRINT LPAR par_call printx RPAR par_call2 .)
    ADD             reduce using rule 65 (print -> PRINT LPAR par_call printx RPAR par_call2 .)
    RETURN          reduce using rule 65 (print -> PRINT LPAR par_call printx RPAR par_call2 .)
    RCBRACKET       reduce using rule 65 (print -> PRINT LPAR par_call printx RPAR par_call2 .)


state 189

    (71) printx -> call PLUS op_val . printx
    (66) printx -> . expression
    (67) printx -> . ID id_val
    (68) printx -> . call
    (69) printx -> . expression PLUS op_val printx
    (70) printx -> . ID id_val PLUS op_val printx
    (71) printx -> . call PLUS op_val printx
    (48) expression -> . exp
    (49) expression -> . exp COMPARISON op_val expression
    (105) call -> . ID id_call LPAR par_call RPAR par_call2
    (106) call -> . ID id_call LPAR par_call params RPAR par_call2
    (50) exp -> . termino
    (51) exp -> . termino PLUS op_val exp
    (52) exp -> . termino MINUS op_val exp
    (53) termino -> . factor
    (54) termino -> . factor MULTIPLY op_val termino
    (55) termino -> . factor DIVIDE op_val termino
    (58) factor -> . LPAR expression RPAR
    (59) factor -> . MINUS varcte
    (60) factor -> . varcte termino_val
    (61) varcte -> . ID
    (62) varcte -> . NUMINT
    (63) varcte -> . NUMFLOAT
    (64) varcte -> . BOOLEANTYPE

    ID              shift and go to state 138
    LPAR            shift and go to state 36
    MINUS           shift and go to state 39
    NUMINT          shift and go to state 44
    NUMFLOAT        shift and go to state 37
    BOOLEANTYPE     shift and go to state 47

    factor                         shift and go to state 41
    varcte                         shift and go to state 40
    printx                         shift and go to state 211
    call                           shift and go to state 137
    termino                        shift and go to state 38
    exp                            shift and go to state 46
    expression                     shift and go to state 139

state 190

    (70) printx -> ID id_val PLUS . op_val printx
    (57) op_val -> .

    ID              reduce using rule 57 (op_val -> .)
    LPAR            reduce using rule 57 (op_val -> .)
    MINUS           reduce using rule 57 (op_val -> .)
    NUMINT          reduce using rule 57 (op_val -> .)
    NUMFLOAT        reduce using rule 57 (op_val -> .)
    BOOLEANTYPE     reduce using rule 57 (op_val -> .)

    op_val                         shift and go to state 212

state 191

    (69) printx -> expression PLUS op_val . printx
    (66) printx -> . expression
    (67) printx -> . ID id_val
    (68) printx -> . call
    (69) printx -> . expression PLUS op_val printx
    (70) printx -> . ID id_val PLUS op_val printx
    (71) printx -> . call PLUS op_val printx
    (48) expression -> . exp
    (49) expression -> . exp COMPARISON op_val expression
    (105) call -> . ID id_call LPAR par_call RPAR par_call2
    (106) call -> . ID id_call LPAR par_call params RPAR par_call2
    (50) exp -> . termino
    (51) exp -> . termino PLUS op_val exp
    (52) exp -> . termino MINUS op_val exp
    (53) termino -> . factor
    (54) termino -> . factor MULTIPLY op_val termino
    (55) termino -> . factor DIVIDE op_val termino
    (58) factor -> . LPAR expression RPAR
    (59) factor -> . MINUS varcte
    (60) factor -> . varcte termino_val
    (61) varcte -> . ID
    (62) varcte -> . NUMINT
    (63) varcte -> . NUMFLOAT
    (64) varcte -> . BOOLEANTYPE

    ID              shift and go to state 138
    LPAR            shift and go to state 36
    MINUS           shift and go to state 39
    NUMINT          shift and go to state 44
    NUMFLOAT        shift and go to state 37
    BOOLEANTYPE     shift and go to state 47

    factor                         shift and go to state 41
    varcte                         shift and go to state 40
    printx                         shift and go to state 213
    call                           shift and go to state 137
    termino                        shift and go to state 38
    exp                            shift and go to state 46
    expression                     shift and go to state 139

state 192

    (85) list -> LIST idCheck_List EQUAL LBRACKET listx RBRACKET .

    INT             reduce using rule 85 (list -> LIST idCheck_List EQUAL LBRACKET listx RBRACKET .)
    FLOAT           reduce using rule 85 (list -> LIST idCheck_List EQUAL LBRACKET listx RBRACKET .)
    BOOLEAN         reduce using rule 85 (list -> LIST idCheck_List EQUAL LBRACKET listx RBRACKET .)
    ID              reduce using rule 85 (list -> LIST idCheck_List EQUAL LBRACKET listx RBRACKET .)
    IF              reduce using rule 85 (list -> LIST idCheck_List EQUAL LBRACKET listx RBRACKET .)
    WHILE           reduce using rule 85 (list -> LIST idCheck_List EQUAL LBRACKET listx RBRACKET .)
    PRINT           reduce using rule 85 (list -> LIST idCheck_List EQUAL LBRACKET listx RBRACKET .)
    LIST            reduce using rule 85 (list -> LIST idCheck_List EQUAL LBRACKET listx RBRACKET .)
    CAT             reduce using rule 85 (list -> LIST idCheck_List EQUAL LBRACKET listx RBRACKET .)
    ADD             reduce using rule 85 (list -> LIST idCheck_List EQUAL LBRACKET listx RBRACKET .)
    RETURN          reduce using rule 85 (list -> LIST idCheck_List EQUAL LBRACKET listx RBRACKET .)
    RCBRACKET       reduce using rule 85 (list -> LIST idCheck_List EQUAL LBRACKET listx RBRACKET .)


state 193

    (88) listx -> NUMINT id_param .
    (89) listx -> NUMINT id_param . COMA listx

    RBRACKET        reduce using rule 88 (listx -> NUMINT id_param .)
    COMA            shift and go to state 214


state 194

    (90) listx -> NUMFLOAT id_param .
    (91) listx -> NUMFLOAT id_param . COMA listx

    RBRACKET        reduce using rule 90 (listx -> NUMFLOAT id_param .)
    COMA            shift and go to state 215


state 195

    (86) listx -> ID id_param .
    (87) listx -> ID id_param . COMA listx

    RBRACKET        reduce using rule 86 (listx -> ID id_param .)
    COMA            shift and go to state 216


state 196

    (78) condition -> IF LPAR vaciaList RPAR cond_1 block . else cond_2
    (79) else -> . ELSE cond_else block
    (80) else -> . empty
    (118) empty -> .

    ELSE            shift and go to state 217
    INT             reduce using rule 118 (empty -> .)
    FLOAT           reduce using rule 118 (empty -> .)
    BOOLEAN         reduce using rule 118 (empty -> .)
    ID              reduce using rule 118 (empty -> .)
    IF              reduce using rule 118 (empty -> .)
    WHILE           reduce using rule 118 (empty -> .)
    PRINT           reduce using rule 118 (empty -> .)
    LIST            reduce using rule 118 (empty -> .)
    CAT             reduce using rule 118 (empty -> .)
    ADD             reduce using rule 118 (empty -> .)
    RETURN          reduce using rule 118 (empty -> .)
    RCBRACKET       reduce using rule 118 (empty -> .)

    else                           shift and go to state 219
    empty                          shift and go to state 218

state 197

    (84) vaciaList -> ID idCheck_Add POINT VACIA . LPAR RPAR

    LPAR            shift and go to state 220


state 198

    (77) condition -> IF LPAR expression RPAR cond_1 block . else cond_2
    (79) else -> . ELSE cond_else block
    (80) else -> . empty
    (118) empty -> .

    ELSE            shift and go to state 217
    INT             reduce using rule 118 (empty -> .)
    FLOAT           reduce using rule 118 (empty -> .)
    BOOLEAN         reduce using rule 118 (empty -> .)
    ID              reduce using rule 118 (empty -> .)
    IF              reduce using rule 118 (empty -> .)
    WHILE           reduce using rule 118 (empty -> .)
    PRINT           reduce using rule 118 (empty -> .)
    LIST            reduce using rule 118 (empty -> .)
    CAT             reduce using rule 118 (empty -> .)
    ADD             reduce using rule 118 (empty -> .)
    RETURN          reduce using rule 118 (empty -> .)
    RCBRACKET       reduce using rule 118 (empty -> .)

    else                           shift and go to state 221
    empty                          shift and go to state 218

state 199

    (114) move -> CAT POINT MOVE LPAR NUMINT COMA . NUMINT RPAR

    NUMINT          shift and go to state 222


state 200

    (103) find -> ID idCheck_Add POINT FIND LPAR NUMINT . RPAR

    RPAR            shift and go to state 223


state 201

    (104) printList -> ID idCheck_Add POINT PRINTLIST LPAR RPAR .

    INT             reduce using rule 104 (printList -> ID idCheck_Add POINT PRINTLIST LPAR RPAR .)
    FLOAT           reduce using rule 104 (printList -> ID idCheck_Add POINT PRINTLIST LPAR RPAR .)
    BOOLEAN         reduce using rule 104 (printList -> ID idCheck_Add POINT PRINTLIST LPAR RPAR .)
    ID              reduce using rule 104 (printList -> ID idCheck_Add POINT PRINTLIST LPAR RPAR .)
    IF              reduce using rule 104 (printList -> ID idCheck_Add POINT PRINTLIST LPAR RPAR .)
    WHILE           reduce using rule 104 (printList -> ID idCheck_Add POINT PRINTLIST LPAR RPAR .)
    PRINT           reduce using rule 104 (printList -> ID idCheck_Add POINT PRINTLIST LPAR RPAR .)
    LIST            reduce using rule 104 (printList -> ID idCheck_Add POINT PRINTLIST LPAR RPAR .)
    CAT             reduce using rule 104 (printList -> ID idCheck_Add POINT PRINTLIST LPAR RPAR .)
    ADD             reduce using rule 104 (printList -> ID idCheck_Add POINT PRINTLIST LPAR RPAR .)
    RETURN          reduce using rule 104 (printList -> ID idCheck_Add POINT PRINTLIST LPAR RPAR .)
    RCBRACKET       reduce using rule 104 (printList -> ID idCheck_Add POINT PRINTLIST LPAR RPAR .)


state 202

    (97) listx_add -> NUMINT . id_param2
    (95) id_param2 -> .

    RPAR            reduce using rule 95 (id_param2 -> .)

    id_param2                      shift and go to state 224

state 203

    (96) listx_add -> ID . id_param2
    (95) id_param2 -> .

    RPAR            reduce using rule 95 (id_param2 -> .)

    id_param2                      shift and go to state 225

state 204

    (98) listx_add -> NUMFLOAT . id_param2
    (95) id_param2 -> .

    RPAR            reduce using rule 95 (id_param2 -> .)

    id_param2                      shift and go to state 226

state 205

    (99) add -> ID idCheck_Add POINT ADD LPAR listx_add . RPAR

    RPAR            shift and go to state 227


state 206

    (106) call -> ID id_call LPAR par_call params RPAR par_call2 .

    PLUS            reduce using rule 106 (call -> ID id_call LPAR par_call params RPAR par_call2 .)
    RPAR            reduce using rule 106 (call -> ID id_call LPAR par_call params RPAR par_call2 .)
    INT             reduce using rule 106 (call -> ID id_call LPAR par_call params RPAR par_call2 .)
    FLOAT           reduce using rule 106 (call -> ID id_call LPAR par_call params RPAR par_call2 .)
    BOOLEAN         reduce using rule 106 (call -> ID id_call LPAR par_call params RPAR par_call2 .)
    ID              reduce using rule 106 (call -> ID id_call LPAR par_call params RPAR par_call2 .)
    IF              reduce using rule 106 (call -> ID id_call LPAR par_call params RPAR par_call2 .)
    WHILE           reduce using rule 106 (call -> ID id_call LPAR par_call params RPAR par_call2 .)
    PRINT           reduce using rule 106 (call -> ID id_call LPAR par_call params RPAR par_call2 .)
    LIST            reduce using rule 106 (call -> ID id_call LPAR par_call params RPAR par_call2 .)
    CAT             reduce using rule 106 (call -> ID id_call LPAR par_call params RPAR par_call2 .)
    ADD             reduce using rule 106 (call -> ID id_call LPAR par_call params RPAR par_call2 .)
    RETURN          reduce using rule 106 (call -> ID id_call LPAR par_call params RPAR par_call2 .)
    RCBRACKET       reduce using rule 106 (call -> ID id_call LPAR par_call params RPAR par_call2 .)
    FUNC            reduce using rule 106 (call -> ID id_call LPAR par_call params RPAR par_call2 .)
    MAIN            reduce using rule 106 (call -> ID id_call LPAR par_call params RPAR par_call2 .)


state 207

    (111) params -> ID COMA params .

    RPAR            reduce using rule 111 (params -> ID COMA params .)


state 208

    (110) params -> expression COMA params .

    RPAR            reduce using rule 110 (params -> expression COMA params .)


state 209

    (73) cycle -> WHILE cycle_1 LPAR vaciaList RPAR cycle_2 block . cycle_3
    (76) cycle_3 -> .

    INT             reduce using rule 76 (cycle_3 -> .)
    FLOAT           reduce using rule 76 (cycle_3 -> .)
    BOOLEAN         reduce using rule 76 (cycle_3 -> .)
    ID              reduce using rule 76 (cycle_3 -> .)
    IF              reduce using rule 76 (cycle_3 -> .)
    WHILE           reduce using rule 76 (cycle_3 -> .)
    PRINT           reduce using rule 76 (cycle_3 -> .)
    LIST            reduce using rule 76 (cycle_3 -> .)
    CAT             reduce using rule 76 (cycle_3 -> .)
    ADD             reduce using rule 76 (cycle_3 -> .)
    RETURN          reduce using rule 76 (cycle_3 -> .)
    RCBRACKET       reduce using rule 76 (cycle_3 -> .)

    cycle_3                        shift and go to state 228

state 210

    (72) cycle -> WHILE cycle_1 LPAR expression RPAR cycle_2 block . cycle_3
    (76) cycle_3 -> .

    INT             reduce using rule 76 (cycle_3 -> .)
    FLOAT           reduce using rule 76 (cycle_3 -> .)
    BOOLEAN         reduce using rule 76 (cycle_3 -> .)
    ID              reduce using rule 76 (cycle_3 -> .)
    IF              reduce using rule 76 (cycle_3 -> .)
    WHILE           reduce using rule 76 (cycle_3 -> .)
    PRINT           reduce using rule 76 (cycle_3 -> .)
    LIST            reduce using rule 76 (cycle_3 -> .)
    CAT             reduce using rule 76 (cycle_3 -> .)
    ADD             reduce using rule 76 (cycle_3 -> .)
    RETURN          reduce using rule 76 (cycle_3 -> .)
    RCBRACKET       reduce using rule 76 (cycle_3 -> .)

    cycle_3                        shift and go to state 229

state 211

    (71) printx -> call PLUS op_val printx .

    RPAR            reduce using rule 71 (printx -> call PLUS op_val printx .)


state 212

    (70) printx -> ID id_val PLUS op_val . printx
    (66) printx -> . expression
    (67) printx -> . ID id_val
    (68) printx -> . call
    (69) printx -> . expression PLUS op_val printx
    (70) printx -> . ID id_val PLUS op_val printx
    (71) printx -> . call PLUS op_val printx
    (48) expression -> . exp
    (49) expression -> . exp COMPARISON op_val expression
    (105) call -> . ID id_call LPAR par_call RPAR par_call2
    (106) call -> . ID id_call LPAR par_call params RPAR par_call2
    (50) exp -> . termino
    (51) exp -> . termino PLUS op_val exp
    (52) exp -> . termino MINUS op_val exp
    (53) termino -> . factor
    (54) termino -> . factor MULTIPLY op_val termino
    (55) termino -> . factor DIVIDE op_val termino
    (58) factor -> . LPAR expression RPAR
    (59) factor -> . MINUS varcte
    (60) factor -> . varcte termino_val
    (61) varcte -> . ID
    (62) varcte -> . NUMINT
    (63) varcte -> . NUMFLOAT
    (64) varcte -> . BOOLEANTYPE

    ID              shift and go to state 138
    LPAR            shift and go to state 36
    MINUS           shift and go to state 39
    NUMINT          shift and go to state 44
    NUMFLOAT        shift and go to state 37
    BOOLEANTYPE     shift and go to state 47

    factor                         shift and go to state 41
    varcte                         shift and go to state 40
    printx                         shift and go to state 230
    call                           shift and go to state 137
    termino                        shift and go to state 38
    exp                            shift and go to state 46
    expression                     shift and go to state 139

state 213

    (69) printx -> expression PLUS op_val printx .

    RPAR            reduce using rule 69 (printx -> expression PLUS op_val printx .)


state 214

    (89) listx -> NUMINT id_param COMA . listx
    (86) listx -> . ID id_param
    (87) listx -> . ID id_param COMA listx
    (88) listx -> . NUMINT id_param
    (89) listx -> . NUMINT id_param COMA listx
    (90) listx -> . NUMFLOAT id_param
    (91) listx -> . NUMFLOAT id_param COMA listx
    (92) listx -> . empty
    (118) empty -> .

    ID              shift and go to state 167
    NUMINT          shift and go to state 165
    NUMFLOAT        shift and go to state 166
    RBRACKET        reduce using rule 118 (empty -> .)

    empty                          shift and go to state 168
    listx                          shift and go to state 231

state 215

    (91) listx -> NUMFLOAT id_param COMA . listx
    (86) listx -> . ID id_param
    (87) listx -> . ID id_param COMA listx
    (88) listx -> . NUMINT id_param
    (89) listx -> . NUMINT id_param COMA listx
    (90) listx -> . NUMFLOAT id_param
    (91) listx -> . NUMFLOAT id_param COMA listx
    (92) listx -> . empty
    (118) empty -> .

    ID              shift and go to state 167
    NUMINT          shift and go to state 165
    NUMFLOAT        shift and go to state 166
    RBRACKET        reduce using rule 118 (empty -> .)

    empty                          shift and go to state 168
    listx                          shift and go to state 232

state 216

    (87) listx -> ID id_param COMA . listx
    (86) listx -> . ID id_param
    (87) listx -> . ID id_param COMA listx
    (88) listx -> . NUMINT id_param
    (89) listx -> . NUMINT id_param COMA listx
    (90) listx -> . NUMFLOAT id_param
    (91) listx -> . NUMFLOAT id_param COMA listx
    (92) listx -> . empty
    (118) empty -> .

    ID              shift and go to state 167
    NUMINT          shift and go to state 165
    NUMFLOAT        shift and go to state 166
    RBRACKET        reduce using rule 118 (empty -> .)

    empty                          shift and go to state 168
    listx                          shift and go to state 233

state 217

    (79) else -> ELSE . cond_else block
    (83) cond_else -> .

    LCBRACKET       reduce using rule 83 (cond_else -> .)

    cond_else                      shift and go to state 234

state 218

    (80) else -> empty .

    INT             reduce using rule 80 (else -> empty .)
    FLOAT           reduce using rule 80 (else -> empty .)
    BOOLEAN         reduce using rule 80 (else -> empty .)
    ID              reduce using rule 80 (else -> empty .)
    IF              reduce using rule 80 (else -> empty .)
    WHILE           reduce using rule 80 (else -> empty .)
    PRINT           reduce using rule 80 (else -> empty .)
    LIST            reduce using rule 80 (else -> empty .)
    CAT             reduce using rule 80 (else -> empty .)
    ADD             reduce using rule 80 (else -> empty .)
    RETURN          reduce using rule 80 (else -> empty .)
    RCBRACKET       reduce using rule 80 (else -> empty .)


state 219

    (78) condition -> IF LPAR vaciaList RPAR cond_1 block else . cond_2
    (82) cond_2 -> .

    INT             reduce using rule 82 (cond_2 -> .)
    FLOAT           reduce using rule 82 (cond_2 -> .)
    BOOLEAN         reduce using rule 82 (cond_2 -> .)
    ID              reduce using rule 82 (cond_2 -> .)
    IF              reduce using rule 82 (cond_2 -> .)
    WHILE           reduce using rule 82 (cond_2 -> .)
    PRINT           reduce using rule 82 (cond_2 -> .)
    LIST            reduce using rule 82 (cond_2 -> .)
    CAT             reduce using rule 82 (cond_2 -> .)
    ADD             reduce using rule 82 (cond_2 -> .)
    RETURN          reduce using rule 82 (cond_2 -> .)
    RCBRACKET       reduce using rule 82 (cond_2 -> .)

    cond_2                         shift and go to state 235

state 220

    (84) vaciaList -> ID idCheck_Add POINT VACIA LPAR . RPAR

    RPAR            shift and go to state 236


state 221

    (77) condition -> IF LPAR expression RPAR cond_1 block else . cond_2
    (82) cond_2 -> .

    INT             reduce using rule 82 (cond_2 -> .)
    FLOAT           reduce using rule 82 (cond_2 -> .)
    BOOLEAN         reduce using rule 82 (cond_2 -> .)
    ID              reduce using rule 82 (cond_2 -> .)
    IF              reduce using rule 82 (cond_2 -> .)
    WHILE           reduce using rule 82 (cond_2 -> .)
    PRINT           reduce using rule 82 (cond_2 -> .)
    LIST            reduce using rule 82 (cond_2 -> .)
    CAT             reduce using rule 82 (cond_2 -> .)
    ADD             reduce using rule 82 (cond_2 -> .)
    RETURN          reduce using rule 82 (cond_2 -> .)
    RCBRACKET       reduce using rule 82 (cond_2 -> .)

    cond_2                         shift and go to state 237

state 222

    (114) move -> CAT POINT MOVE LPAR NUMINT COMA NUMINT . RPAR

    RPAR            shift and go to state 238


state 223

    (103) find -> ID idCheck_Add POINT FIND LPAR NUMINT RPAR .

    INT             reduce using rule 103 (find -> ID idCheck_Add POINT FIND LPAR NUMINT RPAR .)
    FLOAT           reduce using rule 103 (find -> ID idCheck_Add POINT FIND LPAR NUMINT RPAR .)
    BOOLEAN         reduce using rule 103 (find -> ID idCheck_Add POINT FIND LPAR NUMINT RPAR .)
    ID              reduce using rule 103 (find -> ID idCheck_Add POINT FIND LPAR NUMINT RPAR .)
    IF              reduce using rule 103 (find -> ID idCheck_Add POINT FIND LPAR NUMINT RPAR .)
    WHILE           reduce using rule 103 (find -> ID idCheck_Add POINT FIND LPAR NUMINT RPAR .)
    PRINT           reduce using rule 103 (find -> ID idCheck_Add POINT FIND LPAR NUMINT RPAR .)
    LIST            reduce using rule 103 (find -> ID idCheck_Add POINT FIND LPAR NUMINT RPAR .)
    CAT             reduce using rule 103 (find -> ID idCheck_Add POINT FIND LPAR NUMINT RPAR .)
    ADD             reduce using rule 103 (find -> ID idCheck_Add POINT FIND LPAR NUMINT RPAR .)
    RETURN          reduce using rule 103 (find -> ID idCheck_Add POINT FIND LPAR NUMINT RPAR .)
    RCBRACKET       reduce using rule 103 (find -> ID idCheck_Add POINT FIND LPAR NUMINT RPAR .)


state 224

    (97) listx_add -> NUMINT id_param2 .

    RPAR            reduce using rule 97 (listx_add -> NUMINT id_param2 .)


state 225

    (96) listx_add -> ID id_param2 .

    RPAR            reduce using rule 96 (listx_add -> ID id_param2 .)


state 226

    (98) listx_add -> NUMFLOAT id_param2 .

    RPAR            reduce using rule 98 (listx_add -> NUMFLOAT id_param2 .)


state 227

    (99) add -> ID idCheck_Add POINT ADD LPAR listx_add RPAR .

    INT             reduce using rule 99 (add -> ID idCheck_Add POINT ADD LPAR listx_add RPAR .)
    FLOAT           reduce using rule 99 (add -> ID idCheck_Add POINT ADD LPAR listx_add RPAR .)
    BOOLEAN         reduce using rule 99 (add -> ID idCheck_Add POINT ADD LPAR listx_add RPAR .)
    ID              reduce using rule 99 (add -> ID idCheck_Add POINT ADD LPAR listx_add RPAR .)
    IF              reduce using rule 99 (add -> ID idCheck_Add POINT ADD LPAR listx_add RPAR .)
    WHILE           reduce using rule 99 (add -> ID idCheck_Add POINT ADD LPAR listx_add RPAR .)
    PRINT           reduce using rule 99 (add -> ID idCheck_Add POINT ADD LPAR listx_add RPAR .)
    LIST            reduce using rule 99 (add -> ID idCheck_Add POINT ADD LPAR listx_add RPAR .)
    CAT             reduce using rule 99 (add -> ID idCheck_Add POINT ADD LPAR listx_add RPAR .)
    ADD             reduce using rule 99 (add -> ID idCheck_Add POINT ADD LPAR listx_add RPAR .)
    RETURN          reduce using rule 99 (add -> ID idCheck_Add POINT ADD LPAR listx_add RPAR .)
    RCBRACKET       reduce using rule 99 (add -> ID idCheck_Add POINT ADD LPAR listx_add RPAR .)


state 228

    (73) cycle -> WHILE cycle_1 LPAR vaciaList RPAR cycle_2 block cycle_3 .

    INT             reduce using rule 73 (cycle -> WHILE cycle_1 LPAR vaciaList RPAR cycle_2 block cycle_3 .)
    FLOAT           reduce using rule 73 (cycle -> WHILE cycle_1 LPAR vaciaList RPAR cycle_2 block cycle_3 .)
    BOOLEAN         reduce using rule 73 (cycle -> WHILE cycle_1 LPAR vaciaList RPAR cycle_2 block cycle_3 .)
    ID              reduce using rule 73 (cycle -> WHILE cycle_1 LPAR vaciaList RPAR cycle_2 block cycle_3 .)
    IF              reduce using rule 73 (cycle -> WHILE cycle_1 LPAR vaciaList RPAR cycle_2 block cycle_3 .)
    WHILE           reduce using rule 73 (cycle -> WHILE cycle_1 LPAR vaciaList RPAR cycle_2 block cycle_3 .)
    PRINT           reduce using rule 73 (cycle -> WHILE cycle_1 LPAR vaciaList RPAR cycle_2 block cycle_3 .)
    LIST            reduce using rule 73 (cycle -> WHILE cycle_1 LPAR vaciaList RPAR cycle_2 block cycle_3 .)
    CAT             reduce using rule 73 (cycle -> WHILE cycle_1 LPAR vaciaList RPAR cycle_2 block cycle_3 .)
    ADD             reduce using rule 73 (cycle -> WHILE cycle_1 LPAR vaciaList RPAR cycle_2 block cycle_3 .)
    RETURN          reduce using rule 73 (cycle -> WHILE cycle_1 LPAR vaciaList RPAR cycle_2 block cycle_3 .)
    RCBRACKET       reduce using rule 73 (cycle -> WHILE cycle_1 LPAR vaciaList RPAR cycle_2 block cycle_3 .)


state 229

    (72) cycle -> WHILE cycle_1 LPAR expression RPAR cycle_2 block cycle_3 .

    INT             reduce using rule 72 (cycle -> WHILE cycle_1 LPAR expression RPAR cycle_2 block cycle_3 .)
    FLOAT           reduce using rule 72 (cycle -> WHILE cycle_1 LPAR expression RPAR cycle_2 block cycle_3 .)
    BOOLEAN         reduce using rule 72 (cycle -> WHILE cycle_1 LPAR expression RPAR cycle_2 block cycle_3 .)
    ID              reduce using rule 72 (cycle -> WHILE cycle_1 LPAR expression RPAR cycle_2 block cycle_3 .)
    IF              reduce using rule 72 (cycle -> WHILE cycle_1 LPAR expression RPAR cycle_2 block cycle_3 .)
    WHILE           reduce using rule 72 (cycle -> WHILE cycle_1 LPAR expression RPAR cycle_2 block cycle_3 .)
    PRINT           reduce using rule 72 (cycle -> WHILE cycle_1 LPAR expression RPAR cycle_2 block cycle_3 .)
    LIST            reduce using rule 72 (cycle -> WHILE cycle_1 LPAR expression RPAR cycle_2 block cycle_3 .)
    CAT             reduce using rule 72 (cycle -> WHILE cycle_1 LPAR expression RPAR cycle_2 block cycle_3 .)
    ADD             reduce using rule 72 (cycle -> WHILE cycle_1 LPAR expression RPAR cycle_2 block cycle_3 .)
    RETURN          reduce using rule 72 (cycle -> WHILE cycle_1 LPAR expression RPAR cycle_2 block cycle_3 .)
    RCBRACKET       reduce using rule 72 (cycle -> WHILE cycle_1 LPAR expression RPAR cycle_2 block cycle_3 .)


state 230

    (70) printx -> ID id_val PLUS op_val printx .

    RPAR            reduce using rule 70 (printx -> ID id_val PLUS op_val printx .)


state 231

    (89) listx -> NUMINT id_param COMA listx .

    RBRACKET        reduce using rule 89 (listx -> NUMINT id_param COMA listx .)


state 232

    (91) listx -> NUMFLOAT id_param COMA listx .

    RBRACKET        reduce using rule 91 (listx -> NUMFLOAT id_param COMA listx .)


state 233

    (87) listx -> ID id_param COMA listx .

    RBRACKET        reduce using rule 87 (listx -> ID id_param COMA listx .)


state 234

    (79) else -> ELSE cond_else . block
    (17) block -> . LCBRACKET blockx RCBRACKET

    LCBRACKET       shift and go to state 34

    block                          shift and go to state 239

state 235

    (78) condition -> IF LPAR vaciaList RPAR cond_1 block else cond_2 .

    INT             reduce using rule 78 (condition -> IF LPAR vaciaList RPAR cond_1 block else cond_2 .)
    FLOAT           reduce using rule 78 (condition -> IF LPAR vaciaList RPAR cond_1 block else cond_2 .)
    BOOLEAN         reduce using rule 78 (condition -> IF LPAR vaciaList RPAR cond_1 block else cond_2 .)
    ID              reduce using rule 78 (condition -> IF LPAR vaciaList RPAR cond_1 block else cond_2 .)
    IF              reduce using rule 78 (condition -> IF LPAR vaciaList RPAR cond_1 block else cond_2 .)
    WHILE           reduce using rule 78 (condition -> IF LPAR vaciaList RPAR cond_1 block else cond_2 .)
    PRINT           reduce using rule 78 (condition -> IF LPAR vaciaList RPAR cond_1 block else cond_2 .)
    LIST            reduce using rule 78 (condition -> IF LPAR vaciaList RPAR cond_1 block else cond_2 .)
    CAT             reduce using rule 78 (condition -> IF LPAR vaciaList RPAR cond_1 block else cond_2 .)
    ADD             reduce using rule 78 (condition -> IF LPAR vaciaList RPAR cond_1 block else cond_2 .)
    RETURN          reduce using rule 78 (condition -> IF LPAR vaciaList RPAR cond_1 block else cond_2 .)
    RCBRACKET       reduce using rule 78 (condition -> IF LPAR vaciaList RPAR cond_1 block else cond_2 .)


state 236

    (84) vaciaList -> ID idCheck_Add POINT VACIA LPAR RPAR .

    RPAR            reduce using rule 84 (vaciaList -> ID idCheck_Add POINT VACIA LPAR RPAR .)


state 237

    (77) condition -> IF LPAR expression RPAR cond_1 block else cond_2 .

    INT             reduce using rule 77 (condition -> IF LPAR expression RPAR cond_1 block else cond_2 .)
    FLOAT           reduce using rule 77 (condition -> IF LPAR expression RPAR cond_1 block else cond_2 .)
    BOOLEAN         reduce using rule 77 (condition -> IF LPAR expression RPAR cond_1 block else cond_2 .)
    ID              reduce using rule 77 (condition -> IF LPAR expression RPAR cond_1 block else cond_2 .)
    IF              reduce using rule 77 (condition -> IF LPAR expression RPAR cond_1 block else cond_2 .)
    WHILE           reduce using rule 77 (condition -> IF LPAR expression RPAR cond_1 block else cond_2 .)
    PRINT           reduce using rule 77 (condition -> IF LPAR expression RPAR cond_1 block else cond_2 .)
    LIST            reduce using rule 77 (condition -> IF LPAR expression RPAR cond_1 block else cond_2 .)
    CAT             reduce using rule 77 (condition -> IF LPAR expression RPAR cond_1 block else cond_2 .)
    ADD             reduce using rule 77 (condition -> IF LPAR expression RPAR cond_1 block else cond_2 .)
    RETURN          reduce using rule 77 (condition -> IF LPAR expression RPAR cond_1 block else cond_2 .)
    RCBRACKET       reduce using rule 77 (condition -> IF LPAR expression RPAR cond_1 block else cond_2 .)


state 238

    (114) move -> CAT POINT MOVE LPAR NUMINT COMA NUMINT RPAR .

    INT             reduce using rule 114 (move -> CAT POINT MOVE LPAR NUMINT COMA NUMINT RPAR .)
    FLOAT           reduce using rule 114 (move -> CAT POINT MOVE LPAR NUMINT COMA NUMINT RPAR .)
    BOOLEAN         reduce using rule 114 (move -> CAT POINT MOVE LPAR NUMINT COMA NUMINT RPAR .)
    ID              reduce using rule 114 (move -> CAT POINT MOVE LPAR NUMINT COMA NUMINT RPAR .)
    IF              reduce using rule 114 (move -> CAT POINT MOVE LPAR NUMINT COMA NUMINT RPAR .)
    WHILE           reduce using rule 114 (move -> CAT POINT MOVE LPAR NUMINT COMA NUMINT RPAR .)
    PRINT           reduce using rule 114 (move -> CAT POINT MOVE LPAR NUMINT COMA NUMINT RPAR .)
    LIST            reduce using rule 114 (move -> CAT POINT MOVE LPAR NUMINT COMA NUMINT RPAR .)
    CAT             reduce using rule 114 (move -> CAT POINT MOVE LPAR NUMINT COMA NUMINT RPAR .)
    ADD             reduce using rule 114 (move -> CAT POINT MOVE LPAR NUMINT COMA NUMINT RPAR .)
    RETURN          reduce using rule 114 (move -> CAT POINT MOVE LPAR NUMINT COMA NUMINT RPAR .)
    RCBRACKET       reduce using rule 114 (move -> CAT POINT MOVE LPAR NUMINT COMA NUMINT RPAR .)


state 239

    (79) else -> ELSE cond_else block .

    INT             reduce using rule 79 (else -> ELSE cond_else block .)
    FLOAT           reduce using rule 79 (else -> ELSE cond_else block .)
    BOOLEAN         reduce using rule 79 (else -> ELSE cond_else block .)
    ID              reduce using rule 79 (else -> ELSE cond_else block .)
    IF              reduce using rule 79 (else -> ELSE cond_else block .)
    WHILE           reduce using rule 79 (else -> ELSE cond_else block .)
    PRINT           reduce using rule 79 (else -> ELSE cond_else block .)
    LIST            reduce using rule 79 (else -> ELSE cond_else block .)
    CAT             reduce using rule 79 (else -> ELSE cond_else block .)
    ADD             reduce using rule 79 (else -> ELSE cond_else block .)
    RETURN          reduce using rule 79 (else -> ELSE cond_else block .)
    RCBRACKET       reduce using rule 79 (else -> ELSE cond_else block .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PLUS in state 38 resolved as shift
WARNING: shift/reduce conflict for COMA in state 154 resolved as shift
WARNING: reduce/reduce conflict in state 138 resolved using rule (id_val -> <empty>)
WARNING: rejected rule (varcte -> ID) in state 138
WARNING: reduce/reduce conflict in state 154 resolved using rule (varcte -> ID)
WARNING: rejected rule (params -> ID) in state 154
WARNING: Rule (params -> ID) is never reduced
